<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mingyu Jeon">
<meta name="dcterms.date" content="2023-10-20">

<title>Mingyu Jeon - 보존법칙</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mingyu Jeon</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mgjeon"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">보존법칙</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">physics</div>
                <div class="quarto-category">korean</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Mingyu Jeon </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 20, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#역학적-에너지-보존-법칙" id="toc-역학적-에너지-보존-법칙" class="nav-link active" data-scroll-target="#역학적-에너지-보존-법칙">역학적 에너지 보존 법칙</a>
  <ul class="collapse">
  <li><a href="#퍼텐셜-에너지potential-energy의-정의" id="toc-퍼텐셜-에너지potential-energy의-정의" class="nav-link" data-scroll-target="#퍼텐셜-에너지potential-energy의-정의">퍼텐셜 에너지(Potential Energy)의 정의</a></li>
  </ul></li>
  <li><a href="#운동량-보존-법칙" id="toc-운동량-보존-법칙" class="nav-link" data-scroll-target="#운동량-보존-법칙">운동량 보존 법칙</a></li>
  <li><a href="#각운동량-보존-법칙" id="toc-각운동량-보존-법칙" class="nav-link" data-scroll-target="#각운동량-보존-법칙">각운동량 보존 법칙</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>2018년에 물리학실험 보고서용으로 작성한 글</p>
<section id="역학적-에너지-보존-법칙" class="level2">
<h2 class="anchored" data-anchor-id="역학적-에너지-보존-법칙">역학적 에너지 보존 법칙</h2>
<p>뉴턴의 운동법칙은 근본적으로 미분방정식으로 서술된다. 특히 힘과 가속도와 같은 물리량들은 벡터량이기 때문에 다루기가 쉽지 않다. 이러한 이유로 물리학자들은 스칼라량인 일이라는 개념을 만든 후에, 뉴턴 운동법칙을 수학적으로 약간 조작하여 운동에너지라는 새로운 개념을 만들게 되었다. 그리고 그것을 통해 일-(운동)에너지 정리를 이끌어 내었다. 이 정리는 ’물체에 가해진 알짜힘이 한 일은 물체의 운동에너지 변화량과 같다’라는 사실을 알려준다(<span class="math inline">\mathbf{F} = m \mathbf{a}</span>에서의 <span class="math inline">\mathbf{F}</span>가 알짜힘(합력, net force)이기 때문이다). 일-운동에너지 정리를 식으로 나타내면 다음과 같다.</p>
<p><span class="math display">
W_{\text{알짜 힘}} = \Delta K
</span></p>
<p>이 정리는 수학적으로 유도된 정리이기 때문에, 물체에 가해지는 모든 알짜힘에 대해 성립하는 정리이다. 그러나 물리학자들은 여기서 한발 더 나아가 좌변을 다음과 같이 쓰고 싶어했다.</p>
<p><span class="math display">
-\Delta U = \Delta K
</span></p>
<p>왜냐하면 만약 이렇게 쓸 수만 있다면, <span class="math inline">K</span>라는 양과 <span class="math inline">U</span>라는 양이 ’보존’되기 때문이다. 그런데 다행히도 물리학자들은 중력이나 탄성력, 전기력과 같은 특정한 힘들이 하는 일은 위와 같이 쓸수 있음을 알게 되었고, <span class="math inline">U</span>를 ’위치에너지(퍼텐셜에너지)’라 정의하였다. 또한 퍼텐셜에너지를 정의할 수 있는 힘을 보존력이라고 부르게 되었다. 따라서 다음과 같이 쓸 수 있다.</p>
<p><span class="math display">
W_{\text{보존력}} = -\Delta U_{\text{보존력}}
</span></p>
<p>또한 모든 힘은 이러한 보존력과 보존력이 아닌 힘, 즉 비보존력 두 가지로 나뉜다는 사실을 알게 되었다. 일은 힘과 변위벡터의 내적으로 정의되고, 내적은 수학적으로 분배법칙이 성립하기 때문에 일-운동에너지 정리는 다음과 같이 쓸 수 있다.</p>
<p><span class="math display">
W_{\text{보존력}} + W_{\text{비보존력}} = \Delta K
</span> <span class="math display">
W_{\text{비보존력}} = \Delta K + \Delta U_{\text{보존력}}
</span></p>
<p>이때 물체의 운동에너지와 퍼텐셜에너지의 합을 역학적 에너지라고 정의하게 되면 다음을 얻는다.</p>
<p><span class="math display">
W_{\text{비보존력}} = \Delta E_{\text{역학적}}
</span></p>
<p>따라서 비보존력이 일을 하지 않으면 물체의 역학적 에너지는 일정하게 유지된다. 즉 어떤 물체에 보존력만 일을 한다면 그 물체의 역학적 에너지는 일정하게 유지된다. 바로 이것을 역학적 에너지 보존 법칙이라고 부른다.</p>
<section id="퍼텐셜-에너지potential-energy의-정의" class="level3">
<h3 class="anchored" data-anchor-id="퍼텐셜-에너지potential-energy의-정의">퍼텐셜 에너지(Potential Energy)의 정의</h3>
<ul>
<li>어떤 물체의 위치벡터가 벡터함수 <span class="math inline">\mathbf{r}(t)</span> <span class="math inline">(a\leq t \leq b)</span>로 주어지고, 시간 <span class="math inline">a\leq t \leq b</span> 동안 물체가 움직인 경로가 곡선 <span class="math inline">C</span>이며 그동안 물체에 가해진 힘이 <span class="math inline">\mathbf{F}(\mathbf{r})</span>일 때(또는 물체가 벡터장 <span class="math inline">\mathbf{F}(\mathbf{r})</span>가 있는 공간에서 곡선 <span class="math inline">C</span>를 따라 움직였을 때), <strong>힘 <span class="math inline">\mathbf{F}</span>가 물체에 한 일 <span class="math inline">W</span></strong>는 다음과 같이 정의한다. 이때 <span class="math inline">\rm{d}\mathbf{l} = \rm{d}\mathbf{r} = \mathbf{r}'\rm{d}t</span> 이다.</li>
</ul>
<p><span class="math display">
\begin{align*}
W &amp; = \int_{C} \mathbf{F} \cdot \rm{d}\mathbf{l} \\
&amp; = \int_{a}^{b} \mathbf{F}(\mathbf{r}(t)) \cdot \mathbf{r}'(t)\rm{d}t
\end{align*}
</span></p>
<ul>
<li>어떤 힘 <span class="math inline">\mathbf{F}</span>가 보존력일때, 즉 위치벡터 <span class="math inline">\mathbf{r}(t)</span>에 대한 벡터함수 <span class="math inline">\mathbf{F}(\mathbf{r}(t))</span>가 보존장일때, 다음을 만족하는 스칼라 함수 <span class="math inline">U(\mathbf{r}(t))</span>를 <strong>힘 <span class="math inline">\mathbf{F}</span>에 대한 퍼텐셜 에너지</strong>라고 정의한다.</li>
</ul>
<p><span class="math display">
\mathbf{F}(\mathbf{r}) = -\nabla U(\mathbf{r})
</span></p>
<ul>
<li>어떤 힘 <span class="math inline">\mathbf{F}</span>가 <span class="math inline">\mathbf{F}(\mathbf{r}) = - \nabla U(\mathbf{r})</span>로 주어지는 보존력이고, 위치벡터가 <span class="math inline">\mathbf{r}(t)</span>로 주어지는 물체가 시간 <span class="math inline">a \leq t \leq b</span>동안 힘 <span class="math inline">\mathbf{F}</span>를 받으며 경로 <span class="math inline">C</span>를 따라 움직였다고 하면, 선적분의 기본정리에 의해 다음이 성립한다.</li>
</ul>
<p><span class="math display">
U(\mathbf{r}(b)) - U(\mathbf{r}(a)) = - \int_{C} \mathbf{F} \cdot \rm{d}\mathbf{l}
</span></p>
<ul>
<li>따라서 <strong>보존력 <span class="math inline">\mathbf{F}</span>에 대한 위치 <span class="math inline">\mathbf{r}</span>에서의 퍼텐셜 에너지 <span class="math inline">U(\mathbf{r})</span></strong>은 선적분을 이용해 다음과 같이 쓸 수 있다. 이때 <span class="math inline">\mathbf{r}^{*}</span>는 퍼텐셜 에너지가 0이 되는 임의의 기준점이다.</li>
</ul>
<p><span class="math display">
U(\mathbf{r}) = - \int_{\mathbf{r}^{*}}^{\mathbf{r}} \mathbf{F} \cdot \rm{d} \mathbf{l}
</span></p>
</section>
</section>
<section id="운동량-보존-법칙" class="level2">
<h2 class="anchored" data-anchor-id="운동량-보존-법칙">운동량 보존 법칙</h2>
<p>관성기준계의 원점에 대해 위치벡터가 <span class="math inline">\mathbf{r}_{1}, \mathbf{r}_{2}, \cdots, \mathbf{r}_{n}</span>으로 주어지고, 질량이 각각 <span class="math inline">m_{1}, m_{2}, \cdots, m_{n}</span>인 <span class="math inline">n</span>개의 물체들로 구성된 계를 설정하자. 각 물체는 위치벡터의 첨자에 따라 <span class="math inline">1, 2, \cdots, n</span>번째 물체라고 하겠다. 관성기준계에 대해 물체의 위치벡터를 표현하였으므로, <span class="math inline">i</span>번째 물체에 대해 뉴턴 제 2법칙을 적용하면 다음과 같다. 이때 <span class="math inline">\mathbf{F}_{\text{내력}, i}</span>는 <span class="math inline">i</span>번째 물체를 제외한 계 내부의 <span class="math inline">n-1</span>개의 물체들이 <span class="math inline">i</span>번째 물체에 작용하는 힘들의 합력이고, <span class="math inline">\mathbf{F}_{\text{외력}, i}</span>는 주어진 계 외부의 물체들이 <span class="math inline">i</span>번째 물체에 작용하는 힘들의 합력이다. 또한 <span class="math inline">\mathbf{v}_{i} = \displaystyle \frac{d}{dt} \mathbf{r}_{i}</span>이다.</p>
<p><span class="math display">
\mathbf{F}_{\text{내력}, i} + \mathbf{F}_{\text{외력}, i} = m_{i} \frac{d}{dt} \mathbf{v}_{i}
</span></p>
<p>이때 뉴턴 제 3법칙에 의해</p>
<p><span class="math display">
\sum_{i=1}^{n} \mathbf{F}_{\text{내력}, i} = \mathbf{0}
</span></p>
<p>이 성립하고, 물체의 질량이 시간에 대해 변하지 않는다는 가정을 한다면</p>
<p><span class="math display">
m_{i} \frac{d}{dt} \mathbf{v}_{i} = \frac{d}{dt} (m_{i} \mathbf{v}_{i})
</span></p>
<p>이 성립한다. 따라서 <span class="math inline">i</span>번째 물체에 대한 뉴턴 운동방정식 양변에 시그마를 취하면 다음과 같다. 이때 <span class="math inline">\mathbf{F}_{\text{외력}} = \displaystyle \sum_{i=1}^{n} \mathbf{F}_{\text{외력}, i}</span>이다.</p>
<p><span class="math display">
\mathbf{F}_{\text{외력}} = \frac{d}{dt} \left( \sum_{i=1}^{n} m_{i} \mathbf{v}_{i} \right)
</span></p>
<p>이때 새로운 물리량 <span class="math inline">\mathbf{p} \equiv m\mathbf{v}</span>를 정의하고, 이것을 (선)운동량이라고 부르자. 그러면 <span class="math inline">i</span>번째 물체의 운동량은 <span class="math inline">\mathbf{p}_{i} = m_{i}\mathbf{v}_{i}</span>이므로, 위 식의 우변은 계 내부 물체들의 총운동량의 시간에 대한 변화율이다. 그러므로 계 내부 물체들의 총운동량을 <span class="math inline">\mathbf{P} = \displaystyle \sum_{i=1}^{n} m_{i} \mathbf{v}_{i}</span>라고 하면 다음 식이 성립한다.</p>
<p><span class="math display">
\mathbf{F}_{\text{외력}} = \frac{d}{dt} \mathbf{P}
</span></p>
<p>여기서 <span class="math inline">\mathbf{F}_{\text{외력}} = \mathbf{0}</span>일때 <span class="math inline">\mathbf{P} = \text{일정}</span> 임을 알수 있다. 즉 어떤 계에 작용하는 알짜 외력이 0이면, 그 계의 총운동량은 시간에 대해 변하지 않는다. 이 사실을 운동량 보존 법칙이라고 한다.</p>
</section>
<section id="각운동량-보존-법칙" class="level2">
<h2 class="anchored" data-anchor-id="각운동량-보존-법칙">각운동량 보존 법칙</h2>
<p>일반적으로 힘 <span class="math inline">\mathbf{F}</span>가 작용하는 위치의 위치벡터를 <span class="math inline">\mathbf{r}</span>이라고 한다면, 그 위치에 있는 물체에 작용하는 토크(돌림힘)는 다음과 같이 주어진다.</p>
<p><span class="math display">
\boldsymbol{\tau} = \mathbf{r} \times \mathbf{F}
</span></p>
<p>만약 이 힘 <span class="math inline">\mathbf{F}</span>가 그 위치에 있는 물체에 작용하는 알짜힘이라면, 뉴턴 제 2법칙에 의해 다음과 같이 나타날 수 있다.</p>
<p><span class="math display">
\boldsymbol{\tau} = \mathbf{r} \times \frac{d\mathbf{p}}{dt}
</span></p>
<p>그런데 다음이 성립하므로</p>
<p><span class="math display">
\begin{align*}
\frac{d}{dt} (\mathbf{r} \times \mathbf{p}) &amp; = \frac{d\mathbf{r}}{dt} \times \mathbf{p} + \mathbf{r} \times \frac{d\mathbf{p}}{dt} \\
&amp; = \mathbf{v} \times m\mathbf{v} + \mathbf{r} \times \frac{d\mathbf{p}}{dt} \\
&amp; = \mathbf{r} \times \frac{d\mathbf{p}}{dt}
\end{align*}
</span></p>
<p>알짜힘에 의한 토크는 다음과 같이 쓸 수 있다. 이때 <span class="math inline">\mathbf{l} = \mathbf{r} \times \mathbf{p}</span>은 각운동량이다.</p>
<p><span class="math display">
\begin{align*}
\boldsymbol{\tau} &amp; = \frac{d}{dt} (\mathbf{r} \times \mathbf{p}) \\
&amp; = \frac{d\mathbf{l}}{dt}
\end{align*}
</span></p>
<p>여러 물체로 이루어진 계에서 각 물체에 대해, 뉴턴 제 2법칙을 반복적으로 적용하면 다음을 얻는다. 이때 <span class="math inline">\mathbf{F}_{\text{ext}}</span>는 계에 대한 외력의 총합이고, <span class="math inline">\mathbf{P}</span>는 계 내부 물체들의 운동량의 총합이다.</p>
<p><span class="math display">
\mathbf{F}_{\text{ext}} = \frac{d\mathbf{P}}{dt}
</span></p>
<p>따라서 <span class="math inline">\mathbf{F}_{\text{ext}}</span>가 작용하는 위치에 작용하는 토크를 <span class="math inline">\boldsymbol{\tau}_{\text{ext}}</span>라고 쓴다면 다음이 성립한다. 이때 <span class="math inline">\mathbf{L}</span>은 계 내부 물체들의 각운동량의 총합이다.</p>
<p><span class="math display">
\boldsymbol{\tau}_{\text{ext}} = \frac{d\mathbf{L}}{dt}
</span></p>
<p>따라서 알짜 외부 토크가 <span class="math inline">\mathbf{0}</span>이면 계의 총 각운동량은 보존됨을 알 수 있고, 이를 각운동량 보존 법칙이라고 한다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/mgjeon\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>