[
  {
    "objectID": "posts/conservation-law/index.html",
    "href": "posts/conservation-law/index.html",
    "title": "ë³´ì¡´ë²•ì¹™",
    "section": "",
    "text": "2018ë…„ì— ë¬¼ë¦¬í•™ì‹¤í—˜ ë³´ê³ ì„œìš©ìœ¼ë¡œ ì‘ì„±í•œ ê¸€"
  },
  {
    "objectID": "posts/conservation-law/index.html#ì—­í•™ì -ì—ë„ˆì§€-ë³´ì¡´-ë²•ì¹™",
    "href": "posts/conservation-law/index.html#ì—­í•™ì -ì—ë„ˆì§€-ë³´ì¡´-ë²•ì¹™",
    "title": "ë³´ì¡´ë²•ì¹™",
    "section": "ì—­í•™ì  ì—ë„ˆì§€ ë³´ì¡´ ë²•ì¹™",
    "text": "ì—­í•™ì  ì—ë„ˆì§€ ë³´ì¡´ ë²•ì¹™\në‰´í„´ì˜ ìš´ë™ë²•ì¹™ì€ ê·¼ë³¸ì ìœ¼ë¡œ ë¯¸ë¶„ë°©ì •ì‹ìœ¼ë¡œ ì„œìˆ ëœë‹¤. íŠ¹íˆ í˜ê³¼ ê°€ì†ë„ì™€ ê°™ì€ ë¬¼ë¦¬ëŸ‰ë“¤ì€ ë²¡í„°ëŸ‰ì´ê¸° ë•Œë¬¸ì— ë‹¤ë£¨ê¸°ê°€ ì‰½ì§€ ì•Šë‹¤. ì´ëŸ¬í•œ ì´ìœ ë¡œ ë¬¼ë¦¬í•™ìë“¤ì€ ìŠ¤ì¹¼ë¼ëŸ‰ì¸ ì¼ì´ë¼ëŠ” ê°œë…ì„ ë§Œë“  í›„ì—, ë‰´í„´ ìš´ë™ë²•ì¹™ì„ ìˆ˜í•™ì ìœ¼ë¡œ ì•½ê°„ ì¡°ì‘í•˜ì—¬ ìš´ë™ì—ë„ˆì§€ë¼ëŠ” ìƒˆë¡œìš´ ê°œë…ì„ ë§Œë“¤ê²Œ ë˜ì—ˆë‹¤. ê·¸ë¦¬ê³  ê·¸ê²ƒì„ í†µí•´ ì¼-(ìš´ë™)ì—ë„ˆì§€ ì •ë¦¬ë¥¼ ì´ëŒì–´ ë‚´ì—ˆë‹¤. ì´ ì •ë¦¬ëŠ” â€™ë¬¼ì²´ì— ê°€í•´ì§„ ì•Œì§œí˜ì´ í•œ ì¼ì€ ë¬¼ì²´ì˜ ìš´ë™ì—ë„ˆì§€ ë³€í™”ëŸ‰ê³¼ ê°™ë‹¤â€™ë¼ëŠ” ì‚¬ì‹¤ì„ ì•Œë ¤ì¤€ë‹¤(\\mathbf{F} = m \\mathbf{a}ì—ì„œì˜ \\mathbf{F}ê°€ ì•Œì§œí˜(í•©ë ¥, net force)ì´ê¸° ë•Œë¬¸ì´ë‹¤). ì¼-ìš´ë™ì—ë„ˆì§€ ì •ë¦¬ë¥¼ ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\nW_{\\text{ì•Œì§œ í˜}} = \\Delta K\n\nì´ ì •ë¦¬ëŠ” ìˆ˜í•™ì ìœ¼ë¡œ ìœ ë„ëœ ì •ë¦¬ì´ê¸° ë•Œë¬¸ì—, ë¬¼ì²´ì— ê°€í•´ì§€ëŠ” ëª¨ë“  ì•Œì§œí˜ì— ëŒ€í•´ ì„±ë¦½í•˜ëŠ” ì •ë¦¬ì´ë‹¤. ê·¸ëŸ¬ë‚˜ ë¬¼ë¦¬í•™ìë“¤ì€ ì—¬ê¸°ì„œ í•œë°œ ë” ë‚˜ì•„ê°€ ì¢Œë³€ì„ ë‹¤ìŒê³¼ ê°™ì´ ì“°ê³  ì‹¶ì–´í–ˆë‹¤.\n\n-\\Delta U = \\Delta K\n\nì™œëƒí•˜ë©´ ë§Œì•½ ì´ë ‡ê²Œ ì“¸ ìˆ˜ë§Œ ìˆë‹¤ë©´, Kë¼ëŠ” ì–‘ê³¼ Uë¼ëŠ” ì–‘ì´ â€™ë³´ì¡´â€™ë˜ê¸° ë•Œë¬¸ì´ë‹¤. ê·¸ëŸ°ë° ë‹¤í–‰íˆë„ ë¬¼ë¦¬í•™ìë“¤ì€ ì¤‘ë ¥ì´ë‚˜ íƒ„ì„±ë ¥, ì „ê¸°ë ¥ê³¼ ê°™ì€ íŠ¹ì •í•œ í˜ë“¤ì´ í•˜ëŠ” ì¼ì€ ìœ„ì™€ ê°™ì´ ì“¸ìˆ˜ ìˆìŒì„ ì•Œê²Œ ë˜ì—ˆê³ , Uë¥¼ â€™ìœ„ì¹˜ì—ë„ˆì§€(í¼í…ì…œì—ë„ˆì§€)â€™ë¼ ì •ì˜í•˜ì˜€ë‹¤. ë˜í•œ í¼í…ì…œì—ë„ˆì§€ë¥¼ ì •ì˜í•  ìˆ˜ ìˆëŠ” í˜ì„ ë³´ì¡´ë ¥ì´ë¼ê³  ë¶€ë¥´ê²Œ ë˜ì—ˆë‹¤. ë”°ë¼ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆë‹¤.\n\nW_{\\text{ë³´ì¡´ë ¥}} = -\\Delta U_{\\text{ë³´ì¡´ë ¥}}\n\në˜í•œ ëª¨ë“  í˜ì€ ì´ëŸ¬í•œ ë³´ì¡´ë ¥ê³¼ ë³´ì¡´ë ¥ì´ ì•„ë‹Œ í˜, ì¦‰ ë¹„ë³´ì¡´ë ¥ ë‘ ê°€ì§€ë¡œ ë‚˜ë‰œë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œê²Œ ë˜ì—ˆë‹¤. ì¼ì€ í˜ê³¼ ë³€ìœ„ë²¡í„°ì˜ ë‚´ì ìœ¼ë¡œ ì •ì˜ë˜ê³ , ë‚´ì ì€ ìˆ˜í•™ì ìœ¼ë¡œ ë¶„ë°°ë²•ì¹™ì´ ì„±ë¦½í•˜ê¸° ë•Œë¬¸ì— ì¼-ìš´ë™ì—ë„ˆì§€ ì •ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆë‹¤.\n\nW_{\\text{ë³´ì¡´ë ¥}} + W_{\\text{ë¹„ë³´ì¡´ë ¥}} = \\Delta K\n \nW_{\\text{ë¹„ë³´ì¡´ë ¥}} = \\Delta K + \\Delta U_{\\text{ë³´ì¡´ë ¥}}\n\nì´ë•Œ ë¬¼ì²´ì˜ ìš´ë™ì—ë„ˆì§€ì™€ í¼í…ì…œì—ë„ˆì§€ì˜ í•©ì„ ì—­í•™ì  ì—ë„ˆì§€ë¼ê³  ì •ì˜í•˜ê²Œ ë˜ë©´ ë‹¤ìŒì„ ì–»ëŠ”ë‹¤.\n\nW_{\\text{ë¹„ë³´ì¡´ë ¥}} = \\Delta E_{\\text{ì—­í•™ì }}\n\në”°ë¼ì„œ ë¹„ë³´ì¡´ë ¥ì´ ì¼ì„ í•˜ì§€ ì•Šìœ¼ë©´ ë¬¼ì²´ì˜ ì—­í•™ì  ì—ë„ˆì§€ëŠ” ì¼ì •í•˜ê²Œ ìœ ì§€ëœë‹¤. ì¦‰ ì–´ë–¤ ë¬¼ì²´ì— ë³´ì¡´ë ¥ë§Œ ì¼ì„ í•œë‹¤ë©´ ê·¸ ë¬¼ì²´ì˜ ì—­í•™ì  ì—ë„ˆì§€ëŠ” ì¼ì •í•˜ê²Œ ìœ ì§€ëœë‹¤. ë°”ë¡œ ì´ê²ƒì„ ì—­í•™ì  ì—ë„ˆì§€ ë³´ì¡´ ë²•ì¹™ì´ë¼ê³  ë¶€ë¥¸ë‹¤.\n\ní¼í…ì…œ ì—ë„ˆì§€(Potential Energy)ì˜ ì •ì˜\n\nì–´ë–¤ ë¬¼ì²´ì˜ ìœ„ì¹˜ë²¡í„°ê°€ ë²¡í„°í•¨ìˆ˜ \\mathbf{r}(t) (a\\leq t \\leq b)ë¡œ ì£¼ì–´ì§€ê³ , ì‹œê°„ a\\leq t \\leq b ë™ì•ˆ ë¬¼ì²´ê°€ ì›€ì§ì¸ ê²½ë¡œê°€ ê³¡ì„  Cì´ë©° ê·¸ë™ì•ˆ ë¬¼ì²´ì— ê°€í•´ì§„ í˜ì´ \\mathbf{F}(\\mathbf{r})ì¼ ë•Œ(ë˜ëŠ” ë¬¼ì²´ê°€ ë²¡í„°ì¥ \\mathbf{F}(\\mathbf{r})ê°€ ìˆëŠ” ê³µê°„ì—ì„œ ê³¡ì„  Cë¥¼ ë”°ë¼ ì›€ì§ì˜€ì„ ë•Œ), í˜ \\mathbf{F}ê°€ ë¬¼ì²´ì— í•œ ì¼ WëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤. ì´ë•Œ \\rm{d}\\mathbf{l} = \\rm{d}\\mathbf{r} = \\mathbf{r}'\\rm{d}t ì´ë‹¤.\n\n\n\\begin{align*}\nW & = \\int_{C} \\mathbf{F} \\cdot \\rm{d}\\mathbf{l} \\\\\n& = \\int_{a}^{b} \\mathbf{F}(\\mathbf{r}(t)) \\cdot \\mathbf{r}'(t)\\rm{d}t\n\\end{align*}\n\n\nì–´ë–¤ í˜ \\mathbf{F}ê°€ ë³´ì¡´ë ¥ì¼ë•Œ, ì¦‰ ìœ„ì¹˜ë²¡í„° \\mathbf{r}(t)ì— ëŒ€í•œ ë²¡í„°í•¨ìˆ˜ \\mathbf{F}(\\mathbf{r}(t))ê°€ ë³´ì¡´ì¥ì¼ë•Œ, ë‹¤ìŒì„ ë§Œì¡±í•˜ëŠ” ìŠ¤ì¹¼ë¼ í•¨ìˆ˜ U(\\mathbf{r}(t))ë¥¼ í˜ \\mathbf{F}ì— ëŒ€í•œ í¼í…ì…œ ì—ë„ˆì§€ë¼ê³  ì •ì˜í•œë‹¤.\n\n\n\\mathbf{F}(\\mathbf{r}) = -\\nabla U(\\mathbf{r})\n\n\nì–´ë–¤ í˜ \\mathbf{F}ê°€ \\mathbf{F}(\\mathbf{r}) = - \\nabla U(\\mathbf{r})ë¡œ ì£¼ì–´ì§€ëŠ” ë³´ì¡´ë ¥ì´ê³ , ìœ„ì¹˜ë²¡í„°ê°€ \\mathbf{r}(t)ë¡œ ì£¼ì–´ì§€ëŠ” ë¬¼ì²´ê°€ ì‹œê°„ a \\leq t \\leq bë™ì•ˆ í˜ \\mathbf{F}ë¥¼ ë°›ìœ¼ë©° ê²½ë¡œ Cë¥¼ ë”°ë¼ ì›€ì§ì˜€ë‹¤ê³  í•˜ë©´, ì„ ì ë¶„ì˜ ê¸°ë³¸ì •ë¦¬ì— ì˜í•´ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.\n\n\nU(\\mathbf{r}(b)) - U(\\mathbf{r}(a)) = - \\int_{C} \\mathbf{F} \\cdot \\rm{d}\\mathbf{l}\n\n\në”°ë¼ì„œ ë³´ì¡´ë ¥ \\mathbf{F}ì— ëŒ€í•œ ìœ„ì¹˜ \\mathbf{r}ì—ì„œì˜ í¼í…ì…œ ì—ë„ˆì§€ U(\\mathbf{r})ì€ ì„ ì ë¶„ì„ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆë‹¤. ì´ë•Œ \\mathbf{r}^{*}ëŠ” í¼í…ì…œ ì—ë„ˆì§€ê°€ 0ì´ ë˜ëŠ” ì„ì˜ì˜ ê¸°ì¤€ì ì´ë‹¤.\n\n\nU(\\mathbf{r}) = - \\int_{\\mathbf{r}^{*}}^{\\mathbf{r}} \\mathbf{F} \\cdot \\rm{d} \\mathbf{l}"
  },
  {
    "objectID": "posts/conservation-law/index.html#ìš´ë™ëŸ‰-ë³´ì¡´-ë²•ì¹™",
    "href": "posts/conservation-law/index.html#ìš´ë™ëŸ‰-ë³´ì¡´-ë²•ì¹™",
    "title": "ë³´ì¡´ë²•ì¹™",
    "section": "ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™",
    "text": "ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™\nê´€ì„±ê¸°ì¤€ê³„ì˜ ì›ì ì— ëŒ€í•´ ìœ„ì¹˜ë²¡í„°ê°€ \\mathbf{r}_{1}, \\mathbf{r}_{2}, \\cdots, \\mathbf{r}_{n}ìœ¼ë¡œ ì£¼ì–´ì§€ê³ , ì§ˆëŸ‰ì´ ê°ê° m_{1}, m_{2}, \\cdots, m_{n}ì¸ nê°œì˜ ë¬¼ì²´ë“¤ë¡œ êµ¬ì„±ëœ ê³„ë¥¼ ì„¤ì •í•˜ì. ê° ë¬¼ì²´ëŠ” ìœ„ì¹˜ë²¡í„°ì˜ ì²¨ìì— ë”°ë¼ 1, 2, \\cdots, në²ˆì§¸ ë¬¼ì²´ë¼ê³  í•˜ê² ë‹¤. ê´€ì„±ê¸°ì¤€ê³„ì— ëŒ€í•´ ë¬¼ì²´ì˜ ìœ„ì¹˜ë²¡í„°ë¥¼ í‘œí˜„í•˜ì˜€ìœ¼ë¯€ë¡œ, ië²ˆì§¸ ë¬¼ì²´ì— ëŒ€í•´ ë‰´í„´ ì œ 2ë²•ì¹™ì„ ì ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. ì´ë•Œ \\mathbf{F}_{\\text{ë‚´ë ¥}, i}ëŠ” ië²ˆì§¸ ë¬¼ì²´ë¥¼ ì œì™¸í•œ ê³„ ë‚´ë¶€ì˜ n-1ê°œì˜ ë¬¼ì²´ë“¤ì´ ië²ˆì§¸ ë¬¼ì²´ì— ì‘ìš©í•˜ëŠ” í˜ë“¤ì˜ í•©ë ¥ì´ê³ , \\mathbf{F}_{\\text{ì™¸ë ¥}, i}ëŠ” ì£¼ì–´ì§„ ê³„ ì™¸ë¶€ì˜ ë¬¼ì²´ë“¤ì´ ië²ˆì§¸ ë¬¼ì²´ì— ì‘ìš©í•˜ëŠ” í˜ë“¤ì˜ í•©ë ¥ì´ë‹¤. ë˜í•œ \\mathbf{v}_{i} = \\displaystyle \\frac{d}{dt} \\mathbf{r}_{i}ì´ë‹¤.\n\n\\mathbf{F}_{\\text{ë‚´ë ¥}, i} + \\mathbf{F}_{\\text{ì™¸ë ¥}, i} = m_{i} \\frac{d}{dt} \\mathbf{v}_{i}\n\nì´ë•Œ ë‰´í„´ ì œ 3ë²•ì¹™ì— ì˜í•´\n\n\\sum_{i=1}^{n} \\mathbf{F}_{\\text{ë‚´ë ¥}, i} = \\mathbf{0}\n\nì´ ì„±ë¦½í•˜ê³ , ë¬¼ì²´ì˜ ì§ˆëŸ‰ì´ ì‹œê°„ì— ëŒ€í•´ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê°€ì •ì„ í•œë‹¤ë©´\n\nm_{i} \\frac{d}{dt} \\mathbf{v}_{i} = \\frac{d}{dt} (m_{i} \\mathbf{v}_{i})\n\nì´ ì„±ë¦½í•œë‹¤. ë”°ë¼ì„œ ië²ˆì§¸ ë¬¼ì²´ì— ëŒ€í•œ ë‰´í„´ ìš´ë™ë°©ì •ì‹ ì–‘ë³€ì— ì‹œê·¸ë§ˆë¥¼ ì·¨í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. ì´ë•Œ \\mathbf{F}_{\\text{ì™¸ë ¥}} = \\displaystyle \\sum_{i=1}^{n} \\mathbf{F}_{\\text{ì™¸ë ¥}, i}ì´ë‹¤.\n\n\\mathbf{F}_{\\text{ì™¸ë ¥}} = \\frac{d}{dt} \\left( \\sum_{i=1}^{n} m_{i} \\mathbf{v}_{i} \\right)\n\nì´ë•Œ ìƒˆë¡œìš´ ë¬¼ë¦¬ëŸ‰ \\mathbf{p} \\equiv m\\mathbf{v}ë¥¼ ì •ì˜í•˜ê³ , ì´ê²ƒì„ (ì„ )ìš´ë™ëŸ‰ì´ë¼ê³  ë¶€ë¥´ì. ê·¸ëŸ¬ë©´ ië²ˆì§¸ ë¬¼ì²´ì˜ ìš´ë™ëŸ‰ì€ \\mathbf{p}_{i} = m_{i}\\mathbf{v}_{i}ì´ë¯€ë¡œ, ìœ„ ì‹ì˜ ìš°ë³€ì€ ê³„ ë‚´ë¶€ ë¬¼ì²´ë“¤ì˜ ì´ìš´ë™ëŸ‰ì˜ ì‹œê°„ì— ëŒ€í•œ ë³€í™”ìœ¨ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ê³„ ë‚´ë¶€ ë¬¼ì²´ë“¤ì˜ ì´ìš´ë™ëŸ‰ì„ \\mathbf{P} = \\displaystyle \\sum_{i=1}^{n} m_{i} \\mathbf{v}_{i}ë¼ê³  í•˜ë©´ ë‹¤ìŒ ì‹ì´ ì„±ë¦½í•œë‹¤.\n\n\\mathbf{F}_{\\text{ì™¸ë ¥}} = \\frac{d}{dt} \\mathbf{P}\n\nì—¬ê¸°ì„œ \\mathbf{F}_{\\text{ì™¸ë ¥}} = \\mathbf{0}ì¼ë•Œ \\mathbf{P} = \\text{ì¼ì •} ì„ì„ ì•Œìˆ˜ ìˆë‹¤. ì¦‰ ì–´ë–¤ ê³„ì— ì‘ìš©í•˜ëŠ” ì•Œì§œ ì™¸ë ¥ì´ 0ì´ë©´, ê·¸ ê³„ì˜ ì´ìš´ë™ëŸ‰ì€ ì‹œê°„ì— ëŒ€í•´ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ ì‚¬ì‹¤ì„ ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™ì´ë¼ê³  í•œë‹¤."
  },
  {
    "objectID": "posts/conservation-law/index.html#ê°ìš´ë™ëŸ‰-ë³´ì¡´-ë²•ì¹™",
    "href": "posts/conservation-law/index.html#ê°ìš´ë™ëŸ‰-ë³´ì¡´-ë²•ì¹™",
    "title": "ë³´ì¡´ë²•ì¹™",
    "section": "ê°ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™",
    "text": "ê°ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™\nì¼ë°˜ì ìœ¼ë¡œ í˜ \\mathbf{F}ê°€ ì‘ìš©í•˜ëŠ” ìœ„ì¹˜ì˜ ìœ„ì¹˜ë²¡í„°ë¥¼ \\mathbf{r}ì´ë¼ê³  í•œë‹¤ë©´, ê·¸ ìœ„ì¹˜ì— ìˆëŠ” ë¬¼ì²´ì— ì‘ìš©í•˜ëŠ” í† í¬(ëŒë¦¼í˜)ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§„ë‹¤.\n\n\\boldsymbol{\\tau} = \\mathbf{r} \\times \\mathbf{F}\n\në§Œì•½ ì´ í˜ \\mathbf{F}ê°€ ê·¸ ìœ„ì¹˜ì— ìˆëŠ” ë¬¼ì²´ì— ì‘ìš©í•˜ëŠ” ì•Œì§œí˜ì´ë¼ë©´, ë‰´í„´ ì œ 2ë²•ì¹™ì— ì˜í•´ ë‹¤ìŒê³¼ ê°™ì´ ë‚˜íƒ€ë‚  ìˆ˜ ìˆë‹¤.\n\n\\boldsymbol{\\tau} = \\mathbf{r} \\times \\frac{d\\mathbf{p}}{dt}\n\nê·¸ëŸ°ë° ë‹¤ìŒì´ ì„±ë¦½í•˜ë¯€ë¡œ\n\n\\begin{align*}\n\\frac{d}{dt} (\\mathbf{r} \\times \\mathbf{p}) & = \\frac{d\\mathbf{r}}{dt} \\times \\mathbf{p} + \\mathbf{r} \\times \\frac{d\\mathbf{p}}{dt} \\\\\n& = \\mathbf{v} \\times m\\mathbf{v} + \\mathbf{r} \\times \\frac{d\\mathbf{p}}{dt} \\\\\n& = \\mathbf{r} \\times \\frac{d\\mathbf{p}}{dt}\n\\end{align*}\n\nì•Œì§œí˜ì— ì˜í•œ í† í¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆë‹¤. ì´ë•Œ \\mathbf{l} = \\mathbf{r} \\times \\mathbf{p}ì€ ê°ìš´ë™ëŸ‰ì´ë‹¤.\n\n\\begin{align*}\n\\boldsymbol{\\tau} & = \\frac{d}{dt} (\\mathbf{r} \\times \\mathbf{p}) \\\\\n& = \\frac{d\\mathbf{l}}{dt}\n\\end{align*}\n\nì—¬ëŸ¬ ë¬¼ì²´ë¡œ ì´ë£¨ì–´ì§„ ê³„ì—ì„œ ê° ë¬¼ì²´ì— ëŒ€í•´, ë‰´í„´ ì œ 2ë²•ì¹™ì„ ë°˜ë³µì ìœ¼ë¡œ ì ìš©í•˜ë©´ ë‹¤ìŒì„ ì–»ëŠ”ë‹¤. ì´ë•Œ \\mathbf{F}_{\\text{ext}}ëŠ” ê³„ì— ëŒ€í•œ ì™¸ë ¥ì˜ ì´í•©ì´ê³ , \\mathbf{P}ëŠ” ê³„ ë‚´ë¶€ ë¬¼ì²´ë“¤ì˜ ìš´ë™ëŸ‰ì˜ ì´í•©ì´ë‹¤.\n\n\\mathbf{F}_{\\text{ext}} = \\frac{d\\mathbf{P}}{dt}\n\në”°ë¼ì„œ \\mathbf{F}_{\\text{ext}}ê°€ ì‘ìš©í•˜ëŠ” ìœ„ì¹˜ì— ì‘ìš©í•˜ëŠ” í† í¬ë¥¼ \\boldsymbol{\\tau}_{\\text{ext}}ë¼ê³  ì“´ë‹¤ë©´ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤. ì´ë•Œ \\mathbf{L}ì€ ê³„ ë‚´ë¶€ ë¬¼ì²´ë“¤ì˜ ê°ìš´ë™ëŸ‰ì˜ ì´í•©ì´ë‹¤.\n\n\\boldsymbol{\\tau}_{\\text{ext}} = \\frac{d\\mathbf{L}}{dt}\n\në”°ë¼ì„œ ì•Œì§œ ì™¸ë¶€ í† í¬ê°€ \\mathbf{0}ì´ë©´ ê³„ì˜ ì´ ê°ìš´ë™ëŸ‰ì€ ë³´ì¡´ë¨ì„ ì•Œ ìˆ˜ ìˆê³ , ì´ë¥¼ ê°ìš´ë™ëŸ‰ ë³´ì¡´ ë²•ì¹™ì´ë¼ê³  í•œë‹¤."
  },
  {
    "objectID": "posts/derivative-of-1d-scalar-function/index.html",
    "href": "posts/derivative-of-1d-scalar-function/index.html",
    "title": "Calculating Derivatives of a 1D Scalar Function in Python",
    "section": "",
    "text": "There are four techniques to compute derivatives: hand-coded analytical derivative, finite differentiation, symbolic differentiation, and automatic differentiation (Margossian 2019). In this post, I will demonstrate how to find the derivative of a simple 1D scalar function, f(x) = x^2 + \\sin(3x), using each of these four methods in Python within the interval x \\in [0, \\pi]."
  },
  {
    "objectID": "posts/derivative-of-1d-scalar-function/index.html#hand-coded-analytical-derivative",
    "href": "posts/derivative-of-1d-scalar-function/index.html#hand-coded-analytical-derivative",
    "title": "Calculating Derivatives of a 1D Scalar Function in Python",
    "section": "1 Hand-coded analytical derivative",
    "text": "1 Hand-coded analytical derivative\nYou can find the analytical derivative of the fucntion f(x) = x^2 + \\sin(3x) using the table of derivatives learned in your Calculus course.\n\n\\begin{align*}\n\\frac{d}{dx} f(x) & = \\frac{d}{dx} (x^2 + \\sin(3x)) \\\\\n& = \\frac{d}{dx} x^2 + \\frac{d}{dx} \\sin(3x) \\\\\n& = 2x + 3\\cos(3x)\n\\end{align*}\n\nThus, for every x,\n\nf'(x) = 2x + 3\\cos(3x)\n\nAccording to the previous post where I explained how to draw a 1D scalar function in Python, I will plot f(x) and its derivative f'(x) using Matplotlib.\n\n\nCode\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    \"text.usetex\": True,\n    \"font.family\": \"Helvetica\",\n    \"font.size\": 15,\n    \"figure.figsize\": (8, 6)\n})\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfunc = lambda x: x**2 + np.sin(3*x)\nd_func = lambda x: 2*x + 3*np.cos(3*x)\n\nx = np.linspace(0, np.pi, 100)\nf = func(x)\ndf_dx = d_func(x)\n\nplt.plot(x, f, label=r\"$f(x)$\")\nplt.plot(x, df_dx, label=r\"$f'(x)$\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "posts/derivative-of-1d-scalar-function/index.html#finite-differentiation",
    "href": "posts/derivative-of-1d-scalar-function/index.html#finite-differentiation",
    "title": "Calculating Derivatives of a 1D Scalar Function in Python",
    "section": "2 Finite differentiation",
    "text": "2 Finite differentiation\nYou can derive the following finite differentiation formulae using Taylorâ€™s theorem.\n\n2.1 Finite differentiation formulae\n\nForward difference\n\n1st order accuracy \n  f'(x) = \\frac{f(x+h) - f(x)}{h} + \\mathcal{O}(h)\n  \n2nd order accuracy \n  f'(x) = \\frac{-3f(x) + 4f(x+h) - f(x+2h)}{2h} + \\mathcal{O}(h^2)\n  \n\nBackward difference\n\n1st order accuracy \n  f'(x) = \\frac{f(x) - f(x-h)}{h} + \\mathcal{O}(h)\n  \n2nd order accuracy \n  f'(x) = \\frac{3f(x) - 4f(x-h) + f(x-2h)}{2h} + \\mathcal{O}(h^2)\n  \n\nCentral difference\n\n2nd order accuracy \n  f'(x) = \\frac{f(x+h) - f(x-h)}{2h} + \\mathcal{O}(h^2)\n  \n\n\n\n\n2.2 Implementation using NumPy\nNumPy arrays make the implementation of finite differentitation very straightforward. Itâ€™s important to note that at the left boundary (x=0), I use the forward difference, while at the right boundary (x=\\pi), I use the backward difference. Within the domain (0&lt;x&lt;\\pi), I use the central difference.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfunc = lambda x: x**2 + np.sin(3*x)\n\nx = np.linspace(0, np.pi, 100)\nf = func(x)\n\n# calculate the spacing dx \ndx = x[1]-x[0]\n# you can use np.diff\n# dx = np.diff(x)[0] or\n# dx = np.mean(np.diff(x))\n\n# create an array with the same shape as `f`\ndf_dx = np.zeros_like(f)\n\n# forward difference (1st order) at the left boundary\ndf_dx[0] = (f[1] - f[0]) / dx\n\n# backward difference (1st order) at the right boundary\ndf_dx[-1] = (f[-1] - f[-2]) / dx\n\n# central difference (2nd accuracy) within the domain\ndf_dx[1:-1] = (f[2:] - f[:-2]) / (2*dx)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\ndf_dx_exact = exact_d_func(x)\nplt.plot(x, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x, df_dx, 'r--', lw=3, label=\"finite diff.\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nIn the case of using 1st order accuracy formulae, the errors at the boundaries are\n\nprint('1st order')\nprint(f'dx   : {dx:.4f}')\nprint(f'left : {np.abs(df_dx[0] - df_dx_exact[0]):.4f}')\nprint(f'right: {np.abs(df_dx[-1] - df_dx_exact[-1]):.4f}')\n\n1st order\ndx   : 0.0317\nleft : 0.0272\nright: 0.0272\n\n\nIf we use the 2nd order accuracy formulae at the boundaries instead, we get the following errors:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfunc = lambda x: x**2 + np.sin(3*x)\n\nx = np.linspace(0, np.pi, 100)\nf = func(x)\n\n# calculate the spacing dx \ndx = x[1]-x[0]\n# you can use np.diff\n# dx = np.diff(x)[0] or\n# dx = np.mean(np.diff(x))\n\n# create an array with the same shape as `f`\ndf_dx = np.zeros_like(f)\n\n# forward difference (2nd order) at the left boundary\ndf_dx[0] = (-3*f[0] + 4*f[1] - f[2]) / (2*dx)\n\n# backward difference (2nd order) at the right boundary\ndf_dx[-1] = (3*f[-1] - 4*f[-2] + f[-3]) / (2*dx)\n\n# central difference (2nd accuracy) within the domain\ndf_dx[1:-1] = (f[2:] - f[:-2]) / (2*dx)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\ndf_dx_exact = exact_d_func(x)\nplt.plot(x, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x, df_dx, 'r--', lw=3, label=\"finite diff.\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('2nd order')\nprint(f'dx^2 : {dx**2:.4f}')\nprint(f'left : {np.abs(df_dx[0] - df_dx_exact[0]):.4f}')\nprint(f'right: {np.abs(df_dx[-1] - df_dx_exact[-1]):.4f}')\n\n2nd order\ndx^2 : 0.0010\nleft : 0.0090\nright: 0.0090\n\n\n\nnp.allclose(df_dx_exact, df_dx)\n\nFalse\n\n\n\nnp.allclose(df_dx_exact, df_dx, atol=1e-2)\n\nTrue\n\n\n\n2.2.1 numpy.gradient\nThere is a function for finite differentiation in NumPy.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfunc = lambda x: x**2 + np.sin(3*x)\n\nx = np.linspace(0, np.pi, 100)\nf = func(x)\n\n# calculate the spacing dx \ndx = x[1]-x[0]\n\n# calculate derivatives of `f` using np.gradient (2nd order)\ndf_dx_npgrad = np.gradient(f, dx, axis=0, edge_order=2)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\ndf_dx_exact = exact_d_func(x)\nplt.plot(x, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x, df_dx_npgrad, 'r--', lw=3, label=\"finite diff. (np.gradient)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_npgrad)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThis computes the same value as manually computed.\n\nnp.allclose(df_dx, df_dx_npgrad)\n\nTrue\n\n\n\n\n\n2.3 Implementation using findiff\nThere is a convenient library for finite differentiation in Python: findiff\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom findiff import FinDiff\n\nfunc = lambda x: x**2 + np.sin(3*x)\n\nx = np.linspace(0, np.pi, 100)\nf = func(x)\n\n# calculate the spacing dx \ndx = x[1]-x[0]\n\n# construct the differential operator: FinDiff(axis, spacing, degree)\nd_dx = FinDiff(0, dx, 1) \n\ndf_dx_findiff = d_dx(f)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\ndf_dx_exact = exact_d_func(x)\nplt.plot(x, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x, df_dx_findiff, 'r--', lw=3, label=\"finite diff. (findiff)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_findiff)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nBy default, findiff uses 2nd order accuray.\n\nnp.allclose(df_dx, df_dx_findiff)\n\nTrue\n\n\nYou can also find finite difference coefficients using this library. (see SectionÂ 2.1)\n\nimport findiff\n# coefficients of 2nd order accuracy formulae for 1st derivative\nfindiff.coefficients(deriv=1, acc=2)\n\n{'center': {'coefficients': array([-0.5,  0. ,  0.5]),\n  'offsets': array([-1,  0,  1]),\n  'accuracy': 2},\n 'forward': {'coefficients': array([-1.5,  2. , -0.5]),\n  'offsets': array([0, 1, 2]),\n  'accuracy': 2},\n 'backward': {'coefficients': array([ 0.5, -2. ,  1.5]),\n  'offsets': array([-2, -1,  0]),\n  'accuracy': 2}}\n\n\n\nnp.allclose(df_dx_exact, df_dx_findiff)\n\nFalse\n\n\n\nnp.allclose(df_dx_exact, df_dx_findiff, atol=1e-2)\n\nTrue\n\n\n\n\n2.4 Implementation using numdifftools\nThere is another convenient library for automatic numerical differentiation in Python: numdifftools\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport numdifftools as nd\n\nfunc = lambda x: x**2 + np.sin(3*x)\n\n# construct a derivative function (FD)\nd_func = nd.Derivative(func, n=1)\n\nx = np.linspace(0, np.pi, 100)\ndf_dx_numdifftools = d_func(x)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\ndf_dx_exact = exact_d_func(x)\nplt.plot(x, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x, df_dx_numdifftools, 'r--', lw=3, label=\"finite diff. (numdifftools)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_numdifftools)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nSince this library uses an adaptive finite differences with a Richardson extrapolation methodology, the result is maximally accurate.\n\nnp.allclose(df_dx_exact, df_dx_numdifftools)\n\nTrue"
  },
  {
    "objectID": "posts/derivative-of-1d-scalar-function/index.html#symbolic-differentiation",
    "href": "posts/derivative-of-1d-scalar-function/index.html#symbolic-differentiation",
    "title": "Calculating Derivatives of a 1D Scalar Function in Python",
    "section": "3 Symbolic differentiation",
    "text": "3 Symbolic differentiation\n\n3.1 Implementation using Sympy\nBy using SymPy, we can symbolically differentiate f(x) = x^2 + \\sin(3x)\n\nfrom sympy import symbols, sin, diff\nx = symbols('x')\nf = x**2 + sin(3*x)\nf\n\n\\displaystyle x^{2} + \\sin{\\left(3 x \\right)}\n\n\n\ndf_dx_sympy = diff(f, x)\ndf_dx_sympy\n\n\\displaystyle 2 x + 3 \\cos{\\left(3 x \\right)}\n\n\nAs I mentioned in the previous post, SymPy also supports plotting of a function.\n\nfrom sympy.plotting import plot\np1 = plot(f, (x, 0, np.pi), legend=True, show=False, label=\"$f(x)$\", ylabel='')\np2 = plot(df_dx_sympy, (x, 0, np.pi), legend=True, show=False, label=r\"$f'(x)$\", ylabel='')\np1.extend(p2)\np1.show()"
  },
  {
    "objectID": "posts/derivative-of-1d-scalar-function/index.html#automatic-differentiation",
    "href": "posts/derivative-of-1d-scalar-function/index.html#automatic-differentiation",
    "title": "Calculating Derivatives of a 1D Scalar Function in Python",
    "section": "4 Automatic differentiation",
    "text": "4 Automatic differentiation\n\nIn mathematics and computer algebra, automatic differentiation (auto-differentiation, autodiff, or AD), also called algorithmic differentiation, computational differentiation, is a set of techniques to evaluate the partial derivative of a function specified by a computer program. #\n\nThe efficient implementation of automatic differentiation is quite challenging. However, since the backpropagation is used to minimize loss in neural networks and is essentially a reverse-mode automatic differentiation, most deep learning libraries natively support automatic differentiation tools. In this post, I will demonstrate how to use automatic differentiation in Python with TensorFlow, PyTorch, and JAX.\n\n4.1 Implementation using TensorFlow\n\nTensorFlow is an end-to-end open source platform for machine learning.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\nfunc = lambda x: x**2 + tf.math.sin(3*x)\n\nx = tf.linspace(0.0, tf.constant(np.pi), 100)\n\n# calculate derivatives of `f`\nwith tf.GradientTape() as tape:\n    tape.watch(x)\n    f = func(x)\n    df_dx_tf = tape.gradient(f, x)\n\ndf_dx_tf = df_dx_tf.numpy()\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\nx_numpy = x.numpy()\ndf_dx_exact = exact_d_func(x_numpy)\nplt.plot(x_numpy, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x_numpy, df_dx_tf, 'r--', lw=3, label=\"auto diff. (TensorFlow)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_tf)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show();\n\n\n\n\n\n\n\n\n\nnp.allclose(df_dx_exact, df_dx_tf)\n\nTrue\n\n\n\n\n4.2 Implementation using PyTorch\n\nPyTorch is a Python package that supports tensors and dynamic neural networks in Python with strong GPU acceleration.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\n\nfunc = lambda x: x**2 + torch.sin(3*x)\n\nx = torch.linspace(0, np.pi, 100)\n\n# calculate derivatives of `f`\nx.requires_grad = True\nf = func(x)\ndf_dx_torch = torch.autograd.grad(f, x, grad_outputs=torch.ones_like(f), \n                            retain_graph=True, create_graph=True, allow_unused=True)[0]\n\ndf_dx_torch = df_dx_torch.detach().numpy()\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\nx_numpy = x.detach().numpy()\ndf_dx_exact = exact_d_func(x_numpy)\nplt.plot(x_numpy, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x_numpy, df_dx_torch, 'r--', lw=3, label=\"auto diff. (PyTorch)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_torch)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nnp.allclose(df_dx_exact, df_dx_torch)\n\nTrue\n\n\n\n\n4.3 Implementation using JAX\n\nJAX is Autograd and XLA, brought together for high-performance numerical computing, including large-scale machine learning research.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport jax.numpy as jnp\nimport jax\n\nfunc = lambda x: x**2 + jnp.sin(3*x)\n\nx = jnp.linspace(0, jnp.pi, 100)\n\n# calculate derivatives of `f`\ndf_dx_jax = jax.vmap(jax.grad(func))(x)\n\ndf_dx_jax = np.array(df_dx_jax)\n\n# plot for comparison\nexact_d_func = lambda x: 2*x + 3*np.cos(3*x)\nx_numpy = np.array(x)\ndf_dx_exact = exact_d_func(x_numpy)\nplt.plot(x_numpy, df_dx_exact, 'b-', lw=3, label=\"exact\")\nplt.plot(x_numpy, df_dx_jax, 'r--', lw=3, label=\"auto diff. (JAX)\")\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$f'(x)$\")\nRMSE = np.sqrt(np.mean((df_dx_exact - df_dx_jax)**2))\nplt.title(f\"RMSE: {RMSE:.3e}\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nnp.allclose(df_dx_exact, df_dx_jax)\n\nTrue"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html",
    "title": "Stable Diffusion Inference with Diffusers (high-level)",
    "section": "",
    "text": "Create an image using Diffusers library.\n\n\n\n!pip install -qq diffusers transformers scipy ftfy accelerate\n\n\nimport torch\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ndevice\n\n'cuda'\n\n\n\nprompt = [\"a photograph of an astronaut riding a horse\"]\n\nheight = 512  # default height of Stable Diffusion\nwidth = 512  # default width of Stable Diffusion\n\nnum_inference_steps = 50  # Number of denoising steps\n\nguidance_scale = 7.5  # Scale for classifier-free guidance\n\ngenerator = torch.manual_seed(256)  # Seed generator to create the inital latent noise\n\nbatch_size = 2\n\n\nfrom diffusers import LMSDiscreteScheduler, StableDiffusionPipeline\n\nscheduler = LMSDiscreteScheduler.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", subfolder=\"scheduler\"\n)\npipe = StableDiffusionPipeline.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", scheduler=scheduler\n)\n\n\npipe\n\nStableDiffusionPipeline {\n  \"_class_name\": \"StableDiffusionPipeline\",\n  \"_diffusers_version\": \"0.20.2\",\n  \"_name_or_path\": \"CompVis/stable-diffusion-v1-4\",\n  \"feature_extractor\": [\n    \"transformers\",\n    \"CLIPImageProcessor\"\n  ],\n  \"requires_safety_checker\": true,\n  \"safety_checker\": [\n    \"stable_diffusion\",\n    \"StableDiffusionSafetyChecker\"\n  ],\n  \"scheduler\": [\n    \"diffusers\",\n    \"LMSDiscreteScheduler\"\n  ],\n  \"text_encoder\": [\n    \"transformers\",\n    \"CLIPTextModel\"\n  ],\n  \"tokenizer\": [\n    \"transformers\",\n    \"CLIPTokenizer\"\n  ],\n  \"unet\": [\n    \"diffusers\",\n    \"UNet2DConditionModel\"\n  ],\n  \"vae\": [\n    \"diffusers\",\n    \"AutoencoderKL\"\n  ]\n}\n\n\n\npipe = pipe.to(device)\n\n\n\n\n\npil_images = pipe(\n    prompt=prompt * batch_size,\n    height=height,\n    width=width,\n    num_inference_steps=num_inference_steps,\n    guidance_scale=guidance_scale,\n    generator=generator,\n).images\n\n\nfor pil_image in pil_images:\n    display(pil_image)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPatil et al.Â (2022) Stable Diffusion with ğŸ§¨ Diffusers, https://huggingface.co/blog/stable_diffusion"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#install-and-import-libraries",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#install-and-import-libraries",
    "title": "Stable Diffusion Inference with Diffusers (high-level)",
    "section": "",
    "text": "!pip install -qq diffusers transformers scipy ftfy accelerate\n\n\nimport torch\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ndevice\n\n'cuda'\n\n\n\nprompt = [\"a photograph of an astronaut riding a horse\"]\n\nheight = 512  # default height of Stable Diffusion\nwidth = 512  # default width of Stable Diffusion\n\nnum_inference_steps = 50  # Number of denoising steps\n\nguidance_scale = 7.5  # Scale for classifier-free guidance\n\ngenerator = torch.manual_seed(256)  # Seed generator to create the inital latent noise\n\nbatch_size = 2\n\n\nfrom diffusers import LMSDiscreteScheduler, StableDiffusionPipeline\n\nscheduler = LMSDiscreteScheduler.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", subfolder=\"scheduler\"\n)\npipe = StableDiffusionPipeline.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", scheduler=scheduler\n)\n\n\npipe\n\nStableDiffusionPipeline {\n  \"_class_name\": \"StableDiffusionPipeline\",\n  \"_diffusers_version\": \"0.20.2\",\n  \"_name_or_path\": \"CompVis/stable-diffusion-v1-4\",\n  \"feature_extractor\": [\n    \"transformers\",\n    \"CLIPImageProcessor\"\n  ],\n  \"requires_safety_checker\": true,\n  \"safety_checker\": [\n    \"stable_diffusion\",\n    \"StableDiffusionSafetyChecker\"\n  ],\n  \"scheduler\": [\n    \"diffusers\",\n    \"LMSDiscreteScheduler\"\n  ],\n  \"text_encoder\": [\n    \"transformers\",\n    \"CLIPTextModel\"\n  ],\n  \"tokenizer\": [\n    \"transformers\",\n    \"CLIPTokenizer\"\n  ],\n  \"unet\": [\n    \"diffusers\",\n    \"UNet2DConditionModel\"\n  ],\n  \"vae\": [\n    \"diffusers\",\n    \"AutoencoderKL\"\n  ]\n}\n\n\n\npipe = pipe.to(device)"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#high-level",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#high-level",
    "title": "Stable Diffusion Inference with Diffusers (high-level)",
    "section": "",
    "text": "pil_images = pipe(\n    prompt=prompt * batch_size,\n    height=height,\n    width=width,\n    num_inference_steps=num_inference_steps,\n    guidance_scale=guidance_scale,\n    generator=generator,\n).images\n\n\nfor pil_image in pil_images:\n    display(pil_image)"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#references",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_high_level.html#references",
    "title": "Stable Diffusion Inference with Diffusers (high-level)",
    "section": "",
    "text": "Patil et al.Â (2022) Stable Diffusion with ğŸ§¨ Diffusers, https://huggingface.co/blog/stable_diffusion"
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html",
    "href": "posts/draw-1d-scalar-function/index.html",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "",
    "text": "If you know the mathematical formula of a 1D scalar function y=f(x), then I believe the best tool for drawing 1D scalar functions is Desmos. However, you can also plot the functions in Python using various visualization libraries. In this post, I will draw 1D scalar functions y=x^2 and y=\\sin(x) using basic features of these libraries. Keep in mind that there are many advanced features not covered here, so for more information, refer to the official document of the respective library."
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html#sympy",
    "href": "posts/draw-1d-scalar-function/index.html#sympy",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "SymPy",
    "text": "SymPy\n\nSymPy is a Python library for symbolic mathematics.\n\nEven though SymPyâ€™s strength lies in symbolic computations, it can also be used for drawing 1D scalar functions, see FigureÂ 1.\n\nfrom sympy import symbols, sin\nfrom sympy.plotting import plot \n\nx = symbols('x')\n\np1 = plot(x**2, (x, -2, 2), legend=True, show=False)\np2 = plot(sin(x), (x, -5, 5), legend=True, show=False)\np1.extend(p2)\np1.show()\n\n\n\n\n\n\n\nFigureÂ 1: A plot using sympy\n\n\n\n\n\nThe graph depicts y=x^2 for x \\in [-2, 2] and y=\\sin(x) for x \\in [-5, 5]. The purpose of using different ranges for x is to display both graphs in a single figure without one being much smaller than the other. This is because the values of x^2 rapidly increases as |x| increases, while |\\sin(x)| \\leq 1 always."
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html#data-generation-using-numpy",
    "href": "posts/draw-1d-scalar-function/index.html#data-generation-using-numpy",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "Data generation using NumPy",
    "text": "Data generation using NumPy\n\nNumPy is the fundamental package for scientific computing with Python.\n\nOther visualization libraries usually donâ€™t understand symbolic representation of a function. They just draw (x, y) points in a coordinate plane. Therefore, before you use them, you have to generate (x, y) points using NumPy.\n\nimport numpy as np\n\nx1 = np.linspace(-2, 2, 100)\ny1 = x1**2\n\nx2 = np.linspace(-5, 5, 100)\ny2 = np.sin(x2)\n\nnp.linspace(start, stop, num) creates num evenly spaced numbers within a closed interval [start, stop]. So, x1 is an array containing 100 evenly spaced numbers within the interval [-2, 2], and x2 is the same array but within the interval [-5, 5].\n\nx1\n\narray([-2.        , -1.95959596, -1.91919192, -1.87878788, -1.83838384,\n       -1.7979798 , -1.75757576, -1.71717172, -1.67676768, -1.63636364,\n       -1.5959596 , -1.55555556, -1.51515152, -1.47474747, -1.43434343,\n       -1.39393939, -1.35353535, -1.31313131, -1.27272727, -1.23232323,\n       -1.19191919, -1.15151515, -1.11111111, -1.07070707, -1.03030303,\n       -0.98989899, -0.94949495, -0.90909091, -0.86868687, -0.82828283,\n       -0.78787879, -0.74747475, -0.70707071, -0.66666667, -0.62626263,\n       -0.58585859, -0.54545455, -0.50505051, -0.46464646, -0.42424242,\n       -0.38383838, -0.34343434, -0.3030303 , -0.26262626, -0.22222222,\n       -0.18181818, -0.14141414, -0.1010101 , -0.06060606, -0.02020202,\n        0.02020202,  0.06060606,  0.1010101 ,  0.14141414,  0.18181818,\n        0.22222222,  0.26262626,  0.3030303 ,  0.34343434,  0.38383838,\n        0.42424242,  0.46464646,  0.50505051,  0.54545455,  0.58585859,\n        0.62626263,  0.66666667,  0.70707071,  0.74747475,  0.78787879,\n        0.82828283,  0.86868687,  0.90909091,  0.94949495,  0.98989899,\n        1.03030303,  1.07070707,  1.11111111,  1.15151515,  1.19191919,\n        1.23232323,  1.27272727,  1.31313131,  1.35353535,  1.39393939,\n        1.43434343,  1.47474747,  1.51515152,  1.55555556,  1.5959596 ,\n        1.63636364,  1.67676768,  1.71717172,  1.75757576,  1.7979798 ,\n        1.83838384,  1.87878788,  1.91919192,  1.95959596,  2.        ])\n\n\n\\Delta x for this array is (2 - (-2)) / (100 - 1) = 0.\\overline{04}\n\nnp.isclose(np.diff(x1)[0], (2 - (-2)) / (100 - 1))\n\nTrue\n\n\n\nx2\n\narray([-5.        , -4.8989899 , -4.7979798 , -4.6969697 , -4.5959596 ,\n       -4.49494949, -4.39393939, -4.29292929, -4.19191919, -4.09090909,\n       -3.98989899, -3.88888889, -3.78787879, -3.68686869, -3.58585859,\n       -3.48484848, -3.38383838, -3.28282828, -3.18181818, -3.08080808,\n       -2.97979798, -2.87878788, -2.77777778, -2.67676768, -2.57575758,\n       -2.47474747, -2.37373737, -2.27272727, -2.17171717, -2.07070707,\n       -1.96969697, -1.86868687, -1.76767677, -1.66666667, -1.56565657,\n       -1.46464646, -1.36363636, -1.26262626, -1.16161616, -1.06060606,\n       -0.95959596, -0.85858586, -0.75757576, -0.65656566, -0.55555556,\n       -0.45454545, -0.35353535, -0.25252525, -0.15151515, -0.05050505,\n        0.05050505,  0.15151515,  0.25252525,  0.35353535,  0.45454545,\n        0.55555556,  0.65656566,  0.75757576,  0.85858586,  0.95959596,\n        1.06060606,  1.16161616,  1.26262626,  1.36363636,  1.46464646,\n        1.56565657,  1.66666667,  1.76767677,  1.86868687,  1.96969697,\n        2.07070707,  2.17171717,  2.27272727,  2.37373737,  2.47474747,\n        2.57575758,  2.67676768,  2.77777778,  2.87878788,  2.97979798,\n        3.08080808,  3.18181818,  3.28282828,  3.38383838,  3.48484848,\n        3.58585859,  3.68686869,  3.78787879,  3.88888889,  3.98989899,\n        4.09090909,  4.19191919,  4.29292929,  4.39393939,  4.49494949,\n        4.5959596 ,  4.6969697 ,  4.7979798 ,  4.8989899 ,  5.        ])\n\n\n\\Delta x for this array is (5 - (-5)) / (100 - 1) = 0.\\overline{10}\n\nnp.isclose(np.diff(x2)[0], (5 - (-5)) / (100 - 1))\n\nTrue\n\n\n(x1, y1) points are used to draw the graph of y=x^2, while (x2, y2) points are used for the graph of y=\\sin(x)."
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html#matplotlib",
    "href": "posts/draw-1d-scalar-function/index.html#matplotlib",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "Matplotlib",
    "text": "Matplotlib\n\nMatplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python.\n\nMatplotlib is one of the most popular visualization libraries in Python, see FigureÂ 2.\n\nimport matplotlib.pyplot as plt\n\nplt.plot(x1, y1, label=r'$x^2$')\nplt.plot(x2, y2, label=r'$\\sin x$')\nplt.legend()\nplt.axvline(0, color='k')\nplt.axhline(0, color='k')\nplt.show()\n\n\n\n\n\n\n\nFigureÂ 2: A plot using matplotlib"
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html#pandas",
    "href": "posts/draw-1d-scalar-function/index.html#pandas",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "pandas",
    "text": "pandas\n\npandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language.\n\nSince pandas is a great data analysis tool in Python, it can used for drawing graphs, see FigureÂ 3.\n\nimport pandas as pd \n\ndf1 = pd.DataFrame(data={'x':x1, 'y':y1})\ndf2 = pd.DataFrame(data={'x':x2, 'y':y2})\n\nax = df1.plot(x='x', y='y', label=r'$x^2$')\ndf2.plot(ax=ax, x='x', y='y', label=r'$\\sin x$')\nax.axvline(0, color='k')\nax.axhline(0, color='k')\nplt.show()\n\n\n\n\n\n\n\nFigureÂ 3: A plot using pandas"
  },
  {
    "objectID": "posts/draw-1d-scalar-function/index.html#plotly",
    "href": "posts/draw-1d-scalar-function/index.html#plotly",
    "title": "How to Draw 1D Scalar Functions in Python",
    "section": "Plotly",
    "text": "Plotly\n\nPlotly is a technical computing company headquartered in Montreal, Quebec, that develops online data analytics and visualization tools. Plotly provides online graphing, analytics, and statistics tools for individuals and collaboration, as well as scientific graphing libraries for Python, R, MATLAB, Perl, Julia, Arduino, JavaScript and REST. #\n\nPlotly is a useful tool for creating interactive plots, see FigureÂ 4.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=x1, y=y1, mode='lines', name='xÂ²'))\nfig.add_trace(go.Scatter(x=x2, y=y2, mode='lines', name='sin(x)'))\nfig.show()\n\n\n\n                                                \n\n\nFigureÂ 4: A plot using plotly"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html",
    "href": "posts/solar_eruptions_magnetic_fields/index.html",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "",
    "text": "This post is based on the presentation during the lab meeting on 2023-11-28."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#heliophysics-2024-decadal-whitepapers",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#heliophysics-2024-decadal-whitepapers",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Heliophysics 2024 Decadal Whitepapers",
    "text": "Heliophysics 2024 Decadal Whitepapers"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#d-storage-release-caspi2023",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#d-storage-release-caspi2023",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "3D Storage & Release (Caspi et al. 2023)",
    "text": "3D Storage & Release (Caspi et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#solar-eruptions---storage-release-caspi2023",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#solar-eruptions---storage-release-caspi2023",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Solar eruptions - Storage & Release (Caspi et al. 2023)",
    "text": "Solar eruptions - Storage & Release (Caspi et al. 2023)\n\nCoronal mass ejections (CMEs)\nSolar flares\n\neruptive flares : flares with a CME\nconfined flares : flares not associated with a CME"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#the-big-open-questions-caspi2023",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#the-big-open-questions-caspi2023",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "The Big Open Questions (Caspi et al. 2023)",
    "text": "The Big Open Questions (Caspi et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#d-knowledge-caspi2023",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#d-knowledge-caspi2023",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "3D Knowledge (Caspi et al. 2023)",
    "text": "3D Knowledge (Caspi et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#solar-magnetic-field-models",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#solar-magnetic-field-models",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Solar magnetic field models",
    "text": "Solar magnetic field models\n\nStatic model (time-independent); \\mathbf{v} = \\mathbf{0}\n\nForce-free field model : initial condition of MHD simulations\n\npros: related with magnetic field observations directly\ncons: cannot explain the forced structures in the photosphere and lower chromosphere and their dynamical evolution\n\nMagnetohydrostatic (MHS) model\n\npros: partly overcome the disadvantage of the force-free field model\ncons: still static model\n\n\nDynamic model (time-dependent); \\mathbf{v} \\neq \\mathbf{0}\n\nMagnetohydrodynamic (MHD) model\n\npros: may provide the best way to study the observed complex magnetic structures and dynamical evolution\ncons: the most difficult, complicated and expensive model\n\n\n\n\nGuo et al. (2017b)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#plasma-beta-in-the-solar-atmosphere",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#plasma-beta-in-the-solar-atmosphere",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Plasma \\beta in the solar atmosphere",
    "text": "Plasma \\beta in the solar atmosphere\n\n\\beta = \\dfrac{p}{\\frac{B^2}{8\\pi}} is the ratio of gas pressure to magnetic pressure (cgs-Gaussian unit)\n\n\n\n\n\n\n\n\n\nGary (2001), Wiegelmann et al. (2017)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#suggested-physical-mechanisms",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#suggested-physical-mechanisms",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Suggested physical mechanisms",
    "text": "Suggested physical mechanisms\n\n\n\n\n\n\n\n\nGreen et al. (2018)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-fields",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-fields",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic fields",
    "text": "Magnetic fields\n\nFundamental quantities\n\nEnergy\nHelicity\nSurface-calculated quantities\n\nInstabilities\n\nKink instability\nTorus instability\nDouble arc instability\n\nMagnetic topology analysis (magnetic reconnection)\n\nSeparatrices\nQuasi-Separatrix Layers (QSLs)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-energy",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-energy",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic energy",
    "text": "Magnetic energy\n\nTotal magnetic energy E in a volume V (cgs-Gaussian units)\n\n\nE = \\frac{1}{8\\pi} \\int_{V} B^2 \\rm{d}V\n\n\n\n\n\n\n\n\n\nDeRosa et al. (2009)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#helmholtz-decomposition",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#helmholtz-decomposition",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Helmholtz decomposition",
    "text": "Helmholtz decomposition\n\nMagnetic field\n\n\n\\mathbf{B} = \\mathbf{B}_\\text{p} + \\mathbf{B}_\\text{J}\n\n\nPotential (current-free) field\n\n\n\\mathbf{B}_\\text{p} = \\nabla \\phi\n\n\nNon-potential (current-carrying) component of the magnetic field\n\n\n\\mathbf{B}_\\text{J} = \\mathbf{B} - \\mathbf{B}_\\text{p}\n\n\nCurrent density in MHD (cgs-Gaussian units)\n\n\n\\mathbf{J} = \\frac{1}{4\\pi} \\nabla \\times \\mathbf{B}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#potential-field",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#potential-field",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Potential field",
    "text": "Potential field\n\nUsually, the potential field \\mathbf{B}_p is computed from the same distribution of normal field of \\mathbf{B} on the boundary of V.\n\n\n(\\mathbf{\\hat{n}} \\cdot \\mathbf{B}_\\text{p})|_{\\partial V} = (\\mathbf{\\hat{n}} \\cdot \\mathbf{B})|_{\\partial V}\n\n\nThen, the potential field \\mathbf{B}_\\text{p} = \\nabla \\phi is calculated by solving the Laplace equation with the Neumann boundary condition.\n\n\n\\begin{cases}\n\\nabla^2 \\phi &= 0\\\\\n(\\mathbf{\\hat{n}} \\cdot \\nabla \\phi)|_{\\partial V} & = (\\mathbf{\\hat{n}} \\cdot \\mathbf{B})|_{\\partial V}\n\\end{cases}\n\n\nWith such a prescription, the potential field is chosen as a reference is uniquely defined and represents the minimal energy state for a given distribution of the normal component of the field on the boundaries.\n\n\nValori et al. (2013)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-free-energy",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-free-energy",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic free energy",
    "text": "Magnetic free energy\n\nWithout changing the field significantly at the boundaries of the considered volume, the energy that can be converted into kinetic and thermal energies is given by the free enery, i.e., by the difference between the total magnetic energy and the energy of the corresponding current-free (potential) field.\n\n\nE_\\text{free} = E - E_\\text{p}\n\n\nTo use this formula, the magnetic field must be divergence-free (solenoidal).\n\n\n\n\n\n\n\n\n\nValori et al. (2013)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Accuracy of magnetic energy computations (Valori et al. 2013)",
    "text": "Accuracy of magnetic energy computations (Valori et al. 2013)\n\nDecomposition of the magnetic energy (Thomsonâ€™s theorem extended by Valori et al. 2013)\n\n\nE = E_\\text{p, s} + E_\\text{J, s} + E_\\text{p, ns} + E_\\text{J, ns} + E_\\text{mix}\n\nE_\\text{p, s} : energy of solenoidal component of the potential field (positive)\nE_\\text{J, s} : energy of solenoidal component of the current-carrying field (positive)\nE_\\text{p, ns} : energy of nonsolenoidal component of the potential field (positive)\nE_\\text{J, ns} : energy of nonsolenoidal component of the current-carrying field (positive)\nE_\\text{mix} : energy corresponding to all cross terms (can be negative)\n\n\\begin{align*}\nE_{\\text{mix}} & = \\frac{1}{4\\pi} \\left( \\int_{V} \\mathbf{B}_\\text{p,s} \\cdot \\nabla \\zeta \\, dV + \\int_{V} \\mathbf{B}_\\text{J,s} \\cdot \\nabla \\psi \\, dV \\right. \\\\\n& \\left. + \\int_{V} \\mathbf{B}_\\text{p,s} \\cdot \\nabla \\psi \\, dV + \\int_{V} \\mathbf{B}_\\text{J,s} \\cdot \\nabla \\zeta \\, dV \\right. \\\\\n& \\left. + \\int_{V} \\nabla \\zeta \\cdot \\nabla \\psi \\, dV + \\int_{V} \\mathbf{B}_\\text{p,s} \\cdot \\mathbf{B}_\\text{J,s} \\, dV \\right)\n\\end{align*}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Accuracy of magnetic energy computations (Valori et al. 2013)",
    "text": "Accuracy of magnetic energy computations (Valori et al. 2013)\n\nFor a perfectly solenoidal field,\n\n\nE = E_\\text{p, s} + E_\\text{J, s}\n\n\nE_\\text{J, s} = E - E_\\text{p, s}\n\n\nThe free energy of the field is the energy of the solenoidal component of its current-carrying part\n\n\nE_\\text{free} = E_\\text{J, s}\n\n\nFor a nonsolenoidal field, \\tilde{E}_\\text{free} even can be negative.\n\n\n\\begin{align*}\n\\tilde{E}_{\\text{free}} & = E - E_\\text{p} \\\\\n& = E - (E_\\text{p, s} + E_\\text{p, ns}) \\\\\n& = E_\\text{J, s} + E_\\text{J, ns} + E_\\text{mix} \\\\\n& = E_\\text{free} + E_\\text{J, ns} + E_\\text{mix} \\\\\n\\end{align*}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#accuracy-of-magnetic-energy-computations-valori2013-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Accuracy of magnetic energy computations (Valori et al. 2013)",
    "text": "Accuracy of magnetic energy computations (Valori et al. 2013)\n\nE_\\text{div} : upper limit of the energy associated with all non-solenoidal components\n\n\nE_\\text{div} = E_\\text{p, ns} + E_\\text{J, ns} + |E_\\text{mix}|\n\n\nAt least (Valori et al. 2016),\n\n\nE_\\text{div} / E &lt; 0.1\n\n\nMore strictly (Thalmann et al. 2019),\n\n\nE_\\text{div} / E \\lesssim 0.05\n\n\nSimpler test (Mastrano et al. 2018) \\nabla \\cdot \\mathbf{B} = 0 \\Rightarrow W_\\text{f1} = W_\\text{f2} (inverse is not true)\n\n\nW_\\text{f1} = \\frac{1}{8\\pi} \\int_V (\\mathbf{B} - \\mathbf{B}_\\text{p})^2 \\rm{d}V\n\n\nW_\\text{f2} = \\frac{1}{8\\pi} \\int_V \\mathbf{B}^2 \\rm{d}V - \\frac{1}{8\\pi} \\int_V \\mathbf{B}_\\text{p}^2 \\rm{d}V"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#how-to-calculate-potential-field-mathbfb_textp-nabla-phi",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#how-to-calculate-potential-field-mathbfb_textp-nabla-phi",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "How to calculate potential field \\mathbf{B}_\\text{p} = \\nabla \\phi",
    "text": "How to calculate potential field \\mathbf{B}_\\text{p} = \\nabla \\phi\n\n\\mathbf{\\hat{n}} \\cdot \\mathbf{B} is given on the all boundaries\n\nSolve Laplace equation directly\n\n\n\n\\begin{cases}\n\\nabla^2 \\phi &= 0\\\\\n(\\mathbf{\\hat{n}} \\cdot \\nabla \\phi)|_{\\partial V} & = (\\mathbf{\\hat{n}} \\cdot \\mathbf{B})|_{\\partial V}\n\\end{cases}\n\n\n\\mathbf{\\hat{n}} \\cdot \\mathbf{B} is given on the only one boundary (usually bottom one)\n\nUse alternative ways such as Greenâ€™s function methods (Sakurai 1982)\n\n\n\n\\phi(\\mathbf{r}) = \\int_{S} \\frac{B_n(\\mathbf{r}')}{2\\pi|\\mathbf{r}-\\mathbf{r'}|} \\rm{d}S\n\n\nIf the reference potential field does not have the same normal components on all boundaries, then the potential field does not satisfy Thomsonâ€™s theorem, and does not represent the state with the minimum energy for a given distribution of magnetic field on the boundaries (Mastrano et al. 2018)."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-helicity",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-helicity",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic helicity",
    "text": "Magnetic helicity\n\nClassical magnetic helicity\n\n\n\\mathscr{H} = \\int_V \\mathbf{A} \\cdot \\mathbf{B} \\rm{d}V\n\n\nRelative magnetic helicity (Berger & Field (1984) and Finn & Antonsen (1985))\n\n\nH_V = \\int_V (\\mathbf{A} + \\mathbf{A}_\\text{p}) \\cdot (\\mathbf{B} - \\mathbf{B}_\\text{p}) \\rm{d}V\n\n\n\\mathbf{A} : vector potential of \\mathbf{B} = \\nabla \\times \\mathbf{A}\n\\mathbf{A}_\\text{p} : vector potential of \\mathbf{B}_\\text{p} = \\nabla \\times \\mathbf{A}_\\text{p}\nIn order for H_V to be gauge invariant,\n\n\\mathbf{B} and \\mathbf{B}_\\text{p} are solenoidal (divergence-free)\nreference field \\mathbf{B}_\\text{p} satisfies (\\mathbf{\\hat{n}} \\cdot \\mathbf{B}_\\text{p})|_{\\partial V} = (\\mathbf{\\hat{n}} \\cdot \\mathbf{B})|_{\\partial V}\n\nThe usual choice of the reference field is the electirc current-free (potential) field.\n\n\nValori et al. (2016)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#decomposition-of-the-magnetic-helicity-berger2003",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#decomposition-of-the-magnetic-helicity-berger2003",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Decomposition of the magnetic helicity (Berger 2003)",
    "text": "Decomposition of the magnetic helicity (Berger 2003)\n\nRelative magnetic helicity\n\n\nH_V = \\int_V (\\mathbf{A} + \\mathbf{A}_\\text{p}) \\cdot (\\mathbf{B} - \\mathbf{B}_\\text{p}) \\rm{d}V\n\n\nDecomposition of H_V\n\n\nH_V = H_\\text{J} + H_\\text{PJ}\n\n\nH_\\text{J}: classical magnetic helicity of \\mathbf{B}_\\text{J} = \\mathbf{B} - \\mathbf{B}_\\text{p}\n\n\nH_\\text{J} = \\int_V (\\mathbf{A} - \\mathbf{A}_\\text{p}) \\cdot (\\mathbf{B} - \\mathbf{B}_\\text{p}) \\rm{d}V\n\n\nH_\\text{PJ}: a sorf of multual helicity between \\mathbf{B}_\\text{p} and \\mathbf{B}_\\text{J}\n\n\nH_\\text{PJ} = 2\\int_V \\mathbf{A}_\\text{p} \\cdot (\\mathbf{B} - \\mathbf{B}_\\text{p}) \\rm{d}V"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)",
    "text": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)\n\nQuantitative threshold for the divergence-freeness\n\n\nE_\\text{div} / E \\lesssim 0.05\n\nHere, E_\\text{div} = E_\\text{p, ns} + E_\\text{J, ns} + |E_\\text{mix}| is the nonpotential contribution and E is the total magnetic energy."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)",
    "text": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)\n\nNOAA 11158 between February 12 00:00 UT and February 16 00:00 UT\nFree parameters\n\nPreprocessing (Wiegelmann et al. 2006)\n\n(\\mu_1, \\mu_2, \\mu_3, \\mu_4)\n\nNLFFF optimization method of Wiegelmann & Inhester (2010)\n\n(w_f, w_d, w_\\text{hor}, \\nu)\n\n\n(\\mu_1, \\mu_2, w_f, \\nu) = (1, 1, 1, 10^{-3})\n\nSERIES I\n\n(\\mu_3, \\mu_4, w_d, w_\\text{hor}) = (10^{-3}, 10^{-3}, 1, 1)\n\nSERIES II\n\n(\\mu_3, \\mu_4, w_d, w_\\text{hor}) = (10^{-3}, 10^{-3}, 2, \\propto B_\\text{hor})"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#reliability-of-magnetic-energy-and-helicity-computations-thalmann2019-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)",
    "text": "Reliability of magnetic energy and helicity computations (Thalmann et al. 2019)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoulomb gauge\n\n\n\\nabla \\cdot \\mathbf{A} = \\nabla \\cdot \\mathbf{A}_\\text{p} = 0\n\n\nDeVore gauge (DeVore 2000)\n\n\nA_z = A_\\text{p, z} = 0"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#how-to-calculate-magnetic-helicity",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#how-to-calculate-magnetic-helicity",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "How to calculate magnetic helicity",
    "text": "How to calculate magnetic helicity\n\n\n\n\n\n\n\n\nValori et al. (2016)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#connectivity-based-methods",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#connectivity-based-methods",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Connectivity-based methods",
    "text": "Connectivity-based methods\n\nUse the magnetic connectivity matrix to calculate E_\\text{c} and H_m (Georgoulis et al. 2012)\n\n\n\n\\begin{align*}\nE_\\text{c} & = E_{\\text{c}_\\text{self}} + E_{\\text{c}_\\text{mul}} \\\\\n& = Ad^2 \\sum_{l=1}^{N} \\alpha_l^2 \\Phi_l^{2\\delta} + \\frac{1}{8\\pi}\\sum_{l=1}^{N}\\sum_{m=1, l\\neq m}^{N} \\alpha_l \\mathcal{L}_{lm}^{\\text{arch}}\\Phi_{l}\\Phi_{m}\n\\end{align*}\n\n\n\n\n\\begin{align*}\nH_\\text{m} & = H_{\\text{m}_\\text{self}} + H_{\\text{m}_\\text{mul}} \\\\\n& = 8\\pi d^2 A \\sum_{l=1}^{N} \\alpha_l \\Phi_l^{2\\delta} + \\sum_{l=1}^{N}\\sum_{m=1, l\\neq m}^{N} \\mathcal{L}_{lm}^{\\text{arch}}\\Phi_{l}\\Phi_{m}\n\\end{align*}\n\n\n\n\n\n\n\n\n\n\nTziotziou et al. (2012)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#free-energy-relative-helicity-diagram-of-solar-ars-tziotziou2012",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#free-energy-relative-helicity-diagram-of-solar-ars-tziotziou2012",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Free energy â€“ Relative helicity diagram of solar ARs (Tziotziou et al. 2012)",
    "text": "Free energy â€“ Relative helicity diagram of solar ARs (Tziotziou et al. 2012)\n\nBlue diamonds : Non-flaring ARs\nRed squares/asterisks : M-/X-class flaring ARs\n\n\n\n\n\n\n\n\n\n\nThreshold for relative magnetic helicity H_\\text{V}  (denoted as |H_m| in this diagram)\n\n\n|H_\\text{V}| \\sim 2 \\times 10^{42} \\text{ Mx}^2\n\n\nThreshold for free magnetic energy E_\\text{free}  (denoted as E_\\text{c} in this diagram)\n\n\nE_\\text{free} \\sim 4 \\times 10^{31} \\text{ erg}\n\n\nScaling relation (Tziotziou et al. 2014)\n\n\n|H_V| \\propto E_\\text{free}^{0.84 \\pm 0.05}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)",
    "text": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)\n\n\n\n\n\n\n\n\n\n3D visco-resistive MHD simulations\n\nND : no arcade\nWD : weak arcade\nMD : medium arcade\nSD : strong arcade\n\n\n\n\n\nfrom t = 0 to t=200\n\nt &lt; 30 : emerging flux rope rises in the convection zone\nt \\in [30, 120] : pre-eruptive phase\nt \\in [120, 150] : eruptive phase\nt  &gt; 150 : post-eruptive phase"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)",
    "text": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)\n\nH_V = H_\\text{J} + H_\\text{PJ}\n\n\nE = E_\\text{free} + E_\\text{p}\n\nHere, E = E_\\text{mag} and E_\\text{inj} = E_\\text{mag} - E_\\text{mag}(t=0)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#relative-magnetic-helicity-as-a-diagnostic-of-solar-eruptivity-pariat2017-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)",
    "text": "Relative magnetic helicity as a diagnostic of solar eruptivity (Pariat et al. 2017)\n\nH_V = H_\\text{J} + H_\\text{PJ}\n\n\nE = E_\\text{free} + E_\\text{p}\n\nHere, E = E_\\text{mag} and E_\\text{inj} = E_\\text{mag} - E_\\text{mag}(t=0)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#changes-of-magnetic-energy-and-helicity-in-solar-ars-from-major-flares-liu2023",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#changes-of-magnetic-energy-and-helicity-in-solar-ars-from-major-flares-liu2023",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Changes of Magnetic Energy and Helicity in Solar ARs from Major Flares (Liu et al. 2023)",
    "text": "Changes of Magnetic Energy and Helicity in Solar ARs from Major Flares (Liu et al. 2023)\n\nHere, H = H_V"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---sharp-parameters",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---sharp-parameters",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - SHARP parameters",
    "text": "Surface-calculated quantities - SHARP parameters\n\nSOLAR FLARE PREDICTION USING SDO/HMI VECTOR MAGNETIC FIELD DATA WITH A MACHINE-LEARNING ALGORITHM (Bobra et al. 2015)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}",
    "text": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}\n\n\\mathbf{v} : DAVE4VM (differential affine velocity estimator for vector magnetograms) (Schuck 2008)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}",
    "text": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}\n\n\\mathbf{E} : PDFI_SS (Fisher et al. 2020)\n\nPDFI : poloidalâ€“toroidal decomposition (PTD) plus Doppler plus Fourier local correlation tracking (FLCT) plus ideal\nSS : spherical staggered"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---mathbfv-or-mathbfe-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}",
    "text": "Surface-calculated quantities - \\mathbf{v} or \\mathbf{E}\n\nDAVE4VM vs PDFI_SS (Wang et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - Flux of quantities",
    "text": "Surface-calculated quantities - Flux of quantities\n\nMagnetic energy (Poynting) flux (Schuck 2006; Guo et al. 2017b; Liu et al. 2023)\n\n\n\\left.\\frac{dE}{dt}\\right|_{S} = \\frac{1}{4\\pi}\\int_{S}B_t^2V_{\\perp n}\\rm{d}S - \\frac{1}{4\\pi}\\int_{S}(\\mathbf{B}_t \\cdot \\mathbf{V}_{\\perp t})B_n \\rm{d}S\n\n\nFlux of magnetic helicity (Berger 1984; Chae 2001; Liu et al. 2023)\n\n\n\\left.\\frac{dH}{dt}\\right|_{S} = 2\\int_{S}(\\mathbf{A}_p \\cdot \\mathbf{B}_t)\\rm{d}S - 2\\int_{S}(\\mathbf{A}_p \\cdot \\mathbf{V}_{\\perp t})B_n \\rm{d}S"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - Flux of quantities",
    "text": "Surface-calculated quantities - Flux of quantities\n\nOn short timescales (~1 hr) after eruptive flares, there are decreases in both the coronal magnetic energy, E, and helicity H; and their photospheric fluxes, dE/dt and dH/dt. (Liu et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - Flux of quantities",
    "text": "Surface-calculated quantities - Flux of quantities\n\nFluxes of topological quantities (Alielden et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-3",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#surface-calculated-quantities---flux-of-quantities-3",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Surface-calculated quantities - Flux of quantities",
    "text": "Surface-calculated quantities - Flux of quantities\n\nFluxes of topological quantities (Alielden et al. 2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-flux-rope-mfr",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-flux-rope-mfr",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic flux rope (MFR)",
    "text": "Magnetic flux rope (MFR)\n\nMagnetic flux rope (MFR) can be defined as a coherent group of magnetic field lines winding an axis with more than one turn (Liu et al. 2016; Duan et al. 2019).\nMagnetic flux rope of the Titovâ€“DÃ©moulin semi-analytical NLFFF model (Titov et al. 1999; Guo et al. 2017a)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#kink-instability-ki",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#kink-instability-ki",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Kink instability (KI)",
    "text": "Kink instability (KI)\n\nMagnetic twist number T_\\text{w} for a given (closed) field line (Berger et al. 2006; Jing et al. 2018; Duan et al. 2019)\n\n\nT_\\text{w} = \\int_L \\frac{(\\nabla \\times \\mathbf{B}) \\cdot \\mathbf{B}}{4 \\pi B^2} \\rm{d}l\n\n\nIf the magnetic field is force-free, i.e., \\nabla \\times \\mathbf{B} = \\alpha \\mathbf{B},\n\n\nT_\\text{w} = \\frac{1}{4\\pi} \\int_L \\alpha \\rm{d}l\n\n\nKI parameter - There is a critical value to determine whether MFR is eruptive or not.\n\n\n|T_\\text{w}| &gt; |T_\\text{w}|_\\text{crit}\n\n\nT_\\text{w} is not identical to the classical winding number of field lines about a common axis, the parameter often used in the analysis of the helical KI. Nevertheless, accroding to Liu et al.â€™s (2016) analysis, the magnetic field line that possesses the extremum value (maximum or minimum) of |T_\\text{w}| in a MFR can be reliably regarded as the rope axis, and T_\\text{w} computed in the vicinity of the axis approaches the winding number. (Duan et al. 2019)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#identification-of-mfrs-duan2019",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#identification-of-mfrs-duan2019",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Identification of MFRs (Duan et al. 2019)",
    "text": "Identification of MFRs (Duan et al. 2019)\n\nMFRs generally exist prior to major solar flares. With a rigorous definition, over 90% of the studied events have well-defined MFRs in the flare site, i.e., a coherent group of magnetic field lines with twists above one turn and the field line possessing the peak value of twist being the rope axis. The other 10% of events also have MFR-like structures as their magnetic twist numbers are very close to one. Most of the MFRs have corresponding filaments or filament channels as seen in SDO/AIA 304 Ã… observations. (Duan et al. 2019)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#identification-of-mfrs-duan2019-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#identification-of-mfrs-duan2019-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Identification of MFRs (Duan et al. 2019)",
    "text": "Identification of MFRs (Duan et al. 2019)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#torus-instability-ti",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#torus-instability-ti",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Torus instability (TI)",
    "text": "Torus instability (TI)\n\nDecay index n (Kliem et al. 2006; Jing et al. 2018; Duan et al. 2019)\n\n\nn = - \\frac{\\partial \\log (B_\\text{ext})}{\\partial \\log (h)}\n\n\nB_\\text{ext} : external strapping field stabilizing the MFR (usually potential field)\nh : vertical height locally, radial distance globally, or oblique height\nTI parameter - There is a critical value to determine whether MFR is eruptive or not.\n\n\nn &gt; n_\\text{crit}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#torus-instability-ti-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#torus-instability-ti-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Torus instability (TI)",
    "text": "Torus instability (TI)\n\nIllustration of calculating the decay index n at the apex of the MFR axis (Duan et al. 2019)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "TI Parameter - KI Parameter diagram",
    "text": "TI Parameter - KI Parameter diagram\n\nLaboratory experiment designed to study the Sun-like line-tied MFRs (Myers et al. 2015)\n\n\n\n\nVideo"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "TI Parameter - KI Parameter diagram",
    "text": "TI Parameter - KI Parameter diagram\n\nLaboratory experiment designed to study the Sun-like line-tied MFRs (Myers et al. 2015)\n\n\n\n\n\n\n\n\n\n\nPotential field decay index n\n\n\nn(z) = - \\frac{z}{|\\mathbf{B}_\\text{pot}|}\\frac{\\partial |\\mathbf{B}_\\text{pot}|}{\\partial z}\n\n\nEdge safety factor q_a : inverse of the edge magnetic twist \\iota_a\n\n\nq_a = \\frac{2\\pi}{\\iota_a} = \\left.\\frac{\\rm{d}\\Phi_\\text{T}}{\\rm{d}\\psi_\\text{P}}\\right|_{r=a} \\approx \\frac{2\\pi a}{L}\\frac{B_\\text{Ta}}{B_\\text{Pa}}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "TI Parameter - KI Parameter diagram",
    "text": "TI Parameter - KI Parameter diagram\n\nStatistical Analysis of Torus and Kink Instabilities in Solar Eruptions (Jing et al. 2018)\n\nBlack : confined flare\nColor : ejective flare\n\n\n\n\n\n\n\n\n\n\n\n\nT_\\text{w} appears to play little role in discriminating between confined and ejective events\n\n\nThe events with n \\gtrsim 0.8 are all ejective, and all confined events have n \\lesssim 0.8. However, n \\gtrsim 0.8 is not a necessary condition for eruption because some events with n \\lesssim 0.8 also erupted."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-3",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#ti-parameter---ki-parameter-diagram-3",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "TI Parameter - KI Parameter diagram",
    "text": "TI Parameter - KI Parameter diagram\n\nA Study of Pre-flare Solar Coronal Magnetic Fields: Magnetic Flux Ropes (Duan et al. 2019)\n\nGreen : non-MFR event (|T_\\text{w}|_\\text{max} &lt; 1)\n\n\n\n\n\n\n\n\n\n\nIt clearly shows lower limits for TI and KI thresholds, which are n_\\text{crit}=1.3 and |T_\\text{w}|_\\text{crit}=2, respectively, as all the events above n_\\text{crit} and nearly 90% of the events above |T_\\text{w}|_\\text{crit}| erupted. Furthermore, by such criterion, over 70% of the events can be discriminated between eruptive and confined flares, and KI seems to play a nearly equally important role as TI in discriminating between the two types of flares. More than half of the events with both parameters are below the lower limits, and 29% are eruptive. These events might be triggered by magnetic reconnection rather than MHD instabilities."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#tether-cutting-reconnection",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#tether-cutting-reconnection",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Tether-cutting reconnection",
    "text": "Tether-cutting reconnection\n\nTether-cutting reconnection scenario proposed by Moore et al. (2001) explains the eruption of the sigmoidal field often observed before solar eruptions. (Ishiguro et al. 2017)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#tether-cutting-reconnection-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#tether-cutting-reconnection-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Tether-cutting reconnection",
    "text": "Tether-cutting reconnection\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChen et al. (2014)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#double-arc-instability-ishiguro2017",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#double-arc-instability-ishiguro2017",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Double arc instability (Ishiguro et al. 2017)",
    "text": "Double arc instability (Ishiguro et al. 2017)\n\nThe tether-cutting scenario proposes that the internal reconnection proceeds in the core of the sheared magnetic field in the pre-eruptive phase, and it may form a double arc flux rope (sigmoidal field) that carries an electric current (Ishiguro et al. 2017).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIshiguro et al. (2017), Kusano et al. (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#double-arc-instability",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#double-arc-instability",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Double arc instability",
    "text": "Double arc instability\n\nDAI parameter \\kappa (Ishiguro et al. 2017; Muhamad et al. 2018; Kusano et al. 2020)\n\n\n\\kappa = T_\\text{w} \\frac{\\Phi_\\text{rec}}{\\Phi_\\text{over}}\n\n\nT_\\text{w} : magnetic twist of the DA\n\\Phi_\\text{rec} : magnetic flux within DA\n\\Phi_\\text{over} : magnetic flux overlying DA\n\n\nThere is a threshold.\n\n\n\\kappa &gt; \\kappa_0"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#a-physics-based-method-that-can-predict-imminent-large-solar-flares-kusano2020",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#a-physics-based-method-that-can-predict-imminent-large-solar-flares-kusano2020",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "A physics-based method that can predict imminent large solar flares (Kusano et al. 2020)",
    "text": "A physics-based method that can predict imminent large solar flares (Kusano et al. 2020)\n\n\\kappa is evaluated by\n\n\n\\kappa = \\left|\\frac{\\int_\\text{rec} T_\\text{w}\\rm{d}\\Phi}{\\Phi_{\\text{over}}}\\right|\n\nwhere the integral is taken over the magnetic flux subject to the trigger-reconnection which forms the DA.\n\nIf the DA is formed by the magnetic reconnection of magnetic fluxes rooted near the PIL, then \\kappa can be calculated by the area integral over the reconnection-region S_\\text{rec} on the photosphere: \n\\kappa = \\left|\\frac{\\int_{S_\\text{rec}} \\tau\\rm{d}S}{\\Phi_{\\text{over}}}\\right|\n\n\nwhere\n\n\\tau = T_\\text{w}|B_z|\n\nis defined as the magnetic twist flux density with the vertical magnetic field B_z."
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#kappa-scheme-kusano2020",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#kappa-scheme-kusano2020",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "\\kappa-scheme (Kusano et al. 2020)",
    "text": "\\kappa-scheme (Kusano et al. 2020)\n\ncalculate T_\\text{w}\ncalculate \\tau = T_\\text{w} |B_z|\ncalculate B_{\\text{np}} = |\\mathbf{B}_{\\text{h}} - \\mathbf{B}_\\text{p}|\nidentify multiple High Free-Energy Regions (HiFERs) using the condition B_\\text{np} &gt; B_0 = 1000 \\text{ G}\nsort the HiFERs by the size (largest size is the fisrt HiFER). S_{H, i} is the area of the i-th HiFER\nselect one point in PIL within HiFER\nconsider hypothetical reconnection region as a circle with r\ncalculate unsigned magnetic flux of each pole\nfor area with small unsigned magnetic flux, calculate \\int_{S_\\text{rec}}  \\tau \\rm{d}S\nidentify magnetic field lines rooted on the hypothetical reconnection region (predicted trigger-reconnection region)\nidentify strongest sheared field line among them, which is defined by field line that reaches farthest from the reconnection region\ncalculate \\Phi_{\\text{over}} for all flux crossing over the strongest sheared field line\ncalculate \\kappa = \\left| \\frac{\\int_{S_\\text{rec}}  \\tau \\rm{d}S}{\\Phi_{\\text{over}}} \\right|\nsince \\kappa depends on r (radius of reconnection region), we can find the minimum r while satisfying \\kappa &gt; \\kappa_0 = 0.1\nThe minium r is the critical length scale r_c\nfor each point with r_c, calculate the area of the footprint of the overlying field within the HiFER S_r\ncalculate the first level of releasable energy E_r = \\displaystyle \\frac{S_r ^{1/2}}{8\\pi}  \\int_{S_r} B^2_{\\text{np}} \\rm{d} S, which is the mininum energy of the flare driven by a DAI\ncalculate the second level of releasable energy for i-th HiFER E_{H, i} = \\displaystyle \\frac{S_{H, i} ^{1/2}}{8\\pi}  \\int_{S_{H, i}} B^2_{\\text{np}} \\rm{d} S\ncalculate the total free energy of an AR E_{\\text{AR}} = \\displaystyle \\sum_i E_{H, i}"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#kappa-scheme-kusano2020-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#kappa-scheme-kusano2020-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "\\kappa-scheme (Kusano et al. 2020)",
    "text": "\\kappa-scheme (Kusano et al. 2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#a-physics-based-method-that-can-predict-imminent-large-solar-flares-kusano2020-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#a-physics-based-method-that-can-predict-imminent-large-solar-flares-kusano2020-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "A physics-based method that can predict imminent large solar flares (Kusano et al. 2020)",
    "text": "A physics-based method that can predict imminent large solar flares (Kusano et al. 2020)\n\nIf any point on a PIL satisfies the conditions r_c &lt; 1 \\text{ Mm} and E_r &gt; 4 \\times 10^{31} \\text{ erg}, an X-class flare usually occurs.\n\n\n\n\n\n\n\n\n\n\n\nVideo"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-topology-analysis",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#magnetic-topology-analysis",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Magnetic topology analysis",
    "text": "Magnetic topology analysis\n\nThe random or user-defined tracing of magnetic field lines does not guarantee that key features of the magnetic field will be identified.\n\n\n\n\n\n\n\n\n\nMagnetic reconnection, responsible for changing both the topology and geometry of a magnetic field, is a typical example of a phenomenon whose occurrence is strongly associated with the geometry of the magnetic field.\nIn particular, magnetic reconnection is linked to the formation of intense field-aligned current sheets, that are induced by the existence of gradients of the magnetic field, following AmpÃ¨reâ€™s equation (\\mu_0 \\mathbf{J} = \\nabla \\times \\mathbf{B}).\nThese currents develop preferentially in specific locations of the magnetic field, that is in regions where the connectivity of the magnetic field is discontinuous.\nThe aim of the magnetic topology is to determine the locations of such regions.\n\n\nPariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#separatrices",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#separatrices",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Separatrices",
    "text": "Separatrices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet us consider a field line which links the footpoint \\mathbf{r}_1 of coordinate (x_1, y_1) of the plane P_1 to the footpoint \\mathbf{r}_2, of coordinate (X_2, Y_2) of the plane P_2.\nTwo mappings exist that associate a footpoint on one plane to the other: the mapping \\Pi_{12} from P_1 to P_2: \\mathbf{r}_1(x_1, y_1) \\mapsto \\mathbf{r}_2(X_2, Y_2); and the inverse mapping \\Pi_{21} from P_2 to P_1: \\mathbf{r}_2(X_2, Y_2) \\mapsto \\mathbf{r}_1(x_1, y_1).\nA separatrix is present when the mapping contains a discontinuity, i.e.Â where the function \\Pi_{12} (or \\Pi_{21}) is discontinuous.\n\n\nLongcope et al. (2008), Pariat et al. (2012), Pariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Separatrices - Regions of magnetic field discontinuity",
    "text": "Separatrices - Regions of magnetic field discontinuity\n\nNull points \\mathbf{x}_\\text{NP}\n\n\n\\mathbf{B}(\\mathbf{x}_\\text{NP}) = \\mathbf{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLongcope (2005), Jiang et al. (2017), Mason et al. (2019), Pariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Separatrices - Regions of magnetic field discontinuity",
    "text": "Separatrices - Regions of magnetic field discontinuity\n\nBald patches (BPs)\n\nRegions where some field lines touch the boundary tangentially\n\n\n\n\\mathbf{x}_\\text{BP} \\in \\partial V \\quad \\text{with } \\partial V \\text{ a line-tying boundary}\n\n\nB_n (\\mathbf{x}_\\text{BP}) = 0\n\n\n(\\mathbf{B} \\cdot \\nabla B_n)(\\mathbf{x}_\\text{BP}) &gt; 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLongcope (2005), Jiang et al. (2017), Mason et al. (2019), Pariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity-2",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#separatrices---regions-of-magnetic-field-discontinuity-2",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Separatrices - Regions of magnetic field discontinuity",
    "text": "Separatrices - Regions of magnetic field discontinuity\n\nSeparators\n\n1D topological structures and are found at the intersection of two separatrix surfaces.\nSeparators can be found to connect two 3D magnetic null points.\n\n\n\n\n\n\n\n\n\n\nLongcope (2005), Jiang et al. (2017), Mason et al. (2019), Pariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#quasi-separatrix-layers-qsls",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#quasi-separatrix-layers-qsls",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Quasi-Separatrix Layers (QSLs)",
    "text": "Quasi-Separatrix Layers (QSLs)\n\nNumerous solar flares, however, have not been associated with separatrices, i.e.Â with magnetic-field connectivity discontinuities. This has led to the generalization of the concept of separatrices to Quasi-Separatrix Layers (QSLs). QSLs were introduced in DÃ©moulin et al. (1996) and are defined as regions where the mapping of the field lines, while still continuous (unlike seperatrices), possesses very strong gradients.\nQSLs are 3D magnetic volumes of high squashing factor Q, in which the magnetic connectivity varies strongly.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#squashing-factor-q",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#squashing-factor-q",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "Squashing factor Q",
    "text": "Squashing factor Q\n\n\n\n\n\n\n\n\nMappings\n\n\\Pi_{12} : \\mathbf{r}_1(x_1, y_1) \\mapsto \\mathbf{r}_2(X_2, Y_2)\n\\Pi_{21} : \\mathbf{r}_2(X_2, Y_2) \\mapsto \\mathbf{r}_1(x_1, y_1).\n\nJacobian matrices associated with the mappings\n\n\nD_{12} = \\frac{d\\mathbf{r}_2}{d\\mathbf{r}_1} = \\begin{pmatrix}\n\\displaystyle  \\frac{\\partial X_2}{\\partial x_1} & \\displaystyle \\frac{\\partial X_2}{\\partial y_1} \\\\\n\\\\\n\\displaystyle  \\frac{\\partial Y_2}{\\partial x_1} & \\displaystyle \\frac{\\partial Y_2}{\\partial y_1}\n\\end{pmatrix}\n\\quad \\quad\nD_{21} = \\frac{d\\mathbf{r}_1}{d\\mathbf{r}_2} = \\begin{pmatrix}\n\\displaystyle  \\frac{\\partial x_1}{\\partial X_2} & \\displaystyle \\frac{\\partial x_1}{\\partial Y_2} \\\\\n\\\\\n\\displaystyle  \\frac{\\partial y_1}{\\partial X_2} & \\displaystyle \\frac{\\partial y_1}{\\partial Y_2}\n\\end{pmatrix}\n\n\nNorms of the Jacobian matrices\n\n\nN_{12} = \\sqrt{\\left( \\frac{\\partial X_2}{\\partial x_1} \\right)^2 + \\left( \\frac{\\partial X_2}{\\partial y_1} \\right)^2 + \\left( \\frac{\\partial Y_2}{\\partial x_1} \\right)^2 + \\left( \\frac{\\partial Y_2}{\\partial y_1} \\right)^2}\n\n\nN_{21} = \\sqrt{\\left( \\frac{\\partial x_1}{\\partial X_2} \\right)^2 + \\left( \\frac{\\partial x_1}{\\partial Y_2} \\right)^2 + \\left( \\frac{\\partial y_1}{\\partial X_2} \\right)^2 + \\left( \\frac{\\partial y_1}{\\partial Y_2} \\right)^2}.\n\n\nDeterminants of the Jacobian matrices\n\n\n\\Delta_{12} = \\text{det}(D_{12})\n\\quad \\quad\n\\Delta_{21} = \\text{det}(D_{21})\n\n\nSquashing factor (or squashing degree) Q for a field line\n\n\nQ = \\frac{N_{12}^2}{|\\Delta_{12}|} = \\frac{N_{21}^2}{|\\Delta_{21}|}\n\n\nPariat (2020)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#qsl-reconnection",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#qsl-reconnection",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "QSL reconnection",
    "text": "QSL reconnection\n\nQSLs are preferential sites for electric current build-up and magnetic reconnection.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZhao et al. (2016), Yang et al. (2020), Pariat (2020), Cheng et al. (2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#qsl-reconnection-1",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#qsl-reconnection-1",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "QSL reconnection",
    "text": "QSL reconnection\n\nQSLs have been associated with flare ribbons in a large number of events.\n\n\n\n\n\n\n\n\n\nZhao et al. (2016), Yang et al. (2020), Pariat (2020), Cheng et al. (2023)"
  },
  {
    "objectID": "posts/solar_eruptions_magnetic_fields/index.html#fastqsl-zhang2022",
    "href": "posts/solar_eruptions_magnetic_fields/index.html#fastqsl-zhang2022",
    "title": "Solar Eruptions & Magnetic Fields",
    "section": "FastQSL (Zhang et al. 2022)",
    "text": "FastQSL (Zhang et al. 2022)\n\n\n\n\n\n\n\n\nComputation time : 107s for 900 x 540 x 360 grid data"
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html",
    "href": "posts/field-line-isee-nlfff/index.html",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "",
    "text": "The database contains the three-dimensional (3D) magnetic fields of solar active regions analyzed by Kusano et al.Â (2020). The 3D magnetic field are extrapolated by the magnetohydrodynamic relaxation method (Inoue et al., 2014) from the vector magnetic field data observed by the Solar Dynamics Observatory (SDO/HMI). In this database, Space weather HMI Active Region Patch data remapped to a Lambert Cylindrical Equal-Area projection (SHARP CEA) are used. For the detailed list and parameters of the sampled data, please refer to Kusano et al.Â (2020)."
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#isee-database-for-nonlinear-force-free-field-of-solar-active-regions",
    "href": "posts/field-line-isee-nlfff/index.html#isee-database-for-nonlinear-force-free-field-of-solar-active-regions",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "",
    "text": "The database contains the three-dimensional (3D) magnetic fields of solar active regions analyzed by Kusano et al.Â (2020). The 3D magnetic field are extrapolated by the magnetohydrodynamic relaxation method (Inoue et al., 2014) from the vector magnetic field data observed by the Solar Dynamics Observatory (SDO/HMI). In this database, Space weather HMI Active Region Patch data remapped to a Lambert Cylindrical Equal-Area projection (SHARP CEA) are used. For the detailed list and parameters of the sampled data, please refer to Kusano et al.Â (2020)."
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#download-a-sample-data",
    "href": "posts/field-line-isee-nlfff/index.html#download-a-sample-data",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "Download a sample data",
    "text": "Download a sample data\nI will use the 3D magnetic field data from NOAA active region 12673 at 2017-09-06 08:36:00. The data size is about 1.5 GB.\n\n# !wget https://hinode.isee.nagoya-u.ac.jp/nlfff_database/v12/12673/20170906/12673_20170906_083600.nc\n\n--2023-11-12 11:45:53--  https://hinode.isee.nagoya-u.ac.jp/nlfff_database/v12/12673/20170906/12673_20170906_083600.nc\nResolving hinode.isee.nagoya-u.ac.jp (hinode.isee.nagoya-u.ac.jp)... 133.47.151.53, 133.47.151.53\nConnecting to hinode.isee.nagoya-u.ac.jp (hinode.isee.nagoya-u.ac.jp)|133.47.151.53|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 1626400312 (1.5G) [application/x-netcdf]\nSaving to: â€˜12673_20170906_083600.ncâ€™\n\n12673_20170906_0836 100%[===================&gt;]   1.51G  1.74MB/s    in 5m 11s  \n\n2023-11-12 11:51:04 (4.99 MB/s) - â€˜12673_20170906_083600.ncâ€™ saved [1626400312/1626400312]"
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#a-sample-python-script-load_nlfff.py",
    "href": "posts/field-line-isee-nlfff/index.html#a-sample-python-script-load_nlfff.py",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "A sample Python script load_nlfff.py",
    "text": "A sample Python script load_nlfff.py\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport netCDF4\nimport sys\n\nclass nlfff:\n\n      def __init__(self,filename):\n            self.filename=filename\n\n            nc=netCDF4.Dataset(self.filename,'r')\n            self.NOAA=nc.NOAA\n            self.year_month_day_time=nc.year_month_day_time\n            self.project=nc.project\n            self.production_date=nc.production_date\n            self.version=nc.version\n            self.data_doi=nc.data_doi\n            self.http_link=nc.http_link\n            self.Distributor=nc.Distributor\n            \n            nc_x=nc.variables['x']\n            self.x=nc_x[:]\n            print(nc_x.long_name,' unit:',nc_x.units)\n            nc_y=nc.variables['y']\n            self.y=nc_y[:]\n            print(nc_y.long_name,' unit:',nc_y.units)\n            nc_z=nc.variables['z']\n            self.z=nc_z[:]\n            print(nc_z.long_name,' unit:',nc_z.units)\n            \n            nc_bx=nc.variables['Bx']\n            self.bx=nc_bx[:].transpose(2,1,0)\n            print(nc_bx.long_name,' unit:',nc_bx.units)\n            nc_by=nc.variables['By']\n            self.by=nc_by[:].transpose(2,1,0)\n            print(nc_by.long_name,' unit:',nc_by.units)\n            nc_bz=nc.variables['Bz']\n            self.bz=nc_bz[:].transpose(2,1,0)\n            print(nc_bz.long_name,' unit:',nc_bz.units)\n            \n            nc_bxp=nc.variables['Bx_pot']\n            self.bx_pot=nc_bxp[:].transpose(2,1,0)\n            print(nc_bxp.long_name,' unit:',nc_bxp.units)\n            nc_byp=nc.variables['By_pot']\n            self.by_pot=nc_byp[:].transpose(2,1,0)\n            print(nc_byp.long_name,' unit:',nc_byp.units)\n            nc_bzp=nc.variables['Bz_pot']\n            self.bz_pot=nc_bzp[:].transpose(2,1,0)\n            print(nc_bzp.long_name,' unit:',nc_bzp.units)\n            \n      def info(self):\n            print(f\"NOAA\",self.NOAA)\n            print(f'year_month_day_time',self.year_month_day_time)\n            print(f\"project\",self.project)\n            print(f\"production_date\",self.production_date)\n            print(f\"version\",self.version)\n            print(f\"data_doi\",self.data_doi)\n            print(f\"http_link\",self.http_link)\n            print(f\"Distributor\",self.Distributor)\n\n      def plot(self):\n            xs=12.0\n            ys=4.0\n\n            xmin=min(self.x)\n            xmax=max(self.x)\n            ymin=min(self.y)\n            ymax=max(self.y)\n\n            plt.close()\n            fig=plt.figure(figsize=(xs,ys))\n            ax1=fig.add_axes((0.08,0.35,0.25,0.25*xs/ys*(ymax-ymin)/(xmax-xmin)))\n            ax2=fig.add_axes((0.4,0.35,0.25,0.25*xs/ys*(ymax-ymin)/(xmax-xmin)))\n            ax3=fig.add_axes((0.72,0.35,0.25,0.25*xs/ys*(ymax-ymin)/(xmax-xmin)))\n            cax1=fig.add_axes((0.08,0.15,0.25,0.05))\n            cax2=fig.add_axes((0.4,0.15,0.25,0.05))\n            cax3=fig.add_axes((0.72,0.15,0.25,0.05))\n            \n            vmin=-3000.0 \n            vmax=3000.0\n            \n            im1=ax1.pcolormesh(self.x,self.y,self.bx[:,:,0].transpose(),vmin=vmin,vmax=vmax,cmap='gist_gray',shading='auto')\n            im2=ax2.pcolormesh(self.x,self.y,self.by[:,:,0].transpose(),vmin=vmin,vmax=vmax,cmap='gist_gray',shading='auto')\n            im3=ax3.pcolormesh(self.x,self.y,self.bz[:,:,0].transpose(),vmin=vmin,vmax=vmax,cmap='gist_gray',shading='auto')\n\n            cbar1=plt.colorbar(im1,cax=cax1,orientation='horizontal')\n            cbar2=plt.colorbar(im2,cax=cax2,orientation='horizontal')\n            cbar3=plt.colorbar(im3,cax=cax3,orientation='horizontal')\n            \n            ax1.set_title('Bx [G]')\n            ax1.set_xlabel('x [Mm]')\n            ax1.set_ylabel('y [Mm]')\n            \n            ax2.set_title('By [G]')\n            ax2.set_xlabel('x [Mm]')\n            ax2.set_ylabel('y [Mm]')\n            \n            ax3.set_title('Bz [G]')\n            ax3.set_xlabel('x [Mm]')\n            ax3.set_ylabel('y [Mm]')\n            \n            plt.pause(0.1)\n\n\ndata = nlfff('12673_20170906_083600.nc') \n\nx (westward)  unit: Mm\ny (northward)  unit: Mm\nz (out ot photosphere)  unit: Mm\nBx (westward)  unit: G\nBy (northward)  unit: G\nBz (out of photosphere)  unit: G\nBx_pot (westward)  unit: G\nBy_pot (northward)  unit: G\nBz_pot (out of photosphere)  unit: G\n\n\n\ndata.info()\n\nNOAA 12673\nyear_month_day_time 2017_9_6_83600\nproject ISEE Database for Nonlinear Force-Free Field of Solar Active Region\nproduction_date 2023-03-22\nversion v1.2\ndata_doi 10.34515/DATA.HSC-00000\nhttp_link https://hinode.isee.nagoya-u.ac.jp/nlfff_database/\nDistributor Hinode Science Center, Institute for Space-Earth Environmental Research, Nagoya University\n\n\n\ndata.plot()\n\n\n\n\n\n\n\n\n\nvars(data).keys()\n\ndict_keys(['filename', 'NOAA', 'year_month_day_time', 'project', 'production_date', 'version', 'data_doi', 'http_link', 'Distributor', 'x', 'y', 'z', 'bx', 'by', 'bz', 'bx_pot', 'by_pot', 'bz_pot'])"
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#visualization-script",
    "href": "posts/field-line-isee-nlfff/index.html#visualization-script",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "Visualization script",
    "text": "Visualization script\n\nimport numpy as np\nimport pyvista as pv\nimport k3d\nfrom k3d import matplotlib_color_maps\n\ndef create_coordinates(bounds):\n    xbounds = (bounds[0], bounds[1])\n    ybounds = (bounds[2], bounds[3])\n    zbounds = (bounds[4], bounds[5])\n    meshgrid = np.mgrid[xbounds[0]:xbounds[1]+1, ybounds[0]:ybounds[1]+1, zbounds[0]:zbounds[1]+1]\n    return np.stack(meshgrid, axis=-1).astype(np.float32)\n\n\ndef create_mesh(bx, by, bz):\n    bx, by, bz = map(np.array, (bx, by, bz))\n    Nx, Ny, Nz = bx.shape\n    co_bounds = (0, Nx-1, 0, Ny-1, 0, Nz-1)\n    co_coords = create_coordinates(co_bounds).reshape(-1, 3)\n    co_coord = co_coords.reshape(Nx, Ny, Nz, 3)\n    x = co_coord[..., 0]\n    y = co_coord[..., 1]\n    z = co_coord[..., 2]\n    mesh = pv.StructuredGrid(x, y, z)\n    vectors = np.stack([bx, by, bz], axis=-1).transpose(2, 1, 0, 3).reshape(-1, 3)\n    mesh['vector'] = vectors\n    mesh.active_vectors_name = 'vector'\n    magnitude = np.linalg.norm(vectors, axis=-1)\n    mesh['magnitude'] = magnitude\n    mesh.active_scalars_name = 'magnitude'\n    return mesh\n\n\ndef create_mesh_xyz(x, y, z, bx, by, bz):\n    x, y, z, bx, by, bz = map(np.array, (x, y, z, bx, by, bz))\n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    mesh = pv.StructuredGrid(X, Y, Z)\n    vectors = np.stack([bx, by, bz], axis=-1).transpose(2, 1, 0, 3).reshape(-1, 3)\n    mesh['vector'] = vectors\n    mesh.active_vectors_name = 'vector'\n    magnitude = np.linalg.norm(vectors, axis=-1)\n    mesh['magnitude'] = magnitude\n    mesh.active_scalars_name = 'magnitude'\n    return mesh\n\ndef plot_xy_yz_zx(p, dargs, targs):\n    pl = pv.Plotter()\n    pl.show_bounds()\n    pl.add_mesh(p.meshes[0])\n    pl.add_mesh(p.meshes[1], **dargs)\n    pl.add_mesh(p.meshes[2], **targs)\n    pl.camera_position = 'xy'\n    pl.show()\n\n    pl = pv.Plotter()\n    pl.show_bounds()\n    pl.add_mesh(p.meshes[0])\n    pl.add_mesh(p.meshes[1], **dargs)\n    pl.add_mesh(p.meshes[2], **targs)\n    pl.camera_position = 'yz'\n    pl.show()\n\n    pl = pv.Plotter()\n    pl.show_bounds()\n    pl.add_mesh(p.meshes[0])\n    pl.add_mesh(p.meshes[1], **dargs)\n    pl.add_mesh(p.meshes[2], **targs)\n    pl.camera_position = 'xz'\n    pl.show()\n\n\ndef plot_k3d(p):\n    plot = k3d.plot()\n    plot += k3d.vtk_poly_data(p.meshes[0])\n    plot += k3d.vtk_poly_data(p.meshes[1], color_attribute=('vector-2', -2500, 2500), color_map=matplotlib_color_maps.gray)\n    plot += k3d.vtk_poly_data(p.meshes[2])\n    plot.display()\n\n\nclass plotting:\n    def __init__(self, grid):\n        self.grid = grid\n        x_ind_min, y_ind_min, z_ind_min = 0, 0, 0\n        Nx, Ny, Nz = self.grid.dimensions\n        x_ind_max, y_ind_max, z_ind_max = Nx-1, Ny-1, Nz-1\n\n        self.x_ind_min, self.y_ind_min, self.z_ind_min = x_ind_min, y_ind_min, z_ind_min\n        self.x_ind_max, self.y_ind_max, self.z_ind_max = x_ind_max, y_ind_max, z_ind_max\n        \n        bottom_subset = (x_ind_min, x_ind_max, y_ind_min, y_ind_max, 0, 0)\n        bottom = self.grid.extract_subset(bottom_subset).extract_surface()\n        bottom.active_vectors_name = 'vector'\n        bottom.active_scalars_name = 'magnitude'\n\n        self.bottom = bottom\n\n        self.x_bottom = bottom.points[:, 0].reshape(Nx, Ny)\n        self.y_bottom = bottom.points[:, 1].reshape(Nx, Ny)\n        self.B_bottom = bottom['vector'].reshape(Nx, Ny, 3)\n\n        B = self.grid['vector'].reshape(Nz, Ny, Nx, 3)\n        self.B = B.transpose(2, 1, 0, 3)\n\n    def fieldline(self, window_size=None, title=None, title_fontsize=20, camera_position=None, i_siz=160, j_siz=100, i_resolution=16, j_resolution=16, vmin=-2500, vmax=2500, max_time=1000, tube_size=None):\n        p = pv.Plotter()\n        p.show_bounds()\n        p.add_mesh(self.grid.outline())\n        sargs = dict(\n            title='Bz [G]',\n            title_font_size=15,\n            height=0.25,\n            width=0.05,\n            vertical=True,\n            position_x = 0.05,\n            position_y = 0.05,\n        )\n        dargs = dict(\n            cmap='gray',\n            scalars='vector', \n            component=2, \n            clim=(vmin, vmax), \n            scalar_bar_args=sargs, \n            show_scalar_bar=True, \n            lighting=False\n        )\n        p.add_mesh(self.bottom, **dargs)\n\n        if (i_siz is not None) and (j_siz is not None):\n            i_size = i_siz\n            j_size = j_siz\n        else:\n            i_size = self.grid.bounds[1]-self.grid.bounds[0]\n            j_size = self.grid.bounds[3]-self.grid.bounds[2]\n        seed = pv.Plane(center=(self.grid.center[0], self.grid.center[1], 0), direction=(0,0,1), \n                i_size=i_size, j_size=j_size, \n                i_resolution=i_resolution, j_resolution=j_resolution)\n        strl = self.grid.streamlines_from_source(seed,\n                                                 vectors='vector',\n                                                 max_time=max_time,\n                                                 initial_step_length=0.1,\n                                                 integration_direction='both')\n        \n        targs = dict(\n            lighting=False,\n            color='blue'\n        )\n        if tube_size is not None:\n            p.add_mesh(strl.tube(radius=tube_size), **targs)\n        else:\n            p.add_mesh(strl.tube(radius=i_size/400), **targs)\n        if camera_position is not None:\n             p.camera_position = camera_position\n        if window_size is not None:\n            p.window_size = window_size\n        if title is not None:\n            p.add_title(title, font_size=title_fontsize)\n        return p, dargs, targs\n\n\npv.set_jupyter_backend('static')"
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#nonlinear-force-free-field",
    "href": "posts/field-line-isee-nlfff/index.html#nonlinear-force-free-field",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "Nonlinear force-free field",
    "text": "Nonlinear force-free field\n\ncreate_mesh\n\nmesh = create_mesh(data.bx, data.by, data.bz)\nB = plotting(mesh)\np, dargs, targs = B.fieldline()\np.show()\n\n\n\n\n\n\n\n\n\nplot_xy_yz_zx(p, dargs, targs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_k3d(p)\n\n\n\n\n\n    \n\n\n\ncreate_mesh_xyz\n\nmesh = create_mesh_xyz(data.x, data.y, data.z, data.bx, data.by, data.bz)\nB = plotting(mesh)\np, dargs, targs = B.fieldline()\np.show()\n\n\n\n\n\n\n\n\n\nplot_xy_yz_zx(p, dargs, targs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_k3d(p)"
  },
  {
    "objectID": "posts/field-line-isee-nlfff/index.html#potential-field",
    "href": "posts/field-line-isee-nlfff/index.html#potential-field",
    "title": "Visualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python",
    "section": "Potential field",
    "text": "Potential field\n\ncreate_mesh\n\nmesh = create_mesh(data.bx_pot, data.by_pot, data.bz_pot)\nBp = plotting(mesh)\np, dargs, targs = Bp.fieldline()\np.show()\n\n\n\n\n\n\n\n\n\nplot_xy_yz_zx(p, dargs, targs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_k3d(p)\n\n\n\n\n\n    \n\n\n\ncreate_mesh_xyz\n\nmesh = create_mesh_xyz(data.x, data.y, data.z, data.bx_pot, data.by_pot, data.bz_pot)\nBp = plotting(mesh)\np, dargs, targs = Bp.fieldline()\np.show()\n\n\n\n\n\n\n\n\n\nplot_xy_yz_zx(p, dargs, targs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_k3d(p)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Low and Lou (1990) force free magnetic fields\n\n\n\n\n\n\nsolar physics\n\n\nenglish\n\n\n\n\n\n\n\n\n\nMar 30, 2024\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nSolar Eruptions & Magnetic Fields\n\n\n\n\n\n\nsolar physics\n\n\nenglish\n\n\n\n\n\n\n\n\n\nMar 9, 2024\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nThe very, very basics of gravitational wave\n\n\n\n\n\n\nphysics\n\n\nenglish\n\n\n\n\n\n\n\n\n\nDec 25, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nVisualization of ISEE Nonlinear Force-Free Field of Solar Active Regions in Python\n\n\n\n\n\n\nsolar physics\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nNov 12, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nCalculating Derivatives of a 1D Scalar Function in Python\n\n\n\n\n\n\nmath\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nNov 4, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nì²œë¬¸ìš©ì–´ ì„¤ëª…\n\n\n\n\n\n\nastronomy\n\n\nkorean\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nSpherical Astronomy\n\n\n\n\n\n\nastronomy\n\n\nenglish\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Draw 1D Scalar Functions in Python\n\n\n\n\n\n\nmath\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nOct 20, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\në³´ì¡´ë²•ì¹™\n\n\n\n\n\n\nphysics\n\n\nkorean\n\n\n\n\n\n\n\n\n\nOct 20, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nMotion of Charged Particles in Magnetic Dipole Fields\n\n\n\n\n\n\nphysics\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nSep 25, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nStable Diffusion Inference with Diffusers (high-level)\n\n\n\n\n\n\ndeep learning\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nSep 10, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\n\n\n\n\n\n\nStable Diffusion Inference with Diffusers (low-level)\n\n\n\n\n\n\ndeep learning\n\n\npython\n\n\nenglish\n\n\n\n\n\n\n\n\n\nSep 10, 2023\n\n\nMingyu Jeon\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a masterâ€™s student affiliated with the Sun and Space Weather Laboratory at Kyung Hee University, studying how to apply machine learning methods to solar physics and space weather. My research interests include plasma physics and physics-informed machine learning."
  },
  {
    "objectID": "about.html#mingyu-jeon-ì „ë¯¼ê·œ",
    "href": "about.html#mingyu-jeon-ì „ë¯¼ê·œ",
    "title": "About",
    "section": "",
    "text": "I am a masterâ€™s student affiliated with the Sun and Space Weather Laboratory at Kyung Hee University, studying how to apply machine learning methods to solar physics and space weather. My research interests include plasma physics and physics-informed machine learning."
  },
  {
    "objectID": "posts/charged-particle-motion-in-dipole/index.html",
    "href": "posts/charged-particle-motion-in-dipole/index.html",
    "title": "Motion of Charged Particles in Magnetic Dipole Fields",
    "section": "",
    "text": "This post is based on the homework report that was written during the solar terrestrial physics class in 2022.\n\n\n\n\\mathbf{B} = -\\frac{\\mu_0}{4\\pi}\\left( \\frac{\\mathbf{m}}{r^3} - \\frac{3(\\mathbf{m}\\cdot\\mathbf{r})\\mathbf{r}}{r^5} \\right)\n\nIn (r, \\lambda, \\phi) coordinates, we describe the magnetic field as follows:\n\nB_r = Z = -\\frac{\\mu_0 m}{2\\pi}\\frac{\\sin\\lambda}{r^3}\n\n\nB_\\lambda = H = \\frac{\\mu_0 m}{4\\pi}\\frac{\\cos\\lambda}{r^3}\n\n\nB_\\phi = 0\n\nTherefore, the magnetic field \\mathbf{B} does not depend on longitude \\phi.\n\n\\mathbf{B} = \\mathbf{B}(r, \\lambda)\n\nThe strength B is given by:\n\nB = \\frac{\\mu_0 m}{4\\pi r^3}(1+3\\sin^2\\lambda)^{\\textstyle \\frac{1}{2}}\n\nFor the Earthâ€™s magnetic field at the equator, denoted as B_E, it can be expressed as:\n\nB_E = \\frac{\\mu_0 m}{4\\pi R_E^3}\n\nThe actual value for B_E is approximately 0.31 Gauss (G).\nThe components of the magnetic field can be re-express in terms of B_E as follows:\n\nB_r = -\\frac{2B_E}{(r/R_E)^3}\\sin\\lambda\n\n\nB_\\lambda = \\frac{B_E}{(r/R_E)^3}\\cos\\lambda\n\n\nB_\\phi = 0\n\nThe magnetic field line in the meridian (when \\phi=\\text{const} or in the (r,\\lambda)-plane) is given by:\n\nr = r_\\text{eq} \\cos^2\\lambda\n\nHere, r_\\text{eq} = LR_E and L is called L-parameter.\n\nL-parameter describes the set of magnetic field lines which cross the Earthâ€™s magnetic equator at a number of Earth-radii equal to the L-parameter. For example, L=2 describes the set of the Earthâ€™s magnetic field lines which cross the Earthâ€™s magnetic equator two earth radii from the center of the Earth.1\n\n\nThe dipole model of the Earthâ€™s magnetic field is a first order approximation of the rather complex true Earthâ€™s magnetic field. Due to effects of the interplanetary magnetic field (IMF), and the solar wind, the dipole model is particularly inaccurate at high L-shells (e.g., above L=3), but may be a good approximation for lower L-shells. For more precise work, or for any work at higher L-shells, a more accurate model that incorporates solar effects, such as the Tsyganenko magnetic field model, is recommended.2\n\n\n\\begin{align*}\n\\mathbf{B}(\\mathbf{r}) & = B_r(r, \\lambda) \\hat{r} + B_\\lambda (r, \\lambda) \\hat{\\lambda} \\\\\n& = B_x(x, y)\\hat{x} + B_y(x, y)\\hat{y}\n\\end{align*}\n\n\n\n\n\n\\frac{d^2\\mathbf{r}}{dt^2} = \\frac{q}{m}\\mathbf{v}\\times\\mathbf{B}\n\n\n\\frac{d^2x}{dt^2}\\hat{x} + \\frac{d^2y}{dt^2}\\hat{y} + \\frac{d^2z}{dt^2}\\hat{z} = \\frac{q}{m}(\\hat{x}(v_yB_z - v_zB_y) + \\hat{y}(v_zB_x - v_xB_z) + \\hat{z}(v_xB_y - v_yB_x))\n\n\n\\frac{d^2x}{dt^2} = \\frac{q}{m}(v_yB_z - v_zB_y)\n\n\n\\frac{d^2y}{dt^2} = \\frac{q}{m}(v_zB_x - v_xB_z)\n\n\n\\frac{d^2z}{dt^2} = \\frac{q}{m}(v_xB_y - v_yB_x)\n\n\n\n\n\n\\frac{dx}{dt} = v_x\n\n\n\\frac{dy}{dt} = v_y\n\n\n\\frac{dz}{dt} = v_z\n\n\n\\frac{dv_x}{dt} = \\frac{q}{m}(v_yB_z - v_zB_y)\n\n\n\\frac{dv_y}{dt} = \\frac{q}{m}(v_zB_x - v_xB_z)\n\n\n\\frac{dv_z}{dt} = \\frac{q}{m}(v_xB_y - v_yB_x)\n\n\n\n\n\nS = (x, y, z, v_x, v_y, v_z)\n\n\n\\frac{dS}{dt} = (\\frac{dx}{dt}, \\frac{dy}{dt}, \\frac{dz}{dt}, \\frac{dv_x}{dt}, \\frac{dv_y}{dt},\\frac{dv_z}{dt})"
  },
  {
    "objectID": "posts/charged-particle-motion-in-dipole/index.html#theory",
    "href": "posts/charged-particle-motion-in-dipole/index.html#theory",
    "title": "Motion of Charged Particles in Magnetic Dipole Fields",
    "section": "",
    "text": "This post is based on the homework report that was written during the solar terrestrial physics class in 2022.\n\n\n\n\\mathbf{B} = -\\frac{\\mu_0}{4\\pi}\\left( \\frac{\\mathbf{m}}{r^3} - \\frac{3(\\mathbf{m}\\cdot\\mathbf{r})\\mathbf{r}}{r^5} \\right)\n\nIn (r, \\lambda, \\phi) coordinates, we describe the magnetic field as follows:\n\nB_r = Z = -\\frac{\\mu_0 m}{2\\pi}\\frac{\\sin\\lambda}{r^3}\n\n\nB_\\lambda = H = \\frac{\\mu_0 m}{4\\pi}\\frac{\\cos\\lambda}{r^3}\n\n\nB_\\phi = 0\n\nTherefore, the magnetic field \\mathbf{B} does not depend on longitude \\phi.\n\n\\mathbf{B} = \\mathbf{B}(r, \\lambda)\n\nThe strength B is given by:\n\nB = \\frac{\\mu_0 m}{4\\pi r^3}(1+3\\sin^2\\lambda)^{\\textstyle \\frac{1}{2}}\n\nFor the Earthâ€™s magnetic field at the equator, denoted as B_E, it can be expressed as:\n\nB_E = \\frac{\\mu_0 m}{4\\pi R_E^3}\n\nThe actual value for B_E is approximately 0.31 Gauss (G).\nThe components of the magnetic field can be re-express in terms of B_E as follows:\n\nB_r = -\\frac{2B_E}{(r/R_E)^3}\\sin\\lambda\n\n\nB_\\lambda = \\frac{B_E}{(r/R_E)^3}\\cos\\lambda\n\n\nB_\\phi = 0\n\nThe magnetic field line in the meridian (when \\phi=\\text{const} or in the (r,\\lambda)-plane) is given by:\n\nr = r_\\text{eq} \\cos^2\\lambda\n\nHere, r_\\text{eq} = LR_E and L is called L-parameter.\n\nL-parameter describes the set of magnetic field lines which cross the Earthâ€™s magnetic equator at a number of Earth-radii equal to the L-parameter. For example, L=2 describes the set of the Earthâ€™s magnetic field lines which cross the Earthâ€™s magnetic equator two earth radii from the center of the Earth.1\n\n\nThe dipole model of the Earthâ€™s magnetic field is a first order approximation of the rather complex true Earthâ€™s magnetic field. Due to effects of the interplanetary magnetic field (IMF), and the solar wind, the dipole model is particularly inaccurate at high L-shells (e.g., above L=3), but may be a good approximation for lower L-shells. For more precise work, or for any work at higher L-shells, a more accurate model that incorporates solar effects, such as the Tsyganenko magnetic field model, is recommended.2\n\n\n\\begin{align*}\n\\mathbf{B}(\\mathbf{r}) & = B_r(r, \\lambda) \\hat{r} + B_\\lambda (r, \\lambda) \\hat{\\lambda} \\\\\n& = B_x(x, y)\\hat{x} + B_y(x, y)\\hat{y}\n\\end{align*}\n\n\n\n\n\n\\frac{d^2\\mathbf{r}}{dt^2} = \\frac{q}{m}\\mathbf{v}\\times\\mathbf{B}\n\n\n\\frac{d^2x}{dt^2}\\hat{x} + \\frac{d^2y}{dt^2}\\hat{y} + \\frac{d^2z}{dt^2}\\hat{z} = \\frac{q}{m}(\\hat{x}(v_yB_z - v_zB_y) + \\hat{y}(v_zB_x - v_xB_z) + \\hat{z}(v_xB_y - v_yB_x))\n\n\n\\frac{d^2x}{dt^2} = \\frac{q}{m}(v_yB_z - v_zB_y)\n\n\n\\frac{d^2y}{dt^2} = \\frac{q}{m}(v_zB_x - v_xB_z)\n\n\n\\frac{d^2z}{dt^2} = \\frac{q}{m}(v_xB_y - v_yB_x)\n\n\n\n\n\n\\frac{dx}{dt} = v_x\n\n\n\\frac{dy}{dt} = v_y\n\n\n\\frac{dz}{dt} = v_z\n\n\n\\frac{dv_x}{dt} = \\frac{q}{m}(v_yB_z - v_zB_y)\n\n\n\\frac{dv_y}{dt} = \\frac{q}{m}(v_zB_x - v_xB_z)\n\n\n\\frac{dv_z}{dt} = \\frac{q}{m}(v_xB_y - v_yB_x)\n\n\n\n\n\nS = (x, y, z, v_x, v_y, v_z)\n\n\n\\frac{dS}{dt} = (\\frac{dx}{dt}, \\frac{dy}{dt}, \\frac{dz}{dt}, \\frac{dv_x}{dt}, \\frac{dv_y}{dt},\\frac{dv_z}{dt})"
  },
  {
    "objectID": "posts/charged-particle-motion-in-dipole/index.html#code",
    "href": "posts/charged-particle-motion-in-dipole/index.html#code",
    "title": "Motion of Charged Particles in Magnetic Dipole Fields",
    "section": "Code",
    "text": "Code\n\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom matplotlib.animation import FuncAnimation\n\n\n# Be = 0.31 G = 0.31 * 10^-4 T\nBe = 0.31 * 1e-4\n# Re = 6371 km = 6371 * 10^3 m\nRe = 6371 * 1e3\nC = Be * (Re**3)\n\n\ndef B(x, y, z):\n    \"\"\"dipole field at (x, y, z)\"\"\"\n    r = np.sqrt(x**2 + y**2 + z**2)\n    Bx = -1 * C * (3 * x * z) / (r**5)\n    By = -1 * C * (3 * y * z) / (r**5)\n    Bz = C * (r**2 - 3 * z**2) / (r**5)\n    return Bx, By, Bz\n\n\ndef field_line_3D(phi, L=6.6):\n    \"\"\"dipole field line (3D)\"\"\"\n    phi = np.deg2rad(phi)\n    theta = np.linspace(0, 2 * np.pi, 1000)\n    rf = L * np.sin(theta) ** 2\n    xf = rf * np.sin(theta) * np.cos(phi)\n    yf = rf * np.sin(theta) * np.sin(phi)\n    zf = rf * np.cos(theta)\n    return xf, yf, zf\n\n\ndef field_line_2D(L=6.6):\n    \"\"\"dipole field line (2D)\"\"\"\n    lamb = np.linspace(0, 2 * np.pi, 1000)\n    rf2 = L * np.cos(lamb) ** 2\n    xf2 = rf2 * np.cos(lamb)\n    zf2 = rf2 * np.sin(lamb)\n    return xf2, zf2\n\n\ndef dSdt(S, t, q_over_m):\n    \"\"\"dS/dt for odeint\"\"\"\n    x, y, z, vx, vy, vz = S\n    Bx, By, Bz = B(x, y, z)\n    dvxdt = q_over_m * (vy * Bz - vz * By)\n    dvydt = q_over_m * (vz * Bx - vx * Bz)\n    dvzdt = q_over_m * (vx * By - vy * Bx)\n    return [vx, vy, vz, dvxdt, dvydt, dvzdt]\n\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot()\nxmin, xmax = -7, 7\nymin, ymax = -7, 7\n\nax.add_patch(\n    plt.Circle(\n        (0, 0), 1, zorder=99, facecolor=\"white\", edgecolor=\"black\", label=\"Earth\"\n    )\n)\nax.set_aspect(\"equal\")\nax.legend()\nax.axhline(y=0, color=\"black\", linewidth=0.5)\nax.xaxis.grid(True, which=\"both\")\nax.set_xlim(xmin, xmax)\nax.set_ylim(ymin, ymax)\nmajors = np.arange(xmin + 1, xmax, 1)\nax.xaxis.set_major_locator(ticker.FixedLocator(majors))\nax.set_xlabel(\"x ($R_E$)\")\nax.set_ylabel(\"z ($R_E$)\")\n\nLvalues = [2, 4, 6, 8, 10, 20, 100]\ncolors = [\"r\", \"darkorange\", \"gold\", \"green\", \"blue\", \"magenta\", \"purple\"]\nlamb = np.linspace(0, 2 * np.pi, 1000)\nfor i, L in enumerate(Lvalues):\n    x, z = field_line_2D(L)\n    ax.plot(x, z, label=f\"L={L}\", color=colors[i])\n\nax.legend()\nax.set_title(\"Magnetic Dipole Field line (2D)\")\nplt.show()\n\n\n\n\n\n\n\n\n\nspecies = \"Proton\"\n\ne = 1.602e-19\nq = e  # C\n\nmH = 1.67e-27\nm = mH  # kg\nq_over_m = q / m\n\nE_keV = 2000  # keV\n\n\n# L-parameter\nL = 6.6\n\n# start at equator\nx0, y0, z0 = L * Re, 0, 0\n\nkeV_to_J = 1e3 * e  # J\n\n# particle energy (keV) and pitch angle\nE = E_keV * keV_to_J  # J\npitch_angle_deg = 30\nalpha = np.deg2rad(pitch_angle_deg)\n\n# particle velocity\nv0 = np.sqrt(2 * E / m)\n\n# vx = v_perp\n# vy = 0\n# vz = v_para\nvx0 = v0 * np.sin(alpha)\nvy0 = 0\nvz0 = v0 * np.cos(alpha)\n\n# bounce time_scale\nt_B = 290 * (np.pi * L / 10) * np.sqrt(m / (mH * E_keV))\nprint(f\"bounce time scale ~ {t_B} s\")\n\nS0 = [x0, y0, z0, vx0, vy0, vz0]\n\n# number of bounce\nn = 3\n\ntmin = 0\ntmax = n * t_B\n\nt = np.linspace(tmin, tmax, 1000)\n\n# solve ODE\nsol = odeint(dSdt, S0, t, args=(q_over_m,))\nx, y, z, vx, vy, vz = sol.T\nx, y, z = x / Re, y / Re, z / Re\n\nprint(f\"t_max ~ {tmax:.4f} s\")\n\nbounce time scale ~ 13.44549539521195 s\nt_max ~ 40.3365 s\n\n\n\ntrajectory_linewidth = 0.8\nfieldline_linewidth = 0.5\n\n\n# xyzrange = 10\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection=\"3d\")\nax.set_aspect(\"equal\")\n# ax.plot([-xyzrange,xyzrange], [0,0], [0, 0], color='black')\n# ax.plot([0,0], [-xyzrange,xyzrange], [0, 0], color='black')\n# ax.plot([0,0], [0,0], [-xyzrange, xyzrange], color='black')\nax.plot(\n    x,\n    y,\n    z,\n    color=\"red\",\n    label=\"Particle Trajectory\",\n    linewidth=trajectory_linewidth,\n    zorder=200,\n)\nax.set_xlabel(\"x ($R_E$)\")\nax.set_ylabel(\"y ($R_E$)\")\nax.set_zlabel(\"z ($R_E$)\")\nax.set_xlim(-L, L)\nax.set_ylim(-L, L)\nax.set_zlim(-L, L)\nfor az in np.arange(0, 361, 20):\n    xf, yf, zf = field_line_3D(az, L)\n    if az == 360:\n        ax.plot(\n            xf,\n            yf,\n            zf,\n            color=\"blue\",\n            linewidth=fieldline_linewidth,\n            zorder=-1,\n            label=f\"Magnetic Field (L={L})\",\n        )\n    else:\n        ax.plot(xf, yf, zf, color=\"blue\", linewidth=fieldline_linewidth, zorder=-1)\n\n# Sphere with radius Re\nu = np.linspace(0, 2 * np.pi, 1000)\nv = np.linspace(0, np.pi, 1000)\nxs = 1 * np.outer(np.cos(u), np.sin(v))\nys = 1 * np.outer(np.sin(u), np.sin(v))\nzs = 1 * np.outer(np.ones(np.size(u)), np.cos(v))\nax.set_title(\n    f\"{species}, E = {E_keV/1000:.0f} MeV, initial pitch angle = {pitch_angle_deg} deg\"\n)\nax.plot_surface(xs, ys, zs, color=\"white\", alpha=1)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot()\nax.set_aspect(\"equal\")\nax.add_patch(\n    plt.Circle(\n        (0, 0), 1, zorder=99, facecolor=\"white\", edgecolor=\"black\", label=\"Earth\"\n    )\n)\nax.plot([-10, 10], [0, 0], color=\"black\")\nax.plot([0, 0], [-10, 10], color=\"black\")\nax.plot(\n    x,\n    y,\n    color=\"red\",\n    label=\"Particle Trajectory\",\n    linewidth=trajectory_linewidth,\n    zorder=200,\n)\nax.set_xlabel(\"x ($R_E$)\")\nax.set_ylabel(\"y ($R_E$)\")\nax.set_xlim(-L - 1, L + 1)\nax.set_ylim(-L - 1, L + 1)\ntheta = np.linspace(0, 2 * np.pi, 100)\nrc = L\nxc = rc * np.cos(theta)\nyc = rc * np.sin(theta)\nplt.plot(xc, yc, color=\"green\", zorder=-1, label=f\"Circle with radius L={L}\")\nax.set_title(\n    f\"{species}, E = {E_keV/1000:.0f} MeV, initial pitch angle = {pitch_angle_deg} deg\"\n)\nax.legend(loc=1)\nplt.show()\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot()\nax.add_patch(\n    plt.Circle(\n        (0, 0), 1, zorder=99, facecolor=\"white\", edgecolor=\"black\", label=\"Earth\"\n    )\n)\nax.set_aspect(\"equal\")\nax.plot([-10, 10], [0, 0], color=\"black\")\nax.plot([0, 0], [-10, 10], color=\"black\")\nax.plot(\n    x,\n    z,\n    color=\"red\",\n    label=\"Particle Trajectory\",\n    linewidth=trajectory_linewidth,\n    zorder=200,\n)\nax.set_xlabel(\"x ($R_E$)\")\nax.set_ylabel(\"z ($R_E$)\")\nax.set_xlim(-L - 1, L + 1)\nax.set_ylim(-L - 1, L + 1)\n\nxf2, zf2 = field_line_2D(L)\nax.plot(xf2, zf2, zorder=-1, color=\"blue\", label=f\"Magnetic field line (L={L})\")\nax.set_title(\n    f\"{species}, E = {E_keV/1000:.0f} MeV, initial pitch angle = {pitch_angle_deg} deg\"\n)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot()\nax.add_patch(\n    plt.Circle(\n        (0, 0), 1, zorder=99, facecolor=\"white\", edgecolor=\"black\", label=\"Earth\"\n    )\n)\nax.set_aspect(\"equal\")\nax.plot([-10, 10], [0, 0], color=\"black\")\nax.plot([0, 0], [-10, 10], color=\"black\")\nax.plot(\n    x,\n    z,\n    color=\"red\",\n    label=\"Particle Trajectory\",\n    linewidth=trajectory_linewidth,\n    zorder=200,\n)\nax.set_xlabel(\"x ($R_E$)\")\nax.set_ylabel(\"z ($R_E$)\")\nax.set_xlim(-L - 1, L + 1)\nax.set_ylim(-L - 1, L + 1)\n\nxf2, zf2 = field_line_2D(L)\nax.plot(xf2, zf2, zorder=-1, color=\"blue\", label=f\"Magnetic field line (L={L})\")\nax.set_title(\n    f\"{species}, E = {E_keV/1000:.0f} MeV, initial pitch angle = {pitch_angle_deg} deg\"\n)\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nfig = plt.figure(figsize=(16, 8))\nax1 = plt.subplot(121)\nax2 = plt.subplot(122, projection=\"3d\")\n\nxdata = x\nydata = y\nzdata = z\n\nsc1 = ax1.scatter([], [], color=\"green\")\n(ln1,) = ax1.plot([], [], \"r-\", zorder=99)\nsc2 = ax2.scatter([], [], [], color=\"green\")\n(ln2,) = ax2.plot([], [], [], \"r-\", zorder=99)\n\n# Field line (2D)\nxf2, zf2 = field_line_2D(L)\nax1.plot(xf2, zf2, zorder=-1, color=\"blue\", label=f\"Magnetic field line (L={L})\")\n\n# Earth (2D)\nax1.add_patch(plt.Circle((0, 0), 1, zorder=99, facecolor=\"white\", edgecolor=\"black\"))\n\n# Field line (3D)\nfor az in np.arange(0, 361, 20):\n    xf, yf, zf = field_line_3D(az, L)\n    if az == 360:\n        ax2.plot(\n            xf,\n            yf,\n            zf,\n            color=\"blue\",\n            linewidth=fieldline_linewidth,\n            zorder=-1,\n            label=f\"Magnetic Field (L={L})\",\n        )\n    else:\n        ax2.plot(xf, yf, zf, color=\"blue\", linewidth=fieldline_linewidth, zorder=-1)\n\n# Earth (3D)\nu = np.linspace(0, 2 * np.pi, 1000)\nv = np.linspace(0, np.pi, 1000)\nxs = 1 * np.outer(np.cos(u), np.sin(v))\nys = 1 * np.outer(np.sin(u), np.sin(v))\nzs = 1 * np.outer(np.ones(np.size(u)), np.cos(v))\nax2.plot_surface(xs, ys, zs, color=\"white\", alpha=1)\n\n\ndef init():\n    ax1.set_aspect(\"equal\")\n    ax1.plot([-10, 10], [0, 0], color=\"black\")\n    ax1.plot([0, 0], [-10, 10], color=\"black\")\n    ax1.set_xlabel(\"x ($R_E$)\")\n    ax1.set_ylabel(\"z ($R_E$)\")\n    ax1.set_xlim(-L - 1, L + 1)\n    ax1.set_ylim(-L - 1, L + 1)\n\n    ax2.set_aspect(\"equal\")\n    ax2.plot([-10, 10], [0, 0], [0, 0], color=\"black\")\n    ax2.plot([0, 0], [-10, 10], [0, 0], color=\"black\")\n    ax2.plot([0, 0], [0, 0], [-10, 10], color=\"black\")\n    ax2.set_xlabel(\"x ($R_E$)\")\n    ax2.set_ylabel(\"y ($R_E$)\")\n    ax2.set_zlabel(\"z ($R_E$)\")\n    ax2.set_xlim(-L, L)\n    ax2.set_ylim(-L, L)\n    ax2.set_zlim(-L, L)\n\n    return ln1, ln2\n\n\ndef update(frame):\n    sc1.set_offsets([xdata[frame - 1], zdata[frame - 1]])\n    ln1.set_data(xdata[:frame], zdata[:frame])\n    ln1.set_label(f\"t={frame}\")\n    ax1.legend()\n\n    sc2._offsets3d = ([xdata[frame - 1]], [ydata[frame - 1]], [zdata[frame - 1]])\n    ln2.set_data(xdata[:frame], ydata[:frame])\n    ln2.set_3d_properties(zdata[:frame])\n    ln2.set_label(f\"t={frame}\")\n    ax2.legend()\n    return ln1, ln2\n\n\nani = FuncAnimation(\n    fig, update, frames=np.arange(1, len(xdata)), init_func=init, blit=True\n)\n\nani.save(\"simulation.gif\", fps=30)\n\n\n\nani.save(\"simulation.mp4\", fps=30)"
  },
  {
    "objectID": "posts/charged-particle-motion-in-dipole/index.html#footnotes",
    "href": "posts/charged-particle-motion-in-dipole/index.html#footnotes",
    "title": "Motion of Charged Particles in Magnetic Dipole Fields",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://en.wikipedia.org/wiki/L-shellâ†©ï¸\nhttps://en.wikipedia.org/wiki/Dipole_model_of_the_Earth%27s_magnetic_fieldâ†©ï¸"
  },
  {
    "objectID": "posts/explain-words/index.html",
    "href": "posts/explain-words/index.html",
    "title": "ì²œë¬¸ìš©ì–´ ì„¤ëª…",
    "section": "",
    "text": "2019ë…„ ìš°ì£¼ê´€ì¸¡ ìˆ˜ì—…ì—ì„œ 2020 ì—­ì„œ 09. ì²œë¬¸ìƒìˆ˜ì™€ ìë£Œ ì„¤ëª…ìš©ìœ¼ë¡œ ì‘ì„±í•œ ê¸€"
  },
  {
    "objectID": "posts/explain-words/index.html#êµ­ì œì²œë¬¸ì—°ë§¹-ì²œë¬¸ìƒìˆ˜",
    "href": "posts/explain-words/index.html#êµ­ì œì²œë¬¸ì—°ë§¹-ì²œë¬¸ìƒìˆ˜",
    "title": "ì²œë¬¸ìš©ì–´ ì„¤ëª…",
    "section": "êµ­ì œì²œë¬¸ì—°ë§¹ ì²œë¬¸ìƒìˆ˜",
    "text": "êµ­ì œì²œë¬¸ì—°ë§¹ ì²œë¬¸ìƒìˆ˜\n\nTT, TCG, TCB, TDB\n\n\\text{TCG} = \\text{TT} + L_G \\times (\\text{JD} - 2443144.5) \\times 86400 \\ \\text{s}\n\n\n(\\text{TCB}-\\text{TCG})_{\\text{secular}} = L_C \\times (\\text{JD} - 2443144.5) \\times 86400 \\ \\text{s}\n\n\n\\text{TDB} = \\text{TCB} - L_B \\times (\\text{JD}_{\\text{TCB}} - T_0) \\times 86400 \\ \\text{s} + \\text{TDB}_0\n\n\n\\text{TDB}(T_0) - \\text{TCB}(T_0) = (\\text{TDB} - \\text{TCB} \\quad \\text{at} \\quad \\text{JD}_{\\text{TCB}} = T_0)\n\nSIë‹¨ìœ„ê³„(International System of Units)ì˜ 1 ì´ˆ(second)ëŠ” í˜„ì¬ ì„¸ìŠ˜-133 ì›ìì˜ ì„­ë™ì´ ì—†ëŠ” ë°”ë‹¥ìƒíƒœì˜ ì´ˆë¯¸ì„¸ ì „ì´ ì£¼íŒŒìˆ˜ \\Delta \\nu_{\\text{Cs}}ë¥¼ Hz ë‹¨ìœ„ë¡œ ë‚˜íƒ€ë‚  ë•Œ ê·¸ ìˆ˜ì¹˜ë¥¼ 9 192 631 770ìœ¼ë¡œ ê³ ì •í•¨ìœ¼ë¡œì¨ ì •ì˜ëœë‹¤. ì—¬ê¸°ì„œ HzëŠ” s^{-1}ê³¼ ê°™ë‹¤.\nTAI(International Atomic Time)ëŠ” ì›ìì‹œê³„ì— ê¸°ë°˜í•œ ì‹œì²™ë„ì´ë©°, BIPM(International Bureau of Weights and Measures)ì˜ ë¶„ì„ì— ì˜í•´ ìœ ì§€ë˜ê³  ìˆë‹¤. TAIì˜ ë‹¨ìœ„ì‹œê°„ ê¸¸ì´ëŠ” ì§€ì˜¤ì´ë“œì—ì„œì˜ SIì´ˆì´ë‹¤.\nì§€êµ¬ í‘œë©´ì—ì„œ ì •ì˜ëœ ì¢Œí‘œì‹œê°„(coordinate time)ì„ TT(Terrestrial Time)ë¼ê³  ë¶€ë¥¸ë‹¤. ì§€í‘œë©´ì—ì„œ ì´ë£¨ì–´ì§€ëŠ” ì²œë¬¸ê´€ì¸¡ì—ì„œì˜ ì‹œê°„ì¸¡ì •ì— ì£¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì‹œì²™ë„ì´ë‹¤. TTì˜ ë‹¨ìœ„ ì‹œê°„ ê¸¸ì´ëŠ” TAIì˜ ë‹¨ìœ„ ì‹œê°„ ê¸¸ì´ë¡œ ì •ì˜í•˜ë©°, TAI 1977ë…„ 1ì›” 1ì¼ 0ì‹œ 0ë¶„ 0ì´ˆë¥¼ TT 1977ë…„ 1ì›” 1ì¼ 0ì‹œ 0ë¶„ 32.184ì´ˆë¡œ ì •ì˜í•œë‹¤.ì—­ì‚¬ì ìœ¼ë¡œ ET(Ephemeris Time)ë¥¼ TDT(Terrestrial Dynamic Time)ê°€ ê³„ìŠ¹í•˜ê³  TDTë¥¼ TTê°€ ê³„ìŠ¹í•˜ê¸°ì— 32.184ì´ˆê°€ ë¶™ëŠ”ë‹¤.\nGCRS(Geocentric Celestial Reference System)ëŠ” ì§€êµ¬ì˜ ì§ˆëŸ‰ì¤‘ì‹¬ì— ì›ì ì„ ë‘” ì¢Œí‘œê³„ì´ë©°, ì§€êµ¬ì ‘ê·¼ì²œì²´(near-Earth object, NEO)ì— ëŒ€í•œ ì—­í•™ì  ê³„ì‚°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì¢Œí‘œê³„ì´ë‹¤. GCRSì˜ ì‹œê°„ì„ TCG(Geocentric Coordinate Time)ë¼ê³  ë¶€ë¥¸ë‹¤. TCGëŠ” ì¤‘ë ¥ì— ì˜í•œ ì‹œê°„ ì§€ì—° íš¨ê³¼ë¥¼ ëª¨ë‘ ë¬´ì‹œí•˜ì˜€ì„ ë•Œ, ì§€êµ¬ì˜ ì§ˆëŸ‰ì¤‘ì‹¬ê³¼ ê°™ì´ ì›€ì§ì´ëŠ” ì¢Œí‘œê³„ì˜ ê³ ìœ ì‹œê°„(proper time)ì´ë‹¤.\nBCRS(Barycentric Celestial Reference System)ëŠ” íƒœì–‘ê³„ì˜ ì§ˆëŸ‰ì¤‘ì‹¬ì— ì›ì ì„ ë‘” ì¢Œí‘œê³„ì´ë©°, ì¼ë°˜ì ì¸ ì²œì²´ì— ëŒ€í•œ ì—­í•™ì  ê³„ì‚°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì¢Œí‘œê³„ì´ë‹¤. BCRSì˜ ì‹œê°„ì„ TCB(Barycentric Coordinate Time)ë¼ê³  ë¶€ë¥¸ë‹¤. TCBëŠ” ì¤‘ë ¥ì— ì˜í•œ ì‹œê°„ ì§€ì—° íš¨ê³¼ë¥¼ ëª¨ë‘ ë¬´ì‹œí•˜ì˜€ì„ë•Œ,íƒœì–‘ê³„ì˜ ì§ˆëŸ‰ì¤‘ì‹¬ê³¼ ê°™ì´ ì›€ì§ì´ëŠ” ì¢Œí‘œê³„ì˜ ê³ ìœ ì‹œê°„(proper time)ì´ë‹¤.\nTDB(Barycentric Dynamical Time)ëŠ” 2006ë…„ ì´í›„ë¡œ TCBë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜ëœë‹¤.\nê° ì‹œìŠ¤í…œ ì‹œê°„ì˜ ë‹¨ìœ„ ì‹œê°„ ê¸¸ì´ëŠ” ìƒëŒ€ë¡ ì  íš¨ê³¼ì— ì˜í•´ ë¯¸ì„¸í•˜ê²Œ ë‹¤ë¥´ë‹¤.ê°ê°ì˜ ë‹¨ìœ„ ì‹œê°„ ê¸¸ì´ë¥¼ \\rm{d}(\\text{TT}), \\rm{d}(\\text{TCG}), \\rm{d}(\\text{TCB}), \\rm{d}(\\text{TDB}) ì²˜ëŸ¼ ë‚˜íƒ€ë‚¸ë‹¤.\n\n\nì§€êµ¬ìì „ê°(ERA)\nì§€êµ¬ìì „ê°(ERA, Earth Rotation Angle)ëŠ” í•­ì„±ì‹œ(Sidereal time)ì™€ ë¹„ìŠ·í•œ ê°œë…ìœ¼ë¡œ, ì§€êµ¬ê°€ ìì „ì— ì˜í•´ ëŒì•„ê°„ ê°ë„ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. revëŠ” revolutions(íšŒì „)ì˜ ì¤„ì„ë§ì´ë‹¤.\n\n1 \\text{ rev} = 1 \\text{ íšŒì „} = 360^\\circ\n\n\n\níƒœì–‘ì§ˆëŸ‰ì¸ìˆ˜(íƒœì–‘ì¤‘ë ¥ìƒìˆ˜), ì§€êµ¬ì¤‘ë ¥ìƒìˆ˜\nGMì˜ ê²½ìš° ì²œë¬¸ê´€ì¸¡ì— ì˜í•´ ì¸¡ì •ì´ ê°€ëŠ¥í•˜ë‚˜, GëŠ” ë§¤ìš° ì •ë°€í•œ ì‹¤í—˜ì— ì˜í•´ì„œë§Œ ì¸¡ì •ì´ ê°€ëŠ¥í•˜ë‹¤. ë”°ë¼ì„œ GMì˜ ì •í™•ë„ê°€ G, Më³´ë‹¤ ë†’ì€ ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ ì²œë¬¸ìƒìˆ˜ì— GM ê°’ì„ ëª…ì‹œí•œ ê²ƒì´ë‹¤.\n\n\nì§€êµ¬ì ë„ë°˜ê²½\nSI m(ë¯¸í„°)ëŠ” SI s(ì´ˆ)ì— ê¸°ë°˜í•˜ì—¬ ì •ì˜ë˜ë¯€ë¡œ, m ë‹¨ìœ„ì˜ ìƒìˆ˜ì—ë„ ì‹œì²™ë„ [\\text{TT}]ë¥¼ ë°íŒ ê²ƒì´ë‹¤. \na_E = a_e\n\n\n\nì§€êµ¬ì—­í•™ê³„ìˆ˜, ì§€êµ¬ì—­í•™ê³„ìˆ˜ ì‹œê°„ë³€í™”ìœ¨\nì§€êµ¬ë¥¼ ê½‰ì°¬ íšŒì „íƒ€ì›ë©´(spheroid)í˜•íƒœì˜ ì§ˆëŸ‰ì²´ë¼ê³  ê°€ì •í•˜ì. ì›ì ì´ ì§€êµ¬ì˜ ì§ˆëŸ‰ì¤‘ì‹¬ì— ìœ„ì¹˜í•˜ê³ , ì§€êµ¬ì˜ íšŒì „ì´ ê´€ì¸¡ë˜ì§€ ì•ŠëŠ” êµ¬ë©´ì¢Œí‘œê³„(spherical coordinate system)ì—ì„œì˜ ì§€êµ¬ ì¤‘ë ¥ í¬í…ì…œ(potential) \\phiëŠ” ì§€êµ¬ ì¤‘ë ¥ìƒìˆ˜ \\mu = GM_Eì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§„ë‹¤. \n\\phi = - \\frac{\\mu}{r} + \\sum_{n=2}^{\\infty} \\frac{J_n P_n(\\sin \\theta)}{r^{n+1}}\n\nì—¬ê¸°ì„œ P_nì€ ë¥´ì¥ë“œë¥´ ë‹¤í•­ì‹(Legendre polynomial)ìœ¼ë¡œ, ë¡œë“œë¦¬ê²ŒìŠ¤ê³µì‹(Rodriguesâ€™ formula)ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. \nP_n(x) = \\frac{1}{2^n n!} \\frac{d^n}{dx^n} (x^2 - 1)^n\n\n\\phiì—ì„œ ì²«í•­ì„ ì œì™¸í•œ ì§€ë°°í•­(dominating term)ì€ n=2ì¸ J_2 termìœ¼ë¡œ, n \\geq 3 í•­ë“¤ì€ ì¼ë°˜ì ìœ¼ë¡œ ë¬´ì‹œê°€ëŠ¥í•˜ë‹¤. J_2 í•­ì€ ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§„ë‹¤.\n\\phi_{J_2 \\  \\text{term}} = \\frac{J_2 P_2(\\sin \\theta)}{r^3} = J_2 \\frac{3 \\sin^2 \\theta - 1}{2r^3}\nì—¬ê¸°ì„œ J_2 í•­ì˜ ê³„ìˆ˜ê°€ J_2ì´ë©°, ì§€êµ¬ì—­í•™ê³„ìˆ˜(Dynamical form-factor for the Earth)ë¼ê³  ë¶€ë¥¸ë‹¤. ì§€êµ¬ì—­í•™ê³„ìˆ˜ ì‹œê°„ë³€í™”ìœ¨ì—ì„œ cyëŠ” century(1ì„¸ê¸°, 100ë…„)ì˜ ì¤„ì„ë§ì´ë‹¤.\nJ_2ì˜ ê°’ì€ ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤.\n\nJ_2 = \\frac{2}{3}f - \\frac{a^3 \\omega^2}{3GM_E}\n\nì—¬ê¸°ì„œ fëŠ” ì§€êµ¬ í¸í‰ë„, aëŠ” ì§€êµ¬ ì ë„ë°˜ê²½, \\omegaëŠ” ì§€êµ¬ í‰ê·  ê°ì†ë„, GM_EëŠ” ì§€êµ¬ ì¤‘ë ¥ìƒìˆ˜ì´ë‹¤.\n\n\nì§€ì˜¤ì´ë“œ í¬í…ì…œ\nì¤‘ë ¥ì¥(gravitational field) \\mathbf{g}ì— ëŒ€í•´ \\mathbf{g} = - \\nabla \\phië¥¼ ë§Œì¡±ì‹œí‚¤ëŠ” ìŠ¤ì¹¼ë¼ì¥(scalar field) \\phië¥¼ ì¤‘ë ¥ í¬í…ì…œ(potential)ì´ë¼ê³  ë¶€ë¥¸ë‹¤.\nì§€êµ¬ ì¤‘ë ¥ì¥ì˜ ë“±í¼í…ì…œë©´(equipotential surface)ì„ ì§€ì˜¤ì´ë“œ(geoid)ë¼ê³  ë¶€ë¥¸ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì •ì˜ì— ì˜í•´ ì§€ì˜¤ì´ë“œëŠ” ì¤‘ë ¥ì— ìˆ˜ì§ì´ë‹¤. ë˜í•œ ì§€ì˜¤ì´ë“œëŠ” ë¬´ìˆ˜íˆ ë§ìœ¼ë©°, ê°ê°ì— ëŒ€ì‘ë˜ëŠ” ì§€ì˜¤ì´ë“œ í¬í…ì…œë„ ë¬´ìˆ˜íˆ ë§ë‹¤. ë‹¤ë§Œ ê´€ìŠµì ìœ¼ë¡œ íŠ¹ì •í•œ ë“±í¬í…ì…œë©´(ë°”ë‹¤ì—ì„œëŠ” í‰ê·  í•´ìˆ˜ë©´, ìœ¡ì§€ì—ì„œëŠ” í‰ê·  í•´ìˆ˜ë©´ì„ ì—°ì¥í•œ ê³¡ë©´)ì„ ì§€ì˜¤ì´ë“œë¼ê³  ë¶€ë¥¸ë‹¤. ì§€ì˜¤ì´ë“œ í¬í…ì…œ W_0ëŠ” í˜„ì¬ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœë‹¤. \nW_0 = c^2 L_G\n\n\n\nì§€êµ¬ í¸í‰ë„ ì—­ìˆ˜ (IERS 2010)\nì§€êµ¬ëŠ” ìì „ì— ì˜í•´ ì ë„ë°˜ê²½ì´ ê·¹ë°˜ê²½ë³´ë‹¤ ê¸¸ë‹¤. ë”°ë¼ì„œ ì§€êµ¬ì˜ ë‹¨ë©´ì„ ì¥ë°˜ê²½ì´ a, ë‹¨ë°˜ê²½ì´ bì¸ íƒ€ì›ìœ¼ë¡œ ê·¼ì‚¬ ê°€ëŠ¥í•˜ë‹¤. ì´ë•Œ ì§€êµ¬ í¸í‰ë„(flattening) fëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœë‹¤ \nf = \\frac{a-b}{a}\n\nIERSëŠ” International Earth Rotation and Reference Systems Serviceì˜ ì•½ìì´ë‹¤.\n\n\nì¼ë°˜ ê²½ë„ì„¸ì°¨, ê²½ì‚¬ê° ë³€í™”ìœ¨, ê²½ë„ ì ë„ì„¸ì°¨, ê²½ì‚¬ê° ì ë„ì„¸ì°¨, ì¥ë™ìƒìˆ˜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nê´€ì„±ì¢Œí‘œê³„(inertial frame of reference)ì—ì„œ ê´€ì¸¡í•œ ì§€êµ¬ëŠ” ìœ„ì˜ ê·¸ë¦¼ ì²˜ëŸ¼ ìì „(Rotation), ì„¸ì°¨(Precession), ì¥ë™(Nutation)ì„ í•œë‹¤. ìì „ì€ ì§€êµ¬ì˜ ì ë„ í‰ë©´ê³¼ ìˆ˜ì§í•œ ì§ì„  ìƒì— ì¡´ì¬í•˜ë©´ì„œ ì§€êµ¬ì˜ ë¶ê·¹ ê·¼ë°©ì— ìˆëŠ” ê´€ì¸¡ìê°€ ì§€êµ¬ë¥¼ ë°”ë¼ë³´ì•˜ì„ ë•Œ ì§€êµ¬ ì „ì²´ê°€ ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ íšŒì „í•˜ëŠ” í˜„ìƒì´ë‹¤. ìì „ ì£¼ê¸°ëŠ” 1ì¼ì´ë‹¤. ì„¸ì°¨ëŠ” ì§€êµ¬ì˜ í™©ë„í‰ë©´ê³¼ ìˆ˜ì§í•œ ì§ì„  ìƒì— ì¡´ì¬í•˜ë©´ì„œ ì§€êµ¬ì˜ ë¶ê·¹ ê·¼ë°©ì— ìˆëŠ” ê´€ì¸¡ìê°€ ì§€êµ¬ë¥¼ ë°”ë¼ë³´ì•˜ì„ ë•Œ ì§€êµ¬ì˜ ìì „ì¶•ì´ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ íšŒì „í•˜ëŠ” í˜„ìƒì´ë‹¤. ì„¸ì°¨ ì£¼ê¸°ëŠ” ì•½ 26000ë…„ì´ë‹¤. ì¥ë™ì€ ì§€êµ¬ì˜ í™©ë„í‰ë©´ê³¼ ìˆ˜ì§í•œ ì§ì„  ìƒì— ì¡´ì¬í•˜ë©´ì„œ ì§€êµ¬ì˜ ë¶ê·¹ ê·¼ë°©ì— ìˆëŠ” ê´€ì¸¡ìê°€ ì§€êµ¬ë¥¼ ë°”ë¼ë³´ì•˜ì„ ë•Œ ì§€êµ¬ì˜ ìì „ì¶•ê³¼ ì§€êµ¬ì˜ ê³µì „ì¶• ì‚¬ì´ì˜ ê°ë„ê°€ ì£¼ê¸°ì ìœ¼ë¡œ ë³€í•˜ëŠ” í˜„ìƒì´ë‹¤. ì¥ë™ ì£¼ê¸°ëŠ” ì•½ 18.61ë…„ì´ë‹¤.\nê·¸ë¦¬ìŠ¤ì˜ íˆíŒŒë¥´ì½”ìŠ¤(Hipparchus of Nicaea)ê°€ ì¶˜ë¶„ì ì´ ì´ë™í•œë‹¤ëŠ” í˜„ìƒì„ BC 127ë…„ì— ë°œê²¬í•¨ìœ¼ë¡œì¨ ì§€êµ¬ì˜ ì„¸ì°¨ìš´ë™ì´ ì•Œë ¤ì¡Œê¸° ë•Œë¬¸ì—, ì—­ì‚¬ì ìœ¼ë¡œ ì§€êµ¬ì˜ ì„¸ì°¨ìš´ë™ì€ ë¶„ì ì˜ ì„¸ì°¨ìš´ë™(precession of the equinoxes)ì´ë¼ê³  ë¶ˆë ¸ë‹¤. ê·¸ëŸ¬ë‚˜ ë‰´í„´ ì´í›„ ì²œì²´ì—­í•™ì´ ë°œë‹¬í•˜ë©´ì„œ ì„¸ì°¨ìš´ë™ì´ íƒœì–‘, ë‹¬, ì§€êµ¬ ì™¸ í–‰ì„±ë“¤ì´ ì§€êµ¬ì— ì‘ìš©í•˜ëŠ” ì¤‘ë ¥ì— ì˜í•´ ë°œìƒí•œë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œê²Œ ë˜ë©´ì„œ ìƒˆë¡œìš´ ìš©ì–´ê°€ ë§Œë“¤ì–´ì¡Œë‹¤. ì£¼ë¡œ íƒœì–‘ê³¼ ë‹¬ì— ì˜í•´ ì§€êµ¬ì˜ ì ë„ í‰ë©´ì´ ë³€í•˜ëŠ” í˜„ìƒì„ ì¼ì›” ì„¸ì°¨(Lunisolar precession), ì£¼ë¡œ ì§€êµ¬ ì™¸ í–‰ì„±ì— ì˜í•´ ì§€êµ¬ì˜ í™©ë„ í‰ë©´ì´ ë³€í•˜ëŠ” í˜„ìƒì„ í–‰ì„± ì„¸ì°¨(Planetary precession)ë¼ê³  ëª…ëª…í–ˆìœ¼ë©°, ì´ ë‘˜ì˜ ê²°í•©ìœ¼ë¡œ ë°œìƒí•˜ëŠ” ì‹¤ì œ ì„¸ì°¨ìš´ë™ì„ ì¼ë°˜ ì„¸ì°¨(General Precession)ë¼ê³  ëª…ëª…í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ íƒœì–‘ê³¼ ë‹¬ì´ ì§€êµ¬ì˜ í™©ë„í‰ë©´ì„ ë³€í™”ì‹œí‚¤ê¸°ë„ í•˜ê³ , ì§€êµ¬ ì™¸ í–‰ì„±ì´ ì§€êµ¬ì˜ ì ë„í‰ë©´ì„ ë³€í™”ì‹œí‚¤ê¸°ë„ í•˜ê¸°ì—, ìš©ì–´ì— ìˆì–´ í˜¼ì„ ì´ ì¡´ì¬í•œë‹¤ëŠ” íŒë‹¨ í•˜ì— 2006ë…„ IAUê°€ ê°ê°ì˜ ìš©ì–´ë¥¼ ì¬ì •ì˜í–ˆë‹¤. ì¦‰ ì¼ì›”ì„¸ì°¨(Lunisolar precession)ë¥¼ ì ë„ ì„¸ì°¨(Precession of the equator)ë¡œ, í–‰ì„± ì„¸ì°¨(Planetary precession)ë¥¼ í™©ë„ ì„¸ì°¨(Precession of the ecliptic)ë¡œ ìš©ì–´ë¥¼ ë°”ê¾¸ì—ˆë‹¤.\n\n\n\n\n\nìœ„ ê·¸ë¦¼ì€ ì§€êµ¬ì˜ í™©ë„í‰ë©´ê³¼ ìˆ˜ì§í•œ ì§ì„  ìƒì— ì¡´ì¬í•˜ë©´ì„œ ì§€êµ¬ì˜ ë¶ê·¹ ê·¼ë°©ì— ìˆëŠ” ê´€ì¸¡ìê°€ ì§€êµ¬ë¥¼ ë°”ë¼ë³´ì•˜ì„ ë•Œ ì²œêµ¬ì˜ ë¶ê·¹(ì§€êµ¬ ìì „ì¶•ì˜ ëë¶€ë¶„)ì´ ì´ë™í•˜ëŠ” ê²½ë¡œë¥¼ ë‚˜íƒ€ë‚¸ ê²ƒì´ë‹¤. ì ì„ ì˜ ìš´ë™ê²½ë¡œ(path of mean celestial pole)ëŠ” ì„¸ì°¨ìš´ë™ì— ì˜í•œ ê²½ë¡œì´ê³ , ì‹¤ì„ ì˜ ìš´ë™ê²½ë¡œ(path of instantaneous celestial pole)ëŠ” ì„¸ì°¨ìš´ë™ì— ì˜í•œ ì›ìš´ë™ì— ì¥ë™ìš´ë™ì— ì˜í•œ íƒ€ì›ìš´ë™ì´ ê²°í•©ëœ ìš´ë™ì— ì˜í•œ ê²½ë¡œì´ë‹¤. ì²œêµ¬ì˜ ë¶ê·¹ì´ ì ì„ ì˜ ìš´ë™ê²½ë¡œë¥¼ ë”°ë¼ ì´ë™í•˜ëŠ” ê°ì†ë ¥ì„ ì¼ë°˜ ê²½ë„ì„¸ì°¨(General precession in longitude) p_Aë¼ê³  í•œë‹¤. ì¥ë™ìš´ë™ì— ì˜í•´ ì²œêµ¬ì˜ ë¶ê·¹ì€ êµ­ì†Œì ì¸ íƒ€ì›ìš´ë™ì„ í•˜ê²Œ ë˜ëŠ”ë°, ì´ íƒ€ì›ì˜ ì¥ë°˜ê²½(semi-major axis)ì„ ì¥ë™ì¥ìˆ˜(constant of nutation) Nì´ë¼ í•œë‹¤.\n\n\n\n\n\nEquinoctial colureëŠ” ì²œêµ¬ì˜ ë¶ê·¹(Celestial North Pole), ì²œêµ¬ì˜ ë‚¨ê·¹(Celestial South Pole), ì¶˜ë¶„ì (Vernal Equinox), ì¶”ë¶„ì (Autumnal Equinox)ì„ ì§€ë‚˜ëŠ” ëŒ€ì›ì´ë‹¤. Solstitial colureëŠ” ì²œêµ¬ì˜ ë¶ê·¹(Celestial North Pole), ì²œêµ¬ì˜ ë‚¨ê·¹(Celestial South Pole), í•˜ì§€ì (Summer Solstice), ë™ì§€ì (Winter Solstice)ì„ ì§€ë‚˜ëŠ” ëŒ€ì›ì´ë‹¤.\nì–´ëŠ ì‹œì ì—ì„œì˜ \\epsilon_AëŠ” ê·¸ ì‹œì ì—ì„œì˜ í™©ë„(ecliptic of date)ì™€ ê·¸ ì‹œì ì—ì„œì˜ í‰ê·  ì ë„(mean equator of date)ê°€ ì´ë£¨ëŠ” ê°ë„ì´ë‹¤. ì–´ëŠ ì‹œì ì—ì„œì˜ \\psi_AëŠ” ê·¸ ì‹œì ì—ì„œì˜ solstital colure(solstital colure of date)ì™€ ì—­ê¸°ì ì—ì„œì˜ solstital colure(solstitial colure of epoch)ê°€ ì´ë£¨ëŠ” ê°ë„ì´ë‹¤. ì–´ëŠ ì‹œì ì—ì„œì˜ \\omega_AëŠ” ê·¸ ì‹œì ì—ì„œì˜ í‰ê· ì ë„(mean equator of date)ì™€ ì—­ê¸°ì ì—ì„œì˜ ê³ ì •ëœ í™©ë„(fixed ecliptic of epoch)ê°€ ì´ë£¨ëŠ” ê°ë„ì´ë‹¤. P03 precession modelì— ì˜í•´ ì£¼ì–´ì§€ëŠ” ê°ê°ì˜ ê°’ì„ tì— ëŒ€í•œ 2ì°¨í•­ ê¹Œì§€ë§Œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n\\epsilon_A = 84381''.406 - 46''.836769t - 0''.0001831t^2\n\n\n\\psi_A = 5038''.481507t - 1''.0790069t^2\n\n\n\\omega_A = 84381''.406 - 0''.025754t + 0''.0512623t^2\n\nì—¬ê¸°ì„œ t = (\\text{TT} - \\text{2000 January 1d 12h TT})/36525 (ê°’ì€ dayë‹¨ìœ„ë¡œ ë„£ëŠ”ë‹¤)ëŠ” J2000.0 TT ë¡œë¶€í„° ê²½ê³¼ëœ ì‹œê°„ì„ Julian century ë‹¨ìœ„ë¡œ ë‚˜íƒ€ë‚¸ ê°’ì´ë‹¤.\nJ2000.0 ê²½ì‚¬ê° ë³€í™”ìœ¨(Rate of change in obliquity) \\dot{\\epsilon}ëŠ” \\epsilon_Aë¥¼ tì— ëŒ€í•´ ë¯¸ë¶„í•˜ê³  t=0ì„ ëŒ€ì…í•œ ê°’ìœ¼ë¡œ, J2000.0ì—ì„œì˜ \\epsilon_Aì˜ ì‹œê°„ ë³€í™”ìœ¨ì„ ë‚˜íƒ€ë‚¸ë‹¤.\nJ2000.0 ê²½ë„ ì ë„ì„¸ì°¨(Precession of the equator in longitude) \\dot{\\psi}ëŠ” \\psi_Aë¥¼ tì— ëŒ€í•´ ë¯¸ë¶„í•˜ê³  t=0ì„ ëŒ€ì…í•œ ê°’ìœ¼ë¡œ, J2000.0ì—ì„œì˜ \\psi_Aì˜ ì‹œê°„ ë³€í™”ìœ¨ì„ ë‚˜íƒ€ë‚¸ë‹¤.\nJ2000.0 ê²½ì‚¬ê° ì ë„ì„¸ì°¨(Precession of the equator in obliquity) \\dot{\\omega}ëŠ” \\omega_Aë¥¼ tì— ëŒ€í•´ ë¯¸ë¶„í•˜ê³  t=0ì„ ëŒ€ì…í•œ ê°’ìœ¼ë¡œ, J2000.0ì—ì„œì˜ \\omega_Aì˜ ì‹œê°„ ë³€í™”ìœ¨ì„ ë‚˜íƒ€ë‚¸ë‹¤.\n\n\níƒœì–‘ ì‹œì°¨\níƒœì–‘ì—ì„œ ë³¸ ì§€êµ¬ì˜ ì‹œë°˜ê²½(apparent radius, angular radius)ì„ íƒœì–‘ ì‹œì°¨(solar parallax)ë¼ê³  ë¶€ë¥¸ë‹¤.\n\n\nê´‘í–‰ì°¨ ìƒìˆ˜\n\n\n\n\n\nê´‘í–‰ì°¨(aberration)ë€ ê´€ì¸¡ìì˜ ì†ë„ì— ì˜ì¡´í•˜ì—¬ ê´€ì¸¡ëŒ€ìƒì˜ ê²‰ë³´ê¸° ìœ„ì¹˜ê°€ ë°”ë€ŒëŠ” í˜„ìƒì´ë‹¤. ê´€ì¸¡ìê°€ vì˜ ì†ë ¥ìœ¼ë¡œ ì›€ì§ì¸ë‹¤ê³  í•˜ì. ê´€ì¸¡ìê°€ ì›€ì§ì´ëŠ” ë°©í–¥ì„ ê°ë„ë¥¼ ì¸¡ì •í•˜ëŠ” ê¸°ì¤€ì„ ìœ¼ë¡œ ì„¤ì •í•˜ê³ , ê´€ì¸¡ìê°€ ì •ì§€í–ˆì„ ë•Œ íŠ¹ì • ê´€ì¸¡ ëŒ€ìƒì— ëŒ€í•œ ì‹œì„ ë°©í–¥ê³¼ ê¸°ì¤€ì„ ì´ ì´ë£¨ëŠ” ê°ì„ \\theta, ê´€ì¸¡ìê°€ ì›€ì§ì¼ ë•Œ íŠ¹ì • ê´€ì¸¡ ëŒ€ìƒì— ëŒ€í•œ ì‹œì„ ë°©í–¥ê³¼ ê¸°ì¤€ì„ ì´ ì´ë£¨ëŠ” ê°ì„ \\phië¼ê³  í•˜ì. ê·¸ëŸ¬ë©´ v/c \\ll 1ì¼ ë•Œ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.\n\n\\kappa = \\theta - \\phi \\approx v/c\n\nvê°€ ì§€êµ¬ì˜ í‰ê·  ê³µì „ ì†ë„ì¼ë•Œì˜ \\kappaë¥¼ ê´‘í–‰ì°¨ ìƒìˆ˜(constant of aberration)ë¼ê³  ë¶€ë¥¸ë‹¤."
  },
  {
    "objectID": "posts/explain-words/index.html#ì¼ë°˜-ì²œë¬¸ìƒìˆ˜",
    "href": "posts/explain-words/index.html#ì¼ë°˜-ì²œë¬¸ìƒìˆ˜",
    "title": "ì²œë¬¸ìš©ì–´ ì„¤ëª…",
    "section": "ì¼ë°˜ ì²œë¬¸ìƒìˆ˜",
    "text": "ì¼ë°˜ ì²œë¬¸ìƒìˆ˜\n\ní‘œë©´ì¤‘ë ¥, íƒœì–‘ìƒìˆ˜, í‘œë©´íƒˆì¶œì†ë„, í‘œë©´ìœ íš¨ì˜¨ë„, ì „ë³µì‚¬ì—ë„ˆì§€, í‘œë©´ë³µì‚¬ì—ë„ˆì§€\nì§ˆëŸ‰ì´ Mì¸ ì²œì²´ì˜ ë°˜ì§€ë¦„ì´ Rì´ë¼ë©´ í‘œë©´ì¤‘ë ¥ì€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í•  ìˆ˜ ìˆë‹¤.\n\n\\text{í‘œë©´ì¤‘ë ¥} = \\frac{GM}{R^2}\n\níƒœì–‘ìœ¼ë¡œë¶€í„° 1 \\text{ au}ë§Œí¼ ë–¨ì–´ì§„ ë‹¨ìœ„ë©´ì ì— ë‹¨ìœ„ì‹œê°„ë™ì•ˆ í†µê³¼í•˜ëŠ” ì´ íƒœì–‘ì—ë„ˆì§€ë¥¼ íƒœì–‘ìƒìˆ˜ë¼ê³ í•œë‹¤. ì¦‰, r=1 \\text{ au}, L = \\text{ê´‘ë„} ì¼ë•Œ ë‹¤ìŒì„ ì–»ëŠ”ë‹¤.\n\n\\text{íƒœì–‘ìƒìˆ˜} = \\frac{L}{4 \\pi r^2}\n\nì§ˆëŸ‰ì´ Mì¸ ì²œì²´ì˜ ë°˜ì§€ë¦„ì´ Rì´ë¼ë©´ í‘œë©´íƒˆì¶œì†ë„ëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬í•  ìˆ˜ ìˆë‹¤. \n\\text{í‘œë©´íƒˆì¶œì†ë„} = \\sqrt{\\frac{2GM}{R}}\n\nì²œì²´ë¥¼ ê·¸ ì²œì²´ì™€ ê°™ì€ ê´‘ë„ë¥¼ ê°€ì§„ í‘ì²´ë¡œ ê°€ì •í–ˆì„ ë•Œ í‘ì²´ê°€ ê°€ì§€ëŠ” ì—´í‰í˜•ì˜¨ë„ë¥¼ í‘œë©´ìœ íš¨ì˜¨ë„ë¼ê³  í•œë‹¤. \n\\text{í‘œë©´ìœ íš¨ì˜¨ë„} = T_e = \\left( \\frac{F_R}{\\sigma} \\right)^{1/4}\n\nì²œì²´ê°€ ë‹¨ìœ„ ì‹œê°„ ë™ì•ˆ ë°©ì¶œí•˜ëŠ” ì´ì—ë„ˆì§€ë¥¼ ì „ë³µì‚¬ì—ë„ˆì§€(ë˜ëŠ” ê´‘ë„)ë¼ê³  í•œë‹¤. \n\\text{ì „ë³µì‚¬ì—ë„ˆì§€} = L = \\text{ê´‘ë„}\n\nì²œì²´ì˜ ë‹¨ìœ„ í‘œë©´ì ì´ ë‹¨ìœ„ ì‹œê°„ ë™ì•ˆ ë°©ì¶œí•˜ëŠ” ì´ì—ë„ˆì§€ë¥¼ í‘œë©´ë³µì‚¬ì—ë„ˆì§€ë¼ê³  í•œë‹¤. \n\\text{í‘œë©´ë³µì‚¬ì—ë„ˆì§€} = F_R = \\frac{L}{4 \\pi R^2}\n\n\n\nì´ì‹¬ë¥ \në‹«íŒ ê³µì „ ê¶¤ë„ëŠ” íƒ€ì› ê¶¤ë„ì´ê³ , íƒ€ì›ì˜ ì¥ë°˜ê²½ a, ë‹¨ë°˜ê²½ bì— ëŒ€í•´ ê¶¤ë„ì˜ ì´ì‹¬ë¥ (eccentricity) eëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°ëœë‹¤. \ne = \\frac{\\sqrt{a^2 - b^2}}{a}\n\n\n\nì ë„ ìˆ˜í‰ ì‹œì°¨\nì ë„ìƒì˜ í•œ ê´€ì¸¡ì ì²œì •ì— ì²œì²´ê°€ ìœ„ì¹˜í•œë‹¤ê³  í•˜ì. ê·¸ ê´€ì¸¡ìë¡œë¶€í„° ì ë„ë¥¼ ë”°ë¼ 90^\\circë§Œí¼ ë–¨ì–´ì ¸ ìˆëŠ” ê´€ì¸¡ìê°€ ê°™ì€ ì²œì²´ë¥¼ ë°”ë¼ë³¸ë‹¤ê³  í•˜ì. ì´ë•Œ ë‘ ê´€ì¸¡ìì˜ ì‹œì„ ë°©í–¥ì´ ì´ë£¨ëŠ” ê°ì„ ì ë„ ìˆ˜í‰ ì‹œì°¨(equatorial horizontal parallax)ë¼ê³  í•œë‹¤.\në”°ë¼ì„œ ë‹¬ì˜ ì ë„ ìˆ˜í‰ ì‹œì°¨ \\piëŠ” ì§€êµ¬ ì ë„ ë°˜ê²½ R, ì§€êµ¬ ì¤‘ì‹¬ì—ì„œ ë‹¬ê¹Œì§€ì˜ ê±°ë¦¬ rì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§„ë‹¤.\n\n\\pi = \\arcsin \\left( \\frac{R}{r} \\right)\n\n\n\nì¥ë™ì£¼ê¸° (êµì ì£¼ê¸°)\n\n\n\n\n\nì²œì²´ì˜ ê³µì „ê¶¤ë„ê°€ ì–´ë–¤ ê¸°ì¤€í‰ë©´ê³¼ ë§Œë‚˜ëŠ” 2ê°œì˜ ì ì„ í†µí‹€ì–´ì„œ ê¶¤ë„ êµì (orbital node)ì´ë¼ê³  í•˜ë©°, ê¸°ì¤€í‰ë©´ì˜ ì–´ëŠ í•œìª½ì„ ìœ„ìª½ìœ¼ë¡œ ì •ì˜í•˜ì˜€ì„ ë•Œ, ì²œì²´ê°€ ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ì˜¤ëŠ” êµì ì„ ìŠ¹êµì (ascending node), ìœ„ì—ì„œ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ëŠ” êµì ì„ ê°•êµì (descending node)ì´ë¼ê³  í•œë‹¤.\nê¸°ì¤€í‰ë©´ì„ í™©ë„í‰ë©´ìœ¼ë¡œ í•˜ì˜€ì„ë•Œ, ë‹¬ì˜ ê³µì „ê¶¤ë„ì— ëŒ€í•œ ê¶¤ë„êµì ì„ ë‹¬ì˜ êµì (Lunar node)ì´ë¼ê³  í•œë‹¤. ì§€êµ¬ì˜ ì¥ë™ ìš´ë™ì„ ë°œìƒì‹œí‚¤ëŠ” ì£¼ ì›ì¸ì´ ë‹¬ì´ê¸° ë•Œë¬¸ì—, ì´ì— ëŒ€í•œ ë°˜ì‘ìš©ìœ¼ë¡œ ë‹¬ì˜ êµì ì´ ë³€í•˜ê²Œ ëœë‹¤. ë‹¬ì˜ êµì ì´ í™©ë„ë¥¼ ë”°ë¼ í•œë°”í€´ íšŒì „í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ì§€êµ¬ì˜ ì¥ë™ ìš´ë™ì£¼ê¸°ì™€ ê°™ì€ ì•½18.61ë…„ì´ë‹¤. ë”°ë¼ì„œ ì´ê²ƒì„ ì¥ë™ì£¼ê¸°(nodal period) ë˜ëŠ” êµì ì£¼ê¸°(draconic period)ë¼ê³  í•œë‹¤.\n\n\nì‚¬ë¡œìŠ¤ ì£¼ê¸°\nì‚¬ë¡œìŠ¤ì£¼ê¸°(saros)ëŠ” íƒœì–‘, ë‹¬, ì§€êµ¬ì˜ ìƒëŒ€ì  ìœ„ì¹˜ ê´€ê³„ê°€ ë°˜ë³µë˜ëŠ” ì£¼ê¸°ë¡œ, ì •í™•íˆ 223 ì‚­ë§ì›”(synodic month)ì´ë‹¤.\n\n\nì˜¤ì˜¤íŠ¸ ìƒìˆ˜\nì€í•˜ë©´(galactic midplane)ì— ì¡´ì¬í•˜ëŠ”, ì€ê²½(galactic longitude)ì´ \\ellì¸ ì„ì˜ì˜ ì²œì²´ê°€ íƒœì–‘ìœ¼ë¡œë¶€í„° ë–¨ì–´ì§„ ê±°ë¦¬ê°€ dë¼ê³  í•˜ì. ê·¸ëŸ¬ë©´ íƒœì–‘ì— ëŒ€í•œ ê·¸ ì²œì²´ì˜ ìƒëŒ€ì†ë„ì˜ ì‹œì„ ë°©í–¥ ì„±ë¶„(radial component)ê³¼ ì ‘ì„  ë°©í–¥ ì„±ë¶„(tangential component)ì€ ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§„ë‹¤.\n\nv_r \\approx Ad\\sin(2\\ell)\n\n\nv_t \\approx Ad\\sin(2\\ell) + Bd\n\nì—¬ê¸°ì„œ A, Bê°€ ì˜¤ì˜¤íŠ¸ ìƒìˆ˜(Oort constant)ì´ë‹¤."
  },
  {
    "objectID": "posts/explain-words/index.html#ì •ì˜¤í‘œ",
    "href": "posts/explain-words/index.html#ì •ì˜¤í‘œ",
    "title": "ì²œë¬¸ìš©ì–´ ì„¤ëª…",
    "section": "ì •ì˜¤í‘œ",
    "text": "ì •ì˜¤í‘œ\n\nì§€êµ¬ í‰ê·  ê°ìš´ë™ëŸ‰\n\n\n\\text{ì§€êµ¬ í‰ê·  ê°ìš´ë™ëŸ‰} \\rightarrow \\text{ì§€êµ¬ í‰ê·  ê°ì†ë„}\n\nì§€êµ¬ í‰ê·  ê°ì†ë„ëŠ” ì§€êµ¬ì˜ í‰ê·  ìì „ ê°ì†ë„ì´ë‹¤.\n\n\níƒœì–‘-(ì§€êµ¬+ë‹¬) ì§ˆëŸ‰ë¹„\n \n(S/E)(l+\\mu) \\rightarrow (S/E)(1+\\mu)\n\n\n\\because \\frac{S}{E+M_M} = \\frac{S}{E+\\mu E} = \\frac{S}{E}\\frac{1}{1+\\mu} = (S/E)(1+\\mu)\n\n\n\nì „ìë³¼íŠ¸\n \neV = \\frac{e}{c} J \\rightarrow \\text{eV} = (e/\\text{C}) \\text{ J}\n\nì—¬ê¸°ì„œ \\text{J}ëŠ” ì—ë„ˆì§€ì˜ ë‹¨ìœ„ ì¤„(joule)ì´ê³ , (e/\\text{C})ëŠ” ì¿¨ë¡¬(coulomb) ë‹¨ìœ„ë¡œ ë‚˜íƒ€ë‚¸ ê¸°ë³¸ ì „í•˜(elementary charge)ì˜ ê°’ì´ë‹¤."
  },
  {
    "objectID": "posts/explain-words/index.html#ì°¸ê³ ë¬¸í—Œ",
    "href": "posts/explain-words/index.html#ì°¸ê³ ë¬¸í—Œ",
    "title": "ì²œë¬¸ìš©ì–´ ì„¤ëª…",
    "section": "ì°¸ê³ ë¬¸í—Œ",
    "text": "ì°¸ê³ ë¬¸í—Œ\n\nCAPITAINE, Nicole; WALLACE, Patrick T.; CHAPRONT, Jean. Expressions for IAU 2000 precession quantities. Astronomy & Astrophysicsâ€‹, 2003, 412.2: 567-586.\nCARROLL, Bradley W.; OSTLIE, Dale A. An introduction to modern astrophysicsâ€‹. Cambridge University Press, 2017.\nLIESKE, J.H., et al.Â Expressions for the precession quantities based upon the IAU/1976/system of astronomical constants. Astronomy and Astrophysicsâ€‹, 1977, 58: 1-16.\nMCCARTHY, Dennis D.; SEIDELMANN, P.Kenneth. Time: from Earth rotation to atomic physicsâ€‹. Cambridge University Press, 2018.\nVÃ–LGYESI, L. Physical backgrounds of Earthâ€™s rotation, revision of the terminology. Acta Geodaetica et Geophysica Hungaricaâ€‹, 2006, 41.1: 31-44.\nBIPM - Time, https://www.bipm.org/en/bipm/tai/\nFIG Article of the Month - December 2004, https://www.fig.net/resources/monthly_articles/2004/beutLer_july_2004.asp\nFile:Lunar eclipse diagram-en.svg - Wikimedia Commons, https://commons.wikimedia.org/wiki/File:Lunar_eclipse_diagram-en.svg\nFile:Praezession.svg - Wikimedia Commons, https://commons.wikimedia.org/wiki/File:Praezession.svg#mw-jump-to-license\nFile:Simple stellar aberration diagram.svg - Wikimedia Commons, https://commons.wikimedia.org/wiki/File:Simple_stellar_aberration_diagram.svg\nFundamental Physical Constants from NIST, https://pml.nist.gov/cuu/Constants/\nReference Earth Model - WGS84, https://topex.ucsd.edu/geodynamics/14gravity1_2.pdf\nThe Astronomical Almanac Online, http://asa.hmnao.com/index.html\nê¸°ë³¸ë‹¨ìœ„ì˜ ì •ì˜, https://www.kriss.re.kr/standard/view.do?pg=explanation_tab_02"
  },
  {
    "objectID": "posts/low_lou_force_free/index.html",
    "href": "posts/low_lou_force_free/index.html",
    "title": "Low and Lou (1990) force free magnetic fields",
    "section": "",
    "text": "Force free magnetic fields are defined as magnetic fields without Lorentz force\n\\begin{align*}\n\\mathbf{J} \\times \\mathbf{B} & = \\mathbf{0} \\\\\n\\nabla \\cdot \\mathbf{B} & = 0\n\\end{align*}\nIn magnetohydrodynamics (MHD), the current density \\mathbf{J} is given by (in SI units)\n\\mathbf{J} = \\frac{1}{\\mu_0} \\nabla \\times \\mathbf{B}\nTherefore, force free magnetic fields are determined by the following partial differential equations (PDEs)\n\\begin{align*}\n\\mathbf{(\\nabla \\times \\mathbf{B})} \\times \\mathbf{B} & = \\mathbf{0} \\\\\n\\nabla \\cdot \\mathbf{B} & = 0\n\\end{align*}\nThe analytical solution of these PDEs in a general case is unknown. But Low and Lou (1990) shows that we can calculate â€œaxisymmetricâ€ force free fields. If we rotate the plane perpendicular to the axis of symmetry, we can generate a quite general force free fields. In this post, I try to calculate this Low and Lou fields, referencing this code."
  },
  {
    "objectID": "posts/low_lou_force_free/index.html#low-lou-ode",
    "href": "posts/low_lou_force_free/index.html#low-lou-ode",
    "title": "Low and Lou (1990) force free magnetic fields",
    "section": "Low-Lou ODE",
    "text": "Low-Lou ODE\nTo calculate Low and Lou fields, we have to solve the following ordinary differential equation (ODE).\n\\begin{cases}\n\\displaystyle (1-\\mu^2)\\frac{d^2 P}{d\\mu^2} + n(n+1)P + a^2 \\frac{1+n}{n}P^{1 + \\frac{2}{n}} = 0 \\\\\n\\mu = \\cos\\theta \\in [-1, 1] \\\\\nP(-1) = 0 \\\\\nP(1) = 0 \\\\\n\\\\\nP'(-1) = 10 \\text{ for numerical normalization}\n\\end{cases}\n\nFor fixed n, a serves as a eignvalue for this homogenous BVP.\nFor n=1, we can list the positive eigenvalues in ascending order with m=0, 1, 2, ....\nWe denote a eigenvalue as a^2 _{n, m} and the corresponding eigenfunction as P_{n, m}.\nFor n=1, m=0, 1, 2,\n\n\\begin{align}\na^2 _{1, 0} &= 0 \\\\\na^2 _{1, 1} &= 0.425 \\\\\na^2 _{1, 2} &= 2.55 \\\\\n\\end{align}\n\nIf you carefully see the Figure 1 by Low and Lou (1990), we can notice that\nP_{1,0} (\\mu) \\sim \\cos\\left(\\displaystyle\\frac{\\pi}{2} \\mu\\right)\nP_{1,1} (\\mu) \\sim -\\sin\\left(\\displaystyle\\pi \\mu\\right)\nP_{1,2} (\\mu) \\sim -\\cos\\left(\\displaystyle\\frac{3\\pi}{2} \\mu\\right)\nThen we can generally say that\nFor m=0, 2 (even m)\nP_{1,m} (\\mu) \\sim \\cos\\left(\\displaystyle\\frac{(m + 1)\\pi}{2} \\mu\\right)\nFor m=1 (odd m) P_{1,m} (\\mu) \\sim \\sin\\left(\\displaystyle\\frac{(m + 1)\\pi}{2} \\mu\\right)\nThis is the initial guess of the solution.\n\nRewrite Low-Lou ODE using \\mathbf{S}(\\mu)\n\n(1-\\mu^2)P'' + n(n+1)P + a^2 \\frac{1+n}{n}P^{1 + \\frac{2}{n}} = 0\n\n\n\\rightarrow P'' =  \\frac{1}{1-\\mu^2}\\left[- n(n+1)P - a^2 \\frac{1+n}{n}P^{1 + \\frac{2}{n}}\\right]\n\n\n\\rightarrow P'' =  \\frac{-1}{1-\\mu^2 + \\epsilon}\\left[n(n+1)P + a^2 \\frac{1+n}{n}P^{1 + \\frac{2}{n}}\\right]\n\nwhere \\epsilon = 10^{-6} for numerical stability.\nTarget y \n\\mathbf{S}(\\mu) = \\begin{bmatrix}\n                     P(\\mu) \\\\\n                     P'(\\mu)\n                 \\end{bmatrix}\n              = \\begin{bmatrix}\n                     y[0] \\\\\n                     y[1]\n                 \\end{bmatrix}\n\nODE system F(x, y) \n\\frac{d\\mathbf{S}}{d\\mu} = \\mathbf{F}(\\mu, \\mathbf{S}(\\mu))\n                         = \\begin{bmatrix}\n                             P'(\\mu) \\\\\n                             P''(\\mu)\n                           \\end{bmatrix}\n                         = \\begin{bmatrix}\n                             y[1] \\\\\n                            \\displaystyle \\frac{-1}{1-\\mu^2 + \\epsilon}\\left[n(n+1)P + a^2 \\frac{1+n}{n}P^{1 + \\frac{2}{n}}\\right]\n                           \\end{bmatrix}   \n\n\\begin{cases}\n\\mu = \\cos\\theta \\in [-1, 1] \\\\\nP(-1) = 0 \\\\\nP(1) = 0 \\\\\n\\end{cases}\n\n\nP'(-1) = 10\n\nDomain\nmu_span = [-1, 1]\nN = 100 # number of points\nmu = np.linspace(mu_span[0], mu_span[1], N)\nBoundary condition function bc defined from ya, yb\n\n\\text{ya} = \\mathbf{S}(-1) = \\begin{bmatrix}\n                                 P(-1) \\\\\n                                 P'(-1)\n                             \\end{bmatrix}\n                          = \\begin{bmatrix}\n                                 0 \\\\\n                                 10\n                             \\end{bmatrix}\n                          = \\begin{bmatrix}\n                                 \\text{ya}[0] \\\\\n                                 \\text{ya}[1]\n                             \\end{bmatrix}\n\n\n\\text{yb} = \\mathbf{S}(1) = \\begin{bmatrix}\n                                 P(1) \\\\\n                                 P'(1)\n                             \\end{bmatrix}\n                            = \\begin{bmatrix}\n                                 0 \\\\\n                                 ?\n                              \\end{bmatrix}\n                            = \\begin{bmatrix}\n                                 \\text{yb}[0] \\\\\n                                 \\text{yb}[1]\n                              \\end{bmatrix}\n\n\n\\text{bc} = \\begin{bmatrix}\n                 \\text{ya} - \\mathbf{S}(-1) \\\\\n                 \\text{yb} - \\mathbf{S}(1)\n            \\end{bmatrix}\n          = \\begin{bmatrix}\n                 \\text{ya}[0] - 0 \\\\\n                 \\text{ya}[1] - 10 \\\\\n                 \\text{yb}[0] - 0\n            \\end{bmatrix}\n          = \\begin{bmatrix}\n                 \\text{ya}[0] \\\\\n                 \\text{ya}[1] - 10\\\\\n                 \\text{yb}[0]\n            \\end{bmatrix}\n\nInitial guess y0\nFor the given spacing h,\n\n\\begin{align}\n\\text{y0} & = [\\mathbf{S}(-1), \\mathbf{S}(-1 + h), \\mathbf{S}(-1 + 2h), \\cdots, \\mathbf{S}(1)] \\\\\n          & = \\begin{bmatrix}\n                  P(\\mu=-1) & P(\\mu=-1+h) & P(\\mu=-1+2h) & \\cdots & P(\\mu=1) \\\\\n                  P'(\\mu=-1) & P'(\\mu=-1+h) & P'(\\mu=-1+2h) & \\cdots & P'(\\mu=1) \\\\\n               \\end{bmatrix}\n\\end{align}\n\nFor m=0, 2 (even m)\nP_{1,m} (\\mu) \\sim \\cos\\left(\\displaystyle\\frac{(m + 1)\\pi}{2} \\mu\\right)\nFor m=1 (odd m) P_{1,m} (\\mu) \\sim \\sin\\left(\\displaystyle\\frac{(m + 1)\\pi}{2} \\mu\\right)\nif m % 2 == 0:\n    P_init = np.cos(mu * (m + 1) * np.pi / 2)\nelse:\n    P_init = np.sin(mu * (m + 1) * np.pi / 2)\nSince P'(-1) = 10,\ndP_init = 10*np.ones_like(mu)\nThen, together,\nS_init = np.vstack([P_init, dP_init])\n\nimport numpy as np \nfrom scipy.integrate import solve_bvp\nimport matplotlib.pyplot as plt \n\n\ndef find_P_and_a2(n, m):\n\n    # ODE system\n    # Define BVP (Low and Lou 1990)\n    # a2 -&gt; eigenvalue\n    # S = [P, dP/dmu]\n    # F = dSdmu\n    # \n    # dP/dmu = 10 at mu = -1\n    def F(x, y, p):\n        mu = x\n        P = y[0]\n        dP = y[1]\n        a2 = p[0]\n\n        ddP = (-1)*(n*(n+1)*P + a2*((1+n)/n)*P**(1+2/n)) / (1-mu**2 + 1e-6)\n\n        return [dP, ddP] \n\n    # Boundary Condition\n    def bc(ya, yb, p):\n        return [ya[0], ya[1]-10, yb[0]]\n\n    # Domain\n    mu_span = [-1, 1]\n    N = 100\n    mu = np.linspace(mu_span[0], mu_span[1], N)\n\n    # Initial guess\n    # For given m, use different initial guess\n    if m % 2 == 0:\n        P_guess = np.cos(mu * (m + 1) * np.pi / 2)\n    else:\n        P_guess = np.sin(mu * (m + 1) * np.pi / 2)\n\n    # For initial guess of dP/dmu, just use BC value\n    dP_guess = 10*np.ones_like(mu)\n\n    y_guess = np.vstack([P_guess, dP_guess])\n\n    # For each initial eigenvalue, solve the problem.\n    # If it is successful, return that otherwise do not return.\n    # np.vectorize -&gt; for loop & return type : array\n    @np.vectorize\n    def solve_eigenvalue_problem(a2_0):\n        sol = solve_bvp(F, bc, mu, y_guess, p=[a2_0], tol=1e-6)\n        if sol.success == True:\n            return sol\n        else:\n            return None \n\n    a2_0_list = np.linspace(0.0, 10.0, 100)\n\n    results = solve_eigenvalue_problem(a2_0_list)\n    eigenvalues = np.array([sol.p for sol in results if sol is not None])\n\n\n     # round & unique value & sorting\n    eigenvalues = np.sort(np.unique(np.round(eigenvalues, 4)))\n    \n    # The smallest value for given m is desired eigenvalue\n    eigenvalue = eigenvalues[0]\n    # If this eigenvalue is zero for nonzero m, choose the next big eigenvalue\n    if m &gt; 0:\n        if not (eigenvalue &gt; 0):\n            eigenvalue = eigenvalues[1]\n\n    # Solve again with that eigenvalue\n    sol = solve_eigenvalue_problem([eigenvalue])[0]\n    \n    return sol.sol, sol.p[0]\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.grid(True)\nax.axhline(0, color='k', lw=2)\nax.axvline(0, color='k', lw=2)\nax.set_xlabel(r'$\\mu$')\nax.set_ylabel(r'P($\\mu$)')\n\nmu_plot = np.linspace(-1, 1, 1000)\n\nn = 1\nfor m in [0, 1, 2]:\n    \n    S, a2 = find_P_and_a2(n, m)\n    P_plot = S(mu_plot)[0]\n    \n    if a2 &lt; 1e-3:\n        P_label = 'P' r'$_{' f'{n}, {m}' r'}(\\mu)$ with $a^2' r'_{' f'{n}, {m}' r'}$ = 0'\n    else:\n        P_label = 'P' r'$_{' f'{n}, {m}' r'}(\\mu)$ with $a^2' r'_{' f'{n}, {m}' r'}$ = ' f'{a2:.3g}'\n    ax.plot(mu_plot, P_plot, label=P_label)\n\nfig.legend()\n\n\n\n\n\n\n\n\nWe successfuly solve Low-Lou ODE for n=1, m=0, 1, 2. (see Figure 1 by Low and Lou (1990))"
  },
  {
    "objectID": "posts/low_lou_force_free/index.html#parameters",
    "href": "posts/low_lou_force_free/index.html#parameters",
    "title": "Low and Lou (1990) force free magnetic fields",
    "section": "Parameters",
    "text": "Parameters\n\nbounds\nbounds=[x_min, x_max, y_min, y_max, z_min, z_max]\n\n\nresolutions\nresolutions=[Nx, Ny, Nz] where Nx, Ny, Nz respectively mean that the number of points in x-, y-, z-axis.\n\n\nn & m\nP_{n,m}(\\mu) & a^2 _{n,m} are eigenfunction and eigenvalues for Low-Lou ODE with fixed n. And m is just used for denoting differenct eigenfunction and eigenvalues.\n\n\\displaystyle (1-\\mu^2)\\frac{d^2 P_{n,m}}{d\\mu^2} + n(n+1)P_{n,m} + a^2 _{n,m} \\frac{1+n}{n}P_{n,m}^{1 + \\frac{2}{n}} = 0\n\n\n\nl & \\Phi\nSee Figure 2 by Low and Lou (1990)"
  },
  {
    "objectID": "posts/low_lou_force_free/index.html#algorithm",
    "href": "posts/low_lou_force_free/index.html#algorithm",
    "title": "Low and Lou (1990) force free magnetic fields",
    "section": "Algorithm",
    "text": "Algorithm\nFor each physical coordinate (x, y, z),\nCalculate corresponding\n\nlocal Cartesian coordinate (X, Y, Z)\nlocal spherical coordinate (r, \\theta, \\phi)\n\\mu = \\cos\\theta\nP'_{n,m}(\\mu) and P_{n,m}(\\mu) by solving Low-Lou ODE\n(B_r, B_\\theta, B_\\phi)\n(B_X, B_Y, B_Z)\n(B_x, B_y, B_z)\n\nThen, we get a vector (B_x, B_y, B_z) at the point (x, y, z)\nThe local spherical coordinates are\nr = \\sqrt{X^2 + Y^2 + Z^2}\n\\theta= \\arccos\\frac{Z}{r}\n\\phi = \\arctan2\\frac{Y}{X}\nS refers to \\mathbf{S}_{n,m}(\\mu) and a2 refers to a^2 _{n,m}\n\n\\mathbf{S}_{n,m}(\\mu) = \\begin{bmatrix}\n                     P_{n,m}(\\mu) \\\\\n                     P'_{n,m}(\\mu)\n                 \\end{bmatrix}\n\nThe magnetic field is\n\n\\mathbf{B}(r, \\theta, \\phi) = B_r \\hat{r} + B_\\theta \\hat{\\theta} + B_\\phi \\hat{\\phi}\n\nwhere\n\nB_r = \\frac{1}{r^2 \\sin\\theta} \\frac{\\partial A}{\\partial \\theta}\n\n\nB_\\theta = -\\frac{1}{r \\sin\\theta} \\frac{\\partial A}{\\partial r}\n\n\nB_\\phi = \\frac{Q}{r \\sin\\theta}\n\nHere A is\n\nA = (r^{-n})P_{n,m}(\\mu)\n\n\n\\frac{\\partial A}{\\partial \\theta} = (- r^{-n}\\sin\\theta) P'_{n,m}(\\mu)\n\n\n\\frac{\\partial A}{\\partial r} = (-n r^{-n-1}) P_{n,m}(\\mu)\n\nFor n=1,\n\nQ(A) = \\sqrt{a^2 _{n,m}} A^{1 + \\frac{1}{n}}\n\n\n\\alpha = \\sqrt{a^2 _{n,m}} \\left(1 + \\frac{1}{n} \\right) A^{\\frac{1}{n}}\n\n\nimport pyvista as pv\npv.set_jupyter_backend('static')\npv.global_theme.notebook = True\npv.start_xvfb()\n\n\nclass LowLouMag:\n    \"A Low and Lou (1990) NLFFF\"\n\n    \n    def __init__(self, \n                 bounds=[-1,1,-1,1,0,2],\n                 resolutions=[64,64,64],\n                 n=1, m=1,\n                 l=0.3, Phi=np.pi/2):\n        self.bounds = bounds\n        self.resolutions = resolutions\n        self.n = n\n        self.m = m\n        self.l = l\n        self.Phi = Phi\n        \n\n    def __str__(self): \n        return (\n            \"### Low and Lou (1990) NLFFF\\n\"\n            f\"bounds = {self.bounds}&lt;br&gt;\\n\"\n            f\"resolutions = {self.resolutions}&lt;br&gt;\\n\"\n            f\"n = {self.n}&lt;br&gt;\\n\"\n            f\"m = {self.m}&lt;br&gt;\\n\"\n            f\"l = {self.l}&lt;br&gt;\\n\"\n            f\"Phi = {self.Phi/np.pi}Ï€&lt;br&gt;\\n\"\n        )\n    _repr_markdown_ = __str__\n\n\n    def create_physical_coordinates(self):\n        x_1D = np.linspace(self.bounds[0], self.bounds[1], self.resolutions[0])\n        y_1D = np.linspace(self.bounds[2], self.bounds[3], self.resolutions[1])\n        z_1D = np.linspace(self.bounds[4], self.bounds[5], self.resolutions[2])\n        x_spacing = np.diff(x_1D)[0]\n        y_spacing = np.diff(y_1D)[0]\n        z_spacing = np.diff(z_1D)[0]\n        spacing = (x_spacing, y_spacing, z_spacing)\n        origin = (x_1D[0], y_1D[0], z_1D[0]) # The bottom left corner of the data set\n        self.grid = pv.ImageData(dimensions=self.resolutions, spacing=spacing, origin=origin)\n        self.x_1D = x_1D\n        self.y_1D = y_1D\n        self.z_1D = z_1D\n        return self.grid\n    \n\n    def calculate_local_Cartesian_coordinates(self):\n        # information of point source & Z-axis\n        l = self.l\n        Phi = self.Phi\n        \n        # physical coordinates (x, y, z)\n        x = self.grid.x\n        y = self.grid.y\n        z = self.grid.z\n\n        # local Cartesian coordinates (X, Y, Z)\n        X = x*np.cos(Phi) - (z+l)*np.sin(Phi)\n        Y = y\n        Z = x*np.sin(Phi) + (z+l)*np.cos(Phi)\n\n        self.X, self.Y, self.Z = X, Y, Z\n\n\n    def calculate_local_spherical_coordinates(self):\n        # local Cartesian coordinates (X, Y, Z)\n        X = self.X\n        Y = self.Y\n        Z = self.Z\n\n        # local spherical coordinates (r, theta, phi)\n        r = np.sqrt(X**2 + Y**2 + Z**2)\n        theta = np.arccos(Z/r)\n        phi = np.arctan2(Y, X) \n\n        self.r, self.theta, self.phi = r, theta, phi\n\n\n    def calculate_eigenfunctions(self):\n        # calculate mu=cos(theta)\n        mu = np.cos(self.theta)\n\n        # eigenfunction parameter n, m\n        n = self.n\n        m = self.m\n\n        # calculate eigenfunction & its derivates and eigenvalues\n        # S = [P, dP]\n        S, a2 = find_P_and_a2(n, m)\n        P, dP = S(mu)\n\n        self.P, self.dP, self.a2 = P, dP, a2\n\n\n    def calculate_local_spherical_magnetic_fields(self):\n        # eigenfunctions and eigenvalue\n        n, m = self.n, self.m\n        P, dP, a2 = self.P, self.dP, self.a2\n\n        # r, theta info\n        r, theta = self.r, self.theta\n        \n        A = (r**(-n)) * P\n        dA_dtheta = -(r**(-n)) * np.sin(theta) * dP\n        dA_dr = -(n*(r**(-n-1))) * P\n        Q = np.sqrt(a2) * A * np.abs(A)**(1/n)\n        \n        alpha = np.sqrt(a2) * (1 + 1/n) * A**(1/n)\n        \n        Br = (r**2 * np.sin(theta))**(-1) * dA_dtheta\n        Btheta = -1 * (r*np.sin(theta))**(-1) * dA_dr\n        Bphi = (r*np.sin(theta))**(-1) * Q\n        \n        self.Br, self.Btheta, self.Bphi, self.alpha = Br, Btheta, Bphi, alpha\n\n\n    def calculate_local_Cartesian_magnetic_fields(self):\n        Br, Btheta, Bphi = self.Br, self.Btheta, self.Bphi\n        r, theta, phi = self.r, self.theta, self.phi\n        \n        BX = Br * np.sin(theta) * np.cos(phi) + Btheta * np.cos(theta) * np.cos(phi) - Bphi * np.sin(phi)\n        BY = Br * np.sin(theta) * np.sin(phi) + Btheta * np.cos(theta) * np.sin(phi) + Bphi * np.cos(phi)\n        BZ = Br * np.cos(theta) - Bphi * np.sin(theta)\n        \n        self.BX, self.BY, self.BZ = BX, BY, BZ\n\n\n    def calculate_physical_magnetic_fields(self):\n        BX, BY, BZ = self.BX, self.BY, self.BZ\n        Phi = self.Phi\n\n        Bx = BX * np.cos(Phi) + BZ * np.sin(Phi)\n        By = BY\n        Bz = - BX * np.sin(Phi) + BZ * np.cos(Phi)\n        \n        self.Bx, self.By, self.Bz = Bx, By, Bz\n\n    def calculate_final_magnetic_fields(self):\n        bx = self.Bx.reshape(self.resolutions).transpose(2, 1, 0)\n        by = self.By.reshape(self.resolutions).transpose(2, 1, 0)\n        bz = self.Bz.reshape(self.resolutions).transpose(2, 1, 0)\n        return bx, by, bz\n\n    ##------ All in one ------##\n    def calculate(self):\n        self.create_physical_coordinates()\n        self.calculate_local_Cartesian_coordinates()\n        self.calculate_local_spherical_coordinates()\n        self.calculate_eigenfunctions()\n        self.calculate_local_spherical_magnetic_fields()\n        self.calculate_local_Cartesian_magnetic_fields()\n        self.calculate_physical_magnetic_fields()\n        bx, by, bz = self.calculate_final_magnetic_fields()\n        return bx, by, bz\n\n\nb = LowLouMag()\nb\n\nLow and Lou (1990) NLFFF\nbounds = [-1, 1, -1, 1, 0, 2] resolutions = [64, 64, 64] n = 1 m = 1 l = 0.3 Phi = 0.5Ï€\n\n\n\nb.create_physical_coordinates()\n\n\n\n\n\n\n\nImageData\nInformation\n\n\nN Cells\n250047\n\n\nN Points\n262144\n\n\nX Bounds\n-1.000e+00, 1.000e+00\n\n\nY Bounds\n-1.000e+00, 1.000e+00\n\n\nZ Bounds\n0.000e+00, 2.000e+00\n\n\nDimensions\n64, 64, 64\n\n\nSpacing\n3.175e-02, 3.175e-02, 3.175e-02\n\n\nN Arrays\n0\n\n\n\n\n\n\n\n\n\nb.calculate_local_Cartesian_coordinates()\n\n\nb.grid.x[0], b.grid.y[0], b.grid.z[0]\n\n(-1.0, -1.0, 0.0)\n\n\n\nb.X[0], b.Y[0], b.Z[0]\n\n(-0.30000000000000004, -1.0, -1.0)\n\n\n\nb.calculate_local_spherical_coordinates()\n\n\nb.r[0], b.theta[0], b.phi[0]\n\n(1.445683229480096, 2.3346567297775978, -1.8622531212727638)\n\n\n\nb.calculate_eigenfunctions()\n\n\nb.P[0], b.dP[0], b.a2\n\n(2.3671821639686197, 4.145376627987454, 0.4274037235234833)\n\n\n\nb.calculate_local_spherical_magnetic_fields()\n\n\nb.Br[0], b.Btheta[0], b.Bphi[0], b.alpha[0]\n\n(-1.3719698429432043,\n 1.0848561237109233,\n 1.6788928338597737,\n 2.140955710310132)\n\n\n\nb.calculate_local_Cartesian_magnetic_fields()\n\n\nb.BX[0], b.BY[0], b.BZ[0]\n\n(2.108420021547058, 1.185348144787035, -0.26343650351723624)\n\n\n\nb.calculate_physical_magnetic_fields()\n\n\nb.Bx[0], b.By[0], b.Bz[0]\n\n(-0.26343650351723613, 1.185348144787035, -2.108420021547058)\n\n\n\nbx, by, bz = b.calculate_final_magnetic_fields()\n\n\n!pip install -q git+https://github.com/mgjeon/magnetic_field_line.git\n\n\nfrom magplot.base import create_mesh, mag_plotter\n\n\nmesh = create_mesh(bx, by, bz)\n\n\nb_plot = mag_plotter(mesh)\nb_tube, b_bottom, b_dargs = b_plot.create_mesh(i_siz=32, j_siz=32, \n                                               i_resolution=8, j_resolution=8, \n                                               vmin=-100, vmax=100, \n                                               max_time=10000)\n\n\np = pv.Plotter()\np.add_mesh(b_plot.grid.outline())\np.add_mesh(b_bottom, cmap='gray', **b_dargs)\np.add_mesh(b_tube, lighting=False, color='blue')\np.camera_position = 'xy'\np.show_bounds()\np.show()\n\n\n\n\n\n\n\n\n\np = pv.Plotter(off_screen=False)\np.add_mesh(b_plot.grid.outline())\np.add_mesh(pv.Plane(center=(mesh.center[0], mesh.center[1], -1), direction=(0, 0, 1), i_size=64, j_size=64), color='gray')\np.add_mesh(b_bottom.contour(scalars=b_bottom['vector'][:, 2]), cmap='bwr', **b_dargs)\np.add_mesh(b_tube, lighting=False, color='black')\np.camera_position = 'xy'\np.show()\n\n\n\n\n\n\n\n\nIt seems to correspond to Figure 8, not Figure 3. I donâ€™t know why.\n\nmesh_new = create_mesh(*LowLouMag(Phi=np.pi/4).calculate()).reflect((0, 1, 0))\n\nb_plot_new = mag_plotter(mesh_new)\nb_tube_new, b_bottom_new, b_dargs_new = b_plot_new.create_mesh(i_siz=32, j_siz=32, \n                                                   i_resolution=8, j_resolution=8, \n                                                   vmin=-100, vmax=100, \n                                                   max_time=10000)\n\np = pv.Plotter(off_screen=False)\np.add_mesh(b_plot_new.grid.outline())\np.add_mesh(pv.Plane(center=(mesh_new.center[0], mesh_new.center[1], -1), direction=(0, 0, 1), i_size=64, j_size=64), color='gray')\np.add_mesh(b_bottom_new.contour(scalars=b_bottom_new['vector'][:, 2]), cmap='bwr', **b_dargs_new)\np.add_mesh(b_tube_new, lighting=False, color='black')\np.camera_position = 'xy'\np.show()\n\n\n\n\n\n\n\n\n\nmesh_new = create_mesh(*LowLouMag(Phi=0.47).calculate()).reflect((0, 1, 0))\n\nb_plot_new = mag_plotter(mesh_new)\nb_tube_new, b_bottom_new, b_dargs_new = b_plot_new.create_mesh(i_siz=40, j_siz=40, \n                                                   i_resolution=8, j_resolution=8, \n                                                   vmin=-100, vmax=100, \n                                                   max_time=10000)\n\np = pv.Plotter(off_screen=False)\np.add_mesh(b_plot_new.grid.outline())\np.add_mesh(pv.Plane(center=(mesh_new.center[0], mesh_new.center[1], -1), direction=(0, 0, 1), i_size=64, j_size=64), color='gray')\np.add_mesh(b_bottom_new.contour(scalars=b_bottom_new['vector'][:, 2]), cmap='bwr', **b_dargs_new)\np.add_mesh(b_tube_new, lighting=False, color='black')\np.camera_position = 'xy'\np.show()\n\n\n\n\n\n\n\n\n\nmesh_new = create_mesh(*LowLouMag(Phi=0.27).calculate()).reflect((0, 1, 0))\n\nb_plot_new = mag_plotter(mesh_new)\nb_tube_new, b_bottom_new, b_dargs_new = b_plot_new.create_mesh(i_siz=40, j_siz=40, \n                                                   i_resolution=8, j_resolution=8, \n                                                   vmin=-100, vmax=100, \n                                                   max_time=10000)\n\np = pv.Plotter(off_screen=False)\np.add_mesh(b_plot_new.grid.outline())\np.add_mesh(pv.Plane(center=(mesh_new.center[0], mesh_new.center[1], -1), direction=(0, 0, 1), i_size=64, j_size=64), color='gray')\np.add_mesh(b_bottom_new.contour(scalars=b_bottom_new['vector'][:, 2]), cmap='bwr', **b_dargs_new)\np.add_mesh(b_tube_new, lighting=False, color='black')\np.camera_position = 'xy'\np.show()\n\n\n\n\n\n\n\n\nWith reflect((0, 1, 0)), these seems to correspond to Figure 4, 5, and 6, respectively. However, I donâ€™t know why I need to use reflect((0, 1, 0))."
  },
  {
    "objectID": "posts/baisc_GWs/index.html",
    "href": "posts/baisc_GWs/index.html",
    "title": "The very, very basics of gravitational wave",
    "section": "",
    "text": "I use the following sign conventions (Misner, Thorne, and Wheeler 1973) and notations.\n\npartial derivative\n\n\n\\partial_{\\mu} = \\frac{\\partial}{\\partial x^{\\mu}}\n\n\n(- + + +) metric signature\n\nFor example, the Minkowski metric \\eta_{\\mu \\nu} in the Cartesian coordinates is written as the following matrix form. \n[\\eta_{\\mu \\nu}] = [\\eta^{\\mu \\nu}] = \\begin{bmatrix}\n-1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n\nThe general metric tensor is denoted by g_{\\mu \\nu}.\n\nChristoffel symbol\n\n\n\\Gamma^{\\sigma}{}_{\\mu \\nu} = \\frac{1}{2} g^{\\sigma \\alpha}(\\partial_{\\mu} g_{\\alpha \\nu} + \\partial_{\\nu} g_{\\alpha \\mu} - \\partial_{\\alpha} g_{\\mu \\nu})\n\n\nRiemann curvature tensor\n\n\nR^{\\mu}{}_{\\nu \\alpha \\beta} = \\partial_{\\alpha} \\Gamma^{\\mu}{}_{\\nu \\beta} - \\partial_{\\beta} \\Gamma^{\\mu}{}_{\\nu \\alpha} + \\Gamma^{\\mu}{}_{\\sigma \\alpha}\\Gamma^{\\sigma}{}_{\\nu \\beta} - \\Gamma^{\\mu}{}_{\\sigma \\beta}\\Gamma^{\\sigma}{}_{\\nu \\alpha}\n\n\nRicci tensor\n\n\nR_{\\mu \\nu} = R^{\\alpha}{}_{\\mu \\alpha \\nu}\n\n\nRicci scalar\n\n\nR = R^{\\alpha}{}_{\\alpha}\n\n\nEinstein tensor\n\n\nG_{\\mu \\nu} = R_{\\mu \\nu} - \\frac{1}{2} R g_{\\mu \\nu}\n\n\nFour-velocity\n\nIn Minkowski space with the Cartesian coordinates, \n[U^{\\mu}] = \\begin{bmatrix}\n\\gamma c \\\\\n\\gamma u_{x} \\\\\n\\gamma u_{y} \\\\\n\\gamma u_{z} \\\\\n\\end{bmatrix}\n\nHere, the Lorentz factor is denoted by \\displaystyle \\gamma = \\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} and u^2 = u_{x}^2 + u_{y}^2 + u_{z}^2.\n\nEnergy-momentum tensor\n\nperfect fluid\n\n  T^{\\mu \\nu} = \\left(\\rho_{0} + \\frac{p}{c^2}\\right)U^{\\mu}U^{\\nu} + p g^{\\mu \\nu}\n  \n\nHere, \\rho_{0} is the rest mass denstiy and \\rho = \\gamma^2 \\rho_{0} is the relativistic mass density.\n\ndust (p=0)\n\n  T^{\\mu \\nu} = \\rho_{0} U^{\\mu}U^{\\nu}\n  \n\nIn this case, T^{00} = \\rho c^2."
  },
  {
    "objectID": "posts/baisc_GWs/index.html#sign-conventions-and-notations",
    "href": "posts/baisc_GWs/index.html#sign-conventions-and-notations",
    "title": "The very, very basics of gravitational wave",
    "section": "",
    "text": "I use the following sign conventions (Misner, Thorne, and Wheeler 1973) and notations.\n\npartial derivative\n\n\n\\partial_{\\mu} = \\frac{\\partial}{\\partial x^{\\mu}}\n\n\n(- + + +) metric signature\n\nFor example, the Minkowski metric \\eta_{\\mu \\nu} in the Cartesian coordinates is written as the following matrix form. \n[\\eta_{\\mu \\nu}] = [\\eta^{\\mu \\nu}] = \\begin{bmatrix}\n-1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n\nThe general metric tensor is denoted by g_{\\mu \\nu}.\n\nChristoffel symbol\n\n\n\\Gamma^{\\sigma}{}_{\\mu \\nu} = \\frac{1}{2} g^{\\sigma \\alpha}(\\partial_{\\mu} g_{\\alpha \\nu} + \\partial_{\\nu} g_{\\alpha \\mu} - \\partial_{\\alpha} g_{\\mu \\nu})\n\n\nRiemann curvature tensor\n\n\nR^{\\mu}{}_{\\nu \\alpha \\beta} = \\partial_{\\alpha} \\Gamma^{\\mu}{}_{\\nu \\beta} - \\partial_{\\beta} \\Gamma^{\\mu}{}_{\\nu \\alpha} + \\Gamma^{\\mu}{}_{\\sigma \\alpha}\\Gamma^{\\sigma}{}_{\\nu \\beta} - \\Gamma^{\\mu}{}_{\\sigma \\beta}\\Gamma^{\\sigma}{}_{\\nu \\alpha}\n\n\nRicci tensor\n\n\nR_{\\mu \\nu} = R^{\\alpha}{}_{\\mu \\alpha \\nu}\n\n\nRicci scalar\n\n\nR = R^{\\alpha}{}_{\\alpha}\n\n\nEinstein tensor\n\n\nG_{\\mu \\nu} = R_{\\mu \\nu} - \\frac{1}{2} R g_{\\mu \\nu}\n\n\nFour-velocity\n\nIn Minkowski space with the Cartesian coordinates, \n[U^{\\mu}] = \\begin{bmatrix}\n\\gamma c \\\\\n\\gamma u_{x} \\\\\n\\gamma u_{y} \\\\\n\\gamma u_{z} \\\\\n\\end{bmatrix}\n\nHere, the Lorentz factor is denoted by \\displaystyle \\gamma = \\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} and u^2 = u_{x}^2 + u_{y}^2 + u_{z}^2.\n\nEnergy-momentum tensor\n\nperfect fluid\n\n  T^{\\mu \\nu} = \\left(\\rho_{0} + \\frac{p}{c^2}\\right)U^{\\mu}U^{\\nu} + p g^{\\mu \\nu}\n  \n\nHere, \\rho_{0} is the rest mass denstiy and \\rho = \\gamma^2 \\rho_{0} is the relativistic mass density.\n\ndust (p=0)\n\n  T^{\\mu \\nu} = \\rho_{0} U^{\\mu}U^{\\nu}\n  \n\nIn this case, T^{00} = \\rho c^2."
  },
  {
    "objectID": "posts/baisc_GWs/index.html#linearized-gravity",
    "href": "posts/baisc_GWs/index.html#linearized-gravity",
    "title": "The very, very basics of gravitational wave",
    "section": "Linearized gravity",
    "text": "Linearized gravity\nThe Einstein Field Equation (EFE) is\n\nG_{\\mu \\nu} + \\Lambda g_{\\mu \\nu} = \\frac{8 \\pi G}{c^{4}}T_{\\mu \\nu}\n\nwhere \\Lambda is the cosmological constant.\nIn the linearized gravity, we ignore the cosmological constant, i.e.Â \\Lambda = 0.\nThen, EFE is\n\nG_{\\mu \\nu} = \\frac{8 \\pi G}{c^{4}}T_{\\mu \\nu}\n\nConsider the small perturbation h_{\\mu \\nu} of the metric.\n\ng_{\\mu \\nu} = \\eta_{\\mu \\nu} + h_{\\mu \\nu}, \\qquad |h_{\\mu \\nu}| \\ll 1\n\nFor convenience, we define the following two quantities.\n\nh = \\eta^{\\mu \\nu} h_{\\mu \\nu}\n\n\n\\bar{h}_{\\mu \\nu} = h_{\\mu \\nu} - \\frac{1}{2} \\eta_{\\mu \\nu} h\n\nAlso, we use the Lorenz gauge condition \\partial_{\\mu} \\bar{h}^{\\mu}{}_{\\nu} = 0.\nAfter many calculations, we get the following linearized EFE in the Lorenz gauge.\n\n\\Box \\bar{h}_{\\mu \\nu} = - \\frac{16 \\pi G}{c^4} T_{\\mu \\nu}\n\nHere, \\Box = \\eta^{\\mu \\nu}\\partial_{\\mu}\\partial_{\\nu} = \\partial^{\\nu} \\partial_{\\nu} is the dâ€™Alembertian.\nThis is the wave equation.\nIn electrodynamics, the Maxwell equation in the Lorenz gauge \\partial_{\\mu}A^{\\mu}=0 in the Gaussian units is\n\n\\Box A^{\\mu} = -\\frac{4 \\pi}{c} J^{\\mu}\n\nHere, A^{\\mu} is the four-potential and J^{\\mu} is the four-current.\nAs you can see, the form of the linearized EFE is very similar to that of the Maxwell equation which predicts electromagnetic waves. Therefore, we can expect the existence of gravitational waves. The theory of gravitational waves in linearized gravity is also very similar to that of electromagnetic waves. For these reasons, Landau and Lifshitz wrote the famous physics textbook â€œThe Classical Theory of Fieldsâ€ which covers both electrodynamics and relativity."
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html",
    "title": "Stable Diffusion Inference with Diffusers (low-level)",
    "section": "",
    "text": "Create an image using Diffusers library.\n\n\n\n!pip install -qq diffusers transformers scipy ftfy accelerate\n\n\nimport torch\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ndevice\n\n'cuda'\n\n\n\nprompt = [\"a photograph of an astronaut riding a horse\"]\n\nheight = 512  # default height of Stable Diffusion\nwidth = 512  # default width of Stable Diffusion\n\nnum_inference_steps = 50  # Number of denoising steps\n\nguidance_scale = 7.5  # Scale for classifier-free guidance\n\ngenerator = torch.manual_seed(256)  # Seed generator to create the inital latent noise\n\nbatch_size = 2\n\n\nfrom diffusers import LMSDiscreteScheduler, StableDiffusionPipeline\n\nscheduler = LMSDiscreteScheduler.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", subfolder=\"scheduler\"\n)\npipe = StableDiffusionPipeline.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", scheduler=scheduler\n)\n\n\npipe\n\nStableDiffusionPipeline {\n  \"_class_name\": \"StableDiffusionPipeline\",\n  \"_diffusers_version\": \"0.20.2\",\n  \"_name_or_path\": \"CompVis/stable-diffusion-v1-4\",\n  \"feature_extractor\": [\n    \"transformers\",\n    \"CLIPImageProcessor\"\n  ],\n  \"requires_safety_checker\": true,\n  \"safety_checker\": [\n    \"stable_diffusion\",\n    \"StableDiffusionSafetyChecker\"\n  ],\n  \"scheduler\": [\n    \"diffusers\",\n    \"LMSDiscreteScheduler\"\n  ],\n  \"text_encoder\": [\n    \"transformers\",\n    \"CLIPTextModel\"\n  ],\n  \"tokenizer\": [\n    \"transformers\",\n    \"CLIPTokenizer\"\n  ],\n  \"unet\": [\n    \"diffusers\",\n    \"UNet2DConditionModel\"\n  ],\n  \"vae\": [\n    \"diffusers\",\n    \"AutoencoderKL\"\n  ]\n}\n\n\n\npipe = pipe.to(device)\n\n\n\n\n\n# 1. Load the autoencoder model which will be used to decode the latents into image space.\nvae = pipe.vae\n\n# 2. Load the tokenizer and text encoder to tokenize and encode the text.\ntokenizer = pipe.tokenizer\ntext_encoder = pipe.text_encoder\n\n# 3. The UNet model for generating the latents.\nunet = pipe.unet\n\n\n\n\nvae\n\nAutoencoderKL(\n  (encoder): Encoder(\n    (conv_in): Conv2d(3, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n    (down_blocks): ModuleList(\n      (0): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0-1): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (1): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(128, 256, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (2): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(256, 512, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1): ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (3): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0-1): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n      )\n    )\n    (mid_block): UNetMidBlock2D(\n      (attentions): ModuleList(\n        (0): Attention(\n          (group_norm): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (to_q): Linear(in_features=512, out_features=512, bias=True)\n          (to_k): Linear(in_features=512, out_features=512, bias=True)\n          (to_v): Linear(in_features=512, out_features=512, bias=True)\n          (to_out): ModuleList(\n            (0): Linear(in_features=512, out_features=512, bias=True)\n            (1): Dropout(p=0.0, inplace=False)\n          )\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n    (conv_norm_out): GroupNorm(32, 512, eps=1e-06, affine=True)\n    (conv_act): SiLU()\n    (conv_out): Conv2d(512, 8, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  )\n  (decoder): Decoder(\n    (conv_in): Conv2d(4, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n    (up_blocks): ModuleList(\n      (0-1): 2 x UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0-2): 3 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (upsamplers): ModuleList(\n          (0): Upsample2D(\n            (conv): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          )\n        )\n      )\n      (2): UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(512, 256, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1-2): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (upsamplers): ModuleList(\n          (0): Upsample2D(\n            (conv): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          )\n        )\n      )\n      (3): UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(256, 128, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1-2): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n      )\n    )\n    (mid_block): UNetMidBlock2D(\n      (attentions): ModuleList(\n        (0): Attention(\n          (group_norm): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (to_q): Linear(in_features=512, out_features=512, bias=True)\n          (to_k): Linear(in_features=512, out_features=512, bias=True)\n          (to_v): Linear(in_features=512, out_features=512, bias=True)\n          (to_out): ModuleList(\n            (0): Linear(in_features=512, out_features=512, bias=True)\n            (1): Dropout(p=0.0, inplace=False)\n          )\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n    (conv_norm_out): GroupNorm(32, 128, eps=1e-06, affine=True)\n    (conv_act): SiLU()\n    (conv_out): Conv2d(128, 3, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  )\n  (quant_conv): Conv2d(8, 8, kernel_size=(1, 1), stride=(1, 1))\n  (post_quant_conv): Conv2d(4, 4, kernel_size=(1, 1), stride=(1, 1))\n)\n\n\n\ntokenizer\n\nCLIPTokenizer(name_or_path='/root/.cache/huggingface/hub/models--CompVis--stable-diffusion-v1-4/snapshots/133a221b8aa7292a167afc5127cb63fb5005638b/tokenizer', vocab_size=49408, model_max_length=77, is_fast=False, padding_side='right', truncation_side='right', special_tokens={'bos_token': AddedToken(\"&lt;|startoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'eos_token': AddedToken(\"&lt;|endoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'unk_token': AddedToken(\"&lt;|endoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'pad_token': '&lt;|endoftext|&gt;'}, clean_up_tokenization_spaces=True)\n\n\n\ntext_encoder\n\nCLIPTextModel(\n  (text_model): CLIPTextTransformer(\n    (embeddings): CLIPTextEmbeddings(\n      (token_embedding): Embedding(49408, 768)\n      (position_embedding): Embedding(77, 768)\n    )\n    (encoder): CLIPEncoder(\n      (layers): ModuleList(\n        (0-11): 12 x CLIPEncoderLayer(\n          (self_attn): CLIPAttention(\n            (k_proj): Linear(in_features=768, out_features=768, bias=True)\n            (v_proj): Linear(in_features=768, out_features=768, bias=True)\n            (q_proj): Linear(in_features=768, out_features=768, bias=True)\n            (out_proj): Linear(in_features=768, out_features=768, bias=True)\n          )\n          (layer_norm1): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n          (mlp): CLIPMLP(\n            (activation_fn): QuickGELUActivation()\n            (fc1): Linear(in_features=768, out_features=3072, bias=True)\n            (fc2): Linear(in_features=3072, out_features=768, bias=True)\n          )\n          (layer_norm2): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n        )\n      )\n    )\n    (final_layer_norm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n  )\n)\n\n\n\nunet\n\nUNet2DConditionModel(\n  (conv_in): Conv2d(4, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (time_proj): Timesteps()\n  (time_embedding): TimestepEmbedding(\n    (linear_1): Linear(in_features=320, out_features=1280, bias=True)\n    (act): SiLU()\n    (linear_2): Linear(in_features=1280, out_features=1280, bias=True)\n  )\n  (down_blocks): ModuleList(\n    (0): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 320, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=320, out_features=320, bias=False)\n                (to_v): Linear(in_features=320, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=768, out_features=320, bias=False)\n                (to_v): Linear(in_features=768, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=320, out_features=2560, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (1): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 640, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=640, out_features=640, bias=False)\n                (to_v): Linear(in_features=640, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=768, out_features=640, bias=False)\n                (to_v): Linear(in_features=768, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=640, out_features=5120, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=2560, out_features=640, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(320, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(320, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (2): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=768, out_features=1280, bias=False)\n                (to_v): Linear(in_features=768, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(640, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (3): DownBlock2D(\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n  )\n  (up_blocks): ModuleList(\n    (0): UpBlock2D(\n      (resnets): ModuleList(\n        (0-2): 3 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 2560, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(2560, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(2560, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (1): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=768, out_features=1280, bias=False)\n                (to_v): Linear(in_features=768, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 2560, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(2560, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(2560, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (2): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1920, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1920, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1920, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (2): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 640, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=640, out_features=640, bias=False)\n                (to_v): Linear(in_features=640, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=768, out_features=640, bias=False)\n                (to_v): Linear(in_features=768, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=640, out_features=5120, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=2560, out_features=640, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1920, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1920, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1920, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1280, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (2): ResnetBlock2D(\n          (norm1): GroupNorm(32, 960, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(960, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(960, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (3): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 320, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=320, out_features=320, bias=False)\n                (to_v): Linear(in_features=320, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=768, out_features=320, bias=False)\n                (to_v): Linear(in_features=768, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=320, out_features=2560, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 960, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(960, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(960, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1-2): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(640, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n    )\n  )\n  (mid_block): UNetMidBlock2DCrossAttn(\n    (attentions): ModuleList(\n      (0): Transformer2DModel(\n        (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n        (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        (transformer_blocks): ModuleList(\n          (0): BasicTransformerBlock(\n            (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (attn1): Attention(\n              (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_out): ModuleList(\n                (0): Linear(in_features=1280, out_features=1280, bias=True)\n                (1): Dropout(p=0.0, inplace=False)\n              )\n            )\n            (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (attn2): Attention(\n              (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_k): Linear(in_features=768, out_features=1280, bias=False)\n              (to_v): Linear(in_features=768, out_features=1280, bias=False)\n              (to_out): ModuleList(\n                (0): Linear(in_features=1280, out_features=1280, bias=True)\n                (1): Dropout(p=0.0, inplace=False)\n              )\n            )\n            (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (ff): FeedForward(\n              (net): ModuleList(\n                (0): GEGLU(\n                  (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                )\n                (1): Dropout(p=0.0, inplace=False)\n                (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n              )\n            )\n          )\n        )\n        (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n      )\n    )\n    (resnets): ModuleList(\n      (0-1): 2 x ResnetBlock2D(\n        (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n        (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n        (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n        (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        (nonlinearity): SiLU()\n      )\n    )\n  )\n  (conv_norm_out): GroupNorm(32, 320, eps=1e-05, affine=True)\n  (conv_act): SiLU()\n  (conv_out): Conv2d(320, 4, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n)\n\n\n\n\n\n\ntext_input = tokenizer(\n    prompt * batch_size,\n    padding=\"max_length\",\n    max_length=tokenizer.model_max_length,\n    truncation=True,\n    return_tensors=\"pt\",\n).input_ids.to(device)\n\ntext_input.shape, text_input\n\n(torch.Size([2, 77]),\n tensor([[49406,   320,  8853,   539,   550, 18376,  6765,   320,  4558, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407],\n         [49406,   320,  8853,   539,   550, 18376,  6765,   320,  4558, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407]], device='cuda:0'))\n\n\n\nwith torch.no_grad():\n    text_embeddings = text_encoder(text_input)[0]\n\ntext_embeddings.shape, text_embeddings\n\n(torch.Size([2, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]]],\n        device='cuda:0'))\n\n\n\nuncond_input = tokenizer(\n    [\"\"] * batch_size,\n    padding=\"max_length\",\n    max_length=text_input.shape[-1],\n    return_tensors=\"pt\",\n).input_ids.to(device)\n\nuncond_input.shape, uncond_input\n\n(torch.Size([2, 77]),\n tensor([[49406, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407],\n         [49406, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407]], device='cuda:0'))\n\n\n\nwith torch.no_grad():\n    uncond_embeddings = text_encoder(uncond_input)[0]\n\nuncond_embeddings.shape, uncond_embeddings\n\n(torch.Size([2, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]]],\n        device='cuda:0'))\n\n\n\ntext_embeddings = torch.cat([uncond_embeddings, text_embeddings])\n\ntext_embeddings.shape, text_embeddings\n\n(torch.Size([4, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]]],\n        device='cuda:0'))\n\n\n\nlatents = torch.randn(\n    (batch_size, unet.in_channels, height // 8, width // 8),\n    generator=generator,\n).to(device)\n\nlatents.shape, latents\n\n(torch.Size([2, 4, 64, 64]),\n tensor([[[[ 0.1884, -0.6394,  0.1089,  ..., -0.9887, -0.7133, -1.1545],\n           [ 0.4124,  1.5587, -0.3407,  ...,  2.1968, -0.0356, -0.0810],\n           [-1.8912,  0.0528, -0.4425,  ...,  1.3110,  0.7100,  0.6802],\n           ...,\n           [-1.3443, -0.1747, -0.6298,  ...,  0.4572, -0.8584, -0.1284],\n           [-1.7920, -0.6554, -0.0439,  ...,  0.5436,  2.2266, -0.5003],\n           [ 0.6213, -1.3155,  0.7470,  ..., -0.2354,  0.7097,  0.6170]],\n \n          [[-0.5007, -1.4418,  0.2598,  ..., -0.2586,  2.3239, -1.3245],\n           [ 0.8540, -0.4135,  0.5658,  ..., -1.9556,  2.0454, -0.2454],\n           [-0.3212, -1.9329, -1.1598,  ...,  0.7156, -0.7228, -0.6992],\n           ...,\n           [ 0.0180, -0.7993,  2.3330,  ...,  0.2594, -0.0333, -0.0826],\n           [-1.2569, -0.8219,  1.3467,  ...,  0.4792,  1.8265, -0.6156],\n           [-1.9367, -0.0949,  0.0720,  ...,  0.0806,  0.2966, -1.0284]],\n \n          [[ 0.2291, -0.0936, -1.3283,  ...,  1.4995, -0.1965, -0.2879],\n           [-1.0226, -1.2896,  1.6202,  ..., -0.3910, -0.3834,  0.5519],\n           [ 0.5424,  0.2685,  0.4912,  ...,  0.9773, -0.8260,  1.1552],\n           ...,\n           [-1.5280, -0.2530, -1.3748,  ..., -1.4948,  1.3661, -1.1294],\n           [ 0.4241, -0.2996,  1.8231,  ...,  0.6968,  0.8247, -0.0279],\n           [-3.3711, -0.7468, -1.3212,  ..., -0.4128,  0.4621,  2.6297]],\n \n          [[-0.7510, -0.7452, -0.8998,  ..., -1.6957, -0.4004, -0.2596],\n           [-1.2092, -1.8881, -0.5828,  ..., -1.0428, -0.6500,  0.3601],\n           [-0.4254,  0.9478,  1.3083,  ..., -0.0259, -0.4542,  0.4353],\n           ...,\n           [-0.1918,  0.4858,  0.0666,  ...,  0.8505, -0.6606, -0.3193],\n           [ 1.3620,  0.2283,  0.6292,  ..., -0.9271,  1.7018,  0.2161],\n           [-0.3891, -1.8911, -0.7501,  ..., -0.2330, -1.0460,  0.4121]]],\n \n \n         [[[ 0.3649, -1.3183, -1.3308,  ..., -0.5548, -1.3610, -1.9329],\n           [-0.0071,  0.1977,  1.5517,  ..., -1.6664,  1.6551,  0.1798],\n           [-1.0404,  0.6524,  0.4654,  ..., -0.5947, -1.0871,  2.2230],\n           ...,\n           [-0.6844,  0.1692, -0.2559,  ...,  0.5511,  0.9734,  0.7936],\n           [-1.1951,  0.5016,  0.8089,  ...,  0.2337, -0.2213, -1.1724],\n           [-0.5055, -0.7491, -1.4940,  ..., -2.1332,  0.9120,  0.2057]],\n \n          [[ 1.3668, -1.1680, -0.8574,  ..., -0.0635, -1.9132, -0.6023],\n           [ 1.0974, -0.9654,  1.2987,  ...,  1.3187, -0.0241, -0.5427],\n           [-2.0427, -1.4358, -0.7115,  ...,  0.1088,  0.0764,  0.7254],\n           ...,\n           [ 1.0957,  1.4058, -0.0178,  ...,  0.5748,  0.0953,  0.7550],\n           [ 0.4080,  0.8792,  0.6801,  ..., -0.7215,  1.1261,  0.0551],\n           [-0.3183, -2.3306,  0.7155,  ...,  0.4291, -0.2074, -1.1237]],\n \n          [[-0.2401,  0.9229,  0.0212,  ...,  0.2128, -0.4705, -0.3262],\n           [ 0.1108,  0.8909,  0.5309,  ..., -1.7175, -1.6657, -1.7706],\n           [-0.1654, -0.4582, -1.2832,  ...,  0.5297, -0.8363,  1.0293],\n           ...,\n           [-1.3526,  2.1482,  0.5417,  ..., -2.2156, -1.9940, -0.9745],\n           [-0.5821,  0.0492,  0.6693,  ..., -0.8610,  0.5864, -0.6040],\n           [ 1.0180,  1.4447,  0.9563,  ...,  0.9034,  0.7988, -1.7119]],\n \n          [[-1.6146,  0.0868,  0.6415,  ...,  0.2083,  0.4058,  0.2813],\n           [ 0.1969, -0.3334, -0.6526,  ..., -1.4639, -1.6302, -0.6036],\n           [ 0.1556, -0.0859, -0.0230,  ..., -0.7900, -0.3481,  0.8767],\n           ...,\n           [ 0.6056,  0.8374, -0.3834,  ..., -0.6636, -0.4814,  0.8244],\n           [ 0.6982, -0.4884, -1.3777,  ...,  0.5876, -2.0944,  0.0853],\n           [ 0.0388, -0.5761, -0.5116,  ..., -1.6645,  0.1752, -0.1923]]]],\n        device='cuda:0'))\n\n\n\nscheduler.set_timesteps(num_inference_steps)\n\nscheduler.timesteps.shape, pipe.scheduler.timesteps\n\n(torch.Size([50]),\n tensor([999.0000, 978.6122, 958.2245, 937.8367, 917.4490, 897.0612, 876.6735,\n         856.2857, 835.8980, 815.5102, 795.1224, 774.7347, 754.3469, 733.9592,\n         713.5714, 693.1837, 672.7959, 652.4082, 632.0204, 611.6327, 591.2449,\n         570.8571, 550.4694, 530.0816, 509.6939, 489.3061, 468.9184, 448.5306,\n         428.1429, 407.7551, 387.3673, 366.9796, 346.5918, 326.2041, 305.8163,\n         285.4286, 265.0408, 244.6531, 224.2653, 203.8776, 183.4898, 163.1020,\n         142.7143, 122.3265, 101.9388,  81.5510,  61.1633,  40.7755,  20.3878,\n           0.0000], dtype=torch.float64))\n\n\n\n\n\n\n\\tilde{\\boldsymbol{\\epsilon}}_\\theta(\\mathbf{z}_t, \\mathbf{c}) = w\\boldsymbol{\\epsilon}_\\theta(\\mathbf{z}_t, \\mathbf{c}) + (1-w)\\boldsymbol{\\epsilon}_{\\theta}(\\mathbf{z}_t).\n\nHere, \\boldsymbol{\\epsilon}_\\theta(\\mathbf{z}_t, \\mathbf{c}) and \\boldsymbol{\\epsilon}_{\\theta}(\\mathbf{z}_t) are conditional and unconditional \\boldsymbol{\\epsilon}-predictions, given by \\boldsymbol{\\epsilon}_\\theta := (\\mathbf{z}_t - \\alpha_t\\hat{\\mathbf{x}}_\\theta)/\\sigma_t, and w is the guidance weight. Setting w = 1 disables classifier-free guidance, while increasing w &gt; 1 strengthens the effect of guidance.1\n\nfrom tqdm.auto import tqdm\n\nlatents = latents * scheduler.init_noise_sigma\n\nfor t in tqdm(scheduler.timesteps):\n    # expand the latents if we are doing classifier-free guidance to avoid doing two forward passes.\n    latent_model_input = torch.cat([latents] * 2)\n\n    latent_model_input = scheduler.scale_model_input(latent_model_input, t)\n\n    # predict the noise residual\n    with torch.no_grad():\n        noise_pred = unet(\n            latent_model_input, t, encoder_hidden_states=text_embeddings\n        ).sample\n\n    # perform guidance\n    noise_pred_uncond, noise_pred_text = noise_pred.chunk(2)\n    noise_pred = (\n        guidance_scale * noise_pred_text + (1 - guidance_scale) * noise_pred_uncond\n    )\n\n    # compute the previous noisy sample x_t -&gt; x_t-1\n    latents = scheduler.step(noise_pred, t, latents).prev_sample\n\n\n# scale and decode the image latents with vae\nlatents = 1 / 0.18215 * latents\n\nwith torch.no_grad():\n    image = vae.decode(latents).sample\n\n\nfrom PIL import Image\n\nimage = (image / 2 + 0.5).clamp(0, 1)\nimage = image.detach().cpu().permute(0, 2, 3, 1).numpy()\nimages = (image * 255).round().astype(\"uint8\")\npil_images = [Image.fromarray(image) for image in images]\n\n\nfor pil_image in pil_images:\n    display(pil_image)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPatil et al.Â (2022) Stable Diffusion with ğŸ§¨ Diffusers, https://huggingface.co/blog/stable_diffusion"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#install-and-import-libraries",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#install-and-import-libraries",
    "title": "Stable Diffusion Inference with Diffusers (low-level)",
    "section": "",
    "text": "!pip install -qq diffusers transformers scipy ftfy accelerate\n\n\nimport torch\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ndevice\n\n'cuda'\n\n\n\nprompt = [\"a photograph of an astronaut riding a horse\"]\n\nheight = 512  # default height of Stable Diffusion\nwidth = 512  # default width of Stable Diffusion\n\nnum_inference_steps = 50  # Number of denoising steps\n\nguidance_scale = 7.5  # Scale for classifier-free guidance\n\ngenerator = torch.manual_seed(256)  # Seed generator to create the inital latent noise\n\nbatch_size = 2\n\n\nfrom diffusers import LMSDiscreteScheduler, StableDiffusionPipeline\n\nscheduler = LMSDiscreteScheduler.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", subfolder=\"scheduler\"\n)\npipe = StableDiffusionPipeline.from_pretrained(\n    \"CompVis/stable-diffusion-v1-4\", scheduler=scheduler\n)\n\n\npipe\n\nStableDiffusionPipeline {\n  \"_class_name\": \"StableDiffusionPipeline\",\n  \"_diffusers_version\": \"0.20.2\",\n  \"_name_or_path\": \"CompVis/stable-diffusion-v1-4\",\n  \"feature_extractor\": [\n    \"transformers\",\n    \"CLIPImageProcessor\"\n  ],\n  \"requires_safety_checker\": true,\n  \"safety_checker\": [\n    \"stable_diffusion\",\n    \"StableDiffusionSafetyChecker\"\n  ],\n  \"scheduler\": [\n    \"diffusers\",\n    \"LMSDiscreteScheduler\"\n  ],\n  \"text_encoder\": [\n    \"transformers\",\n    \"CLIPTextModel\"\n  ],\n  \"tokenizer\": [\n    \"transformers\",\n    \"CLIPTokenizer\"\n  ],\n  \"unet\": [\n    \"diffusers\",\n    \"UNet2DConditionModel\"\n  ],\n  \"vae\": [\n    \"diffusers\",\n    \"AutoencoderKL\"\n  ]\n}\n\n\n\npipe = pipe.to(device)"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#low-level",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#low-level",
    "title": "Stable Diffusion Inference with Diffusers (low-level)",
    "section": "",
    "text": "# 1. Load the autoencoder model which will be used to decode the latents into image space.\nvae = pipe.vae\n\n# 2. Load the tokenizer and text encoder to tokenize and encode the text.\ntokenizer = pipe.tokenizer\ntext_encoder = pipe.text_encoder\n\n# 3. The UNet model for generating the latents.\nunet = pipe.unet\n\n\n\n\nvae\n\nAutoencoderKL(\n  (encoder): Encoder(\n    (conv_in): Conv2d(3, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n    (down_blocks): ModuleList(\n      (0): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0-1): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (1): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(128, 256, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (2): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(256, 512, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1): ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (downsamplers): ModuleList(\n          (0): Downsample2D(\n            (conv): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(2, 2))\n          )\n        )\n      )\n      (3): DownEncoderBlock2D(\n        (resnets): ModuleList(\n          (0-1): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n      )\n    )\n    (mid_block): UNetMidBlock2D(\n      (attentions): ModuleList(\n        (0): Attention(\n          (group_norm): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (to_q): Linear(in_features=512, out_features=512, bias=True)\n          (to_k): Linear(in_features=512, out_features=512, bias=True)\n          (to_v): Linear(in_features=512, out_features=512, bias=True)\n          (to_out): ModuleList(\n            (0): Linear(in_features=512, out_features=512, bias=True)\n            (1): Dropout(p=0.0, inplace=False)\n          )\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n    (conv_norm_out): GroupNorm(32, 512, eps=1e-06, affine=True)\n    (conv_act): SiLU()\n    (conv_out): Conv2d(512, 8, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  )\n  (decoder): Decoder(\n    (conv_in): Conv2d(4, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n    (up_blocks): ModuleList(\n      (0-1): 2 x UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0-2): 3 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (upsamplers): ModuleList(\n          (0): Upsample2D(\n            (conv): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          )\n        )\n      )\n      (2): UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(512, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(512, 256, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1-2): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n        (upsamplers): ModuleList(\n          (0): Upsample2D(\n            (conv): LoRACompatibleConv(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          )\n        )\n      )\n      (3): UpDecoderBlock2D(\n        (resnets): ModuleList(\n          (0): ResnetBlock2D(\n            (norm1): GroupNorm(32, 256, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(256, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n            (conv_shortcut): LoRACompatibleConv(256, 128, kernel_size=(1, 1), stride=(1, 1))\n          )\n          (1-2): 2 x ResnetBlock2D(\n            (norm1): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (conv1): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (norm2): GroupNorm(32, 128, eps=1e-06, affine=True)\n            (dropout): Dropout(p=0.0, inplace=False)\n            (conv2): LoRACompatibleConv(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n            (nonlinearity): SiLU()\n          )\n        )\n      )\n    )\n    (mid_block): UNetMidBlock2D(\n      (attentions): ModuleList(\n        (0): Attention(\n          (group_norm): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (to_q): Linear(in_features=512, out_features=512, bias=True)\n          (to_k): Linear(in_features=512, out_features=512, bias=True)\n          (to_v): Linear(in_features=512, out_features=512, bias=True)\n          (to_out): ModuleList(\n            (0): Linear(in_features=512, out_features=512, bias=True)\n            (1): Dropout(p=0.0, inplace=False)\n          )\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (conv1): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (norm2): GroupNorm(32, 512, eps=1e-06, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n    (conv_norm_out): GroupNorm(32, 128, eps=1e-06, affine=True)\n    (conv_act): SiLU()\n    (conv_out): Conv2d(128, 3, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  )\n  (quant_conv): Conv2d(8, 8, kernel_size=(1, 1), stride=(1, 1))\n  (post_quant_conv): Conv2d(4, 4, kernel_size=(1, 1), stride=(1, 1))\n)\n\n\n\ntokenizer\n\nCLIPTokenizer(name_or_path='/root/.cache/huggingface/hub/models--CompVis--stable-diffusion-v1-4/snapshots/133a221b8aa7292a167afc5127cb63fb5005638b/tokenizer', vocab_size=49408, model_max_length=77, is_fast=False, padding_side='right', truncation_side='right', special_tokens={'bos_token': AddedToken(\"&lt;|startoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'eos_token': AddedToken(\"&lt;|endoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'unk_token': AddedToken(\"&lt;|endoftext|&gt;\", rstrip=False, lstrip=False, single_word=False, normalized=True), 'pad_token': '&lt;|endoftext|&gt;'}, clean_up_tokenization_spaces=True)\n\n\n\ntext_encoder\n\nCLIPTextModel(\n  (text_model): CLIPTextTransformer(\n    (embeddings): CLIPTextEmbeddings(\n      (token_embedding): Embedding(49408, 768)\n      (position_embedding): Embedding(77, 768)\n    )\n    (encoder): CLIPEncoder(\n      (layers): ModuleList(\n        (0-11): 12 x CLIPEncoderLayer(\n          (self_attn): CLIPAttention(\n            (k_proj): Linear(in_features=768, out_features=768, bias=True)\n            (v_proj): Linear(in_features=768, out_features=768, bias=True)\n            (q_proj): Linear(in_features=768, out_features=768, bias=True)\n            (out_proj): Linear(in_features=768, out_features=768, bias=True)\n          )\n          (layer_norm1): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n          (mlp): CLIPMLP(\n            (activation_fn): QuickGELUActivation()\n            (fc1): Linear(in_features=768, out_features=3072, bias=True)\n            (fc2): Linear(in_features=3072, out_features=768, bias=True)\n          )\n          (layer_norm2): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n        )\n      )\n    )\n    (final_layer_norm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)\n  )\n)\n\n\n\nunet\n\nUNet2DConditionModel(\n  (conv_in): Conv2d(4, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (time_proj): Timesteps()\n  (time_embedding): TimestepEmbedding(\n    (linear_1): Linear(in_features=320, out_features=1280, bias=True)\n    (act): SiLU()\n    (linear_2): Linear(in_features=1280, out_features=1280, bias=True)\n  )\n  (down_blocks): ModuleList(\n    (0): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 320, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=320, out_features=320, bias=False)\n                (to_v): Linear(in_features=320, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=768, out_features=320, bias=False)\n                (to_v): Linear(in_features=768, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=320, out_features=2560, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (1): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 640, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=640, out_features=640, bias=False)\n                (to_v): Linear(in_features=640, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=768, out_features=640, bias=False)\n                (to_v): Linear(in_features=768, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=640, out_features=5120, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=2560, out_features=640, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(320, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(320, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (2): CrossAttnDownBlock2D(\n      (attentions): ModuleList(\n        (0-1): 2 x Transformer2DModel(\n          (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=768, out_features=1280, bias=False)\n                (to_v): Linear(in_features=768, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(640, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n      (downsamplers): ModuleList(\n        (0): Downsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n        )\n      )\n    )\n    (3): DownBlock2D(\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n        )\n      )\n    )\n  )\n  (up_blocks): ModuleList(\n    (0): UpBlock2D(\n      (resnets): ModuleList(\n        (0-2): 3 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 2560, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(2560, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(2560, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (1): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n                (to_k): Linear(in_features=768, out_features=1280, bias=False)\n                (to_v): Linear(in_features=768, out_features=1280, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=1280, out_features=1280, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0-1): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 2560, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(2560, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(2560, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (2): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1920, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1920, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n          (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1920, 1280, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (2): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 640, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=640, out_features=640, bias=False)\n                (to_v): Linear(in_features=640, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=640, out_features=640, bias=False)\n                (to_k): Linear(in_features=768, out_features=640, bias=False)\n                (to_v): Linear(in_features=768, out_features=640, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=640, out_features=640, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((640,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=640, out_features=5120, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=2560, out_features=640, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(640, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1920, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1920, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1920, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1): ResnetBlock2D(\n          (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(1280, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(1280, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (2): ResnetBlock2D(\n          (norm1): GroupNorm(32, 960, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(960, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=640, bias=True)\n          (norm2): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(960, 640, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (upsamplers): ModuleList(\n        (0): Upsample2D(\n          (conv): LoRACompatibleConv(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        )\n      )\n    )\n    (3): CrossAttnUpBlock2D(\n      (attentions): ModuleList(\n        (0-2): 3 x Transformer2DModel(\n          (norm): GroupNorm(32, 320, eps=1e-06, affine=True)\n          (proj_in): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n          (transformer_blocks): ModuleList(\n            (0): BasicTransformerBlock(\n              (norm1): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn1): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=320, out_features=320, bias=False)\n                (to_v): Linear(in_features=320, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm2): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (attn2): Attention(\n                (to_q): Linear(in_features=320, out_features=320, bias=False)\n                (to_k): Linear(in_features=768, out_features=320, bias=False)\n                (to_v): Linear(in_features=768, out_features=320, bias=False)\n                (to_out): ModuleList(\n                  (0): Linear(in_features=320, out_features=320, bias=True)\n                  (1): Dropout(p=0.0, inplace=False)\n                )\n              )\n              (norm3): LayerNorm((320,), eps=1e-05, elementwise_affine=True)\n              (ff): FeedForward(\n                (net): ModuleList(\n                  (0): GEGLU(\n                    (proj): LoRACompatibleLinear(in_features=320, out_features=2560, bias=True)\n                  )\n                  (1): Dropout(p=0.0, inplace=False)\n                  (2): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n                )\n              )\n            )\n          )\n          (proj_out): LoRACompatibleConv(320, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n      (resnets): ModuleList(\n        (0): ResnetBlock2D(\n          (norm1): GroupNorm(32, 960, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(960, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(960, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n        (1-2): 2 x ResnetBlock2D(\n          (norm1): GroupNorm(32, 640, eps=1e-05, affine=True)\n          (conv1): LoRACompatibleConv(640, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=320, bias=True)\n          (norm2): GroupNorm(32, 320, eps=1e-05, affine=True)\n          (dropout): Dropout(p=0.0, inplace=False)\n          (conv2): LoRACompatibleConv(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n          (nonlinearity): SiLU()\n          (conv_shortcut): LoRACompatibleConv(640, 320, kernel_size=(1, 1), stride=(1, 1))\n        )\n      )\n    )\n  )\n  (mid_block): UNetMidBlock2DCrossAttn(\n    (attentions): ModuleList(\n      (0): Transformer2DModel(\n        (norm): GroupNorm(32, 1280, eps=1e-06, affine=True)\n        (proj_in): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n        (transformer_blocks): ModuleList(\n          (0): BasicTransformerBlock(\n            (norm1): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (attn1): Attention(\n              (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_k): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_v): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_out): ModuleList(\n                (0): Linear(in_features=1280, out_features=1280, bias=True)\n                (1): Dropout(p=0.0, inplace=False)\n              )\n            )\n            (norm2): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (attn2): Attention(\n              (to_q): Linear(in_features=1280, out_features=1280, bias=False)\n              (to_k): Linear(in_features=768, out_features=1280, bias=False)\n              (to_v): Linear(in_features=768, out_features=1280, bias=False)\n              (to_out): ModuleList(\n                (0): Linear(in_features=1280, out_features=1280, bias=True)\n                (1): Dropout(p=0.0, inplace=False)\n              )\n            )\n            (norm3): LayerNorm((1280,), eps=1e-05, elementwise_affine=True)\n            (ff): FeedForward(\n              (net): ModuleList(\n                (0): GEGLU(\n                  (proj): LoRACompatibleLinear(in_features=1280, out_features=10240, bias=True)\n                )\n                (1): Dropout(p=0.0, inplace=False)\n                (2): LoRACompatibleLinear(in_features=5120, out_features=1280, bias=True)\n              )\n            )\n          )\n        )\n        (proj_out): LoRACompatibleConv(1280, 1280, kernel_size=(1, 1), stride=(1, 1))\n      )\n    )\n    (resnets): ModuleList(\n      (0-1): 2 x ResnetBlock2D(\n        (norm1): GroupNorm(32, 1280, eps=1e-05, affine=True)\n        (conv1): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        (time_emb_proj): LoRACompatibleLinear(in_features=1280, out_features=1280, bias=True)\n        (norm2): GroupNorm(32, 1280, eps=1e-05, affine=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n        (conv2): LoRACompatibleConv(1280, 1280, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        (nonlinearity): SiLU()\n      )\n    )\n  )\n  (conv_norm_out): GroupNorm(32, 320, eps=1e-05, affine=True)\n  (conv_act): SiLU()\n  (conv_out): Conv2d(320, 4, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n)\n\n\n\n\n\n\ntext_input = tokenizer(\n    prompt * batch_size,\n    padding=\"max_length\",\n    max_length=tokenizer.model_max_length,\n    truncation=True,\n    return_tensors=\"pt\",\n).input_ids.to(device)\n\ntext_input.shape, text_input\n\n(torch.Size([2, 77]),\n tensor([[49406,   320,  8853,   539,   550, 18376,  6765,   320,  4558, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407],\n         [49406,   320,  8853,   539,   550, 18376,  6765,   320,  4558, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407]], device='cuda:0'))\n\n\n\nwith torch.no_grad():\n    text_embeddings = text_encoder(text_input)[0]\n\ntext_embeddings.shape, text_embeddings\n\n(torch.Size([2, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]]],\n        device='cuda:0'))\n\n\n\nuncond_input = tokenizer(\n    [\"\"] * batch_size,\n    padding=\"max_length\",\n    max_length=text_input.shape[-1],\n    return_tensors=\"pt\",\n).input_ids.to(device)\n\nuncond_input.shape, uncond_input\n\n(torch.Size([2, 77]),\n tensor([[49406, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407],\n         [49406, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407, 49407,\n          49407, 49407, 49407, 49407, 49407, 49407, 49407]], device='cuda:0'))\n\n\n\nwith torch.no_grad():\n    uncond_embeddings = text_encoder(uncond_input)[0]\n\nuncond_embeddings.shape, uncond_embeddings\n\n(torch.Size([2, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]]],\n        device='cuda:0'))\n\n\n\ntext_embeddings = torch.cat([uncond_embeddings, text_embeddings])\n\ntext_embeddings.shape, text_embeddings\n\n(torch.Size([4, 77, 768]),\n tensor([[[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [-0.3711, -1.4497, -0.3401,  ...,  0.9489,  0.1867, -1.1034],\n          [-0.5107, -1.4629, -0.2926,  ...,  1.0419,  0.0701, -1.0284],\n          ...,\n          [ 0.5006, -0.9552, -0.6610,  ...,  1.6013, -1.0622, -0.2191],\n          [ 0.4988, -0.9451, -0.6656,  ...,  1.6467, -1.0858, -0.2088],\n          [ 0.4923, -0.8124, -0.4912,  ...,  1.6108, -1.0174, -0.2484]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]],\n \n         [[-0.3884,  0.0229, -0.0522,  ..., -0.4899, -0.3066,  0.0675],\n          [ 0.0290, -1.3258,  0.3085,  ..., -0.5257,  0.9768,  0.6652],\n          [ 0.4595,  0.5617,  1.6663,  ..., -1.9515, -1.2307,  0.0104],\n          ...,\n          [-3.0421, -0.0656, -0.1793,  ...,  0.3943, -0.0190,  0.7664],\n          [-3.0551, -0.1036, -0.1936,  ...,  0.4236, -0.0190,  0.7575],\n          [-2.9854, -0.0832, -0.1715,  ...,  0.4355,  0.0095,  0.7485]]],\n        device='cuda:0'))\n\n\n\nlatents = torch.randn(\n    (batch_size, unet.in_channels, height // 8, width // 8),\n    generator=generator,\n).to(device)\n\nlatents.shape, latents\n\n(torch.Size([2, 4, 64, 64]),\n tensor([[[[ 0.1884, -0.6394,  0.1089,  ..., -0.9887, -0.7133, -1.1545],\n           [ 0.4124,  1.5587, -0.3407,  ...,  2.1968, -0.0356, -0.0810],\n           [-1.8912,  0.0528, -0.4425,  ...,  1.3110,  0.7100,  0.6802],\n           ...,\n           [-1.3443, -0.1747, -0.6298,  ...,  0.4572, -0.8584, -0.1284],\n           [-1.7920, -0.6554, -0.0439,  ...,  0.5436,  2.2266, -0.5003],\n           [ 0.6213, -1.3155,  0.7470,  ..., -0.2354,  0.7097,  0.6170]],\n \n          [[-0.5007, -1.4418,  0.2598,  ..., -0.2586,  2.3239, -1.3245],\n           [ 0.8540, -0.4135,  0.5658,  ..., -1.9556,  2.0454, -0.2454],\n           [-0.3212, -1.9329, -1.1598,  ...,  0.7156, -0.7228, -0.6992],\n           ...,\n           [ 0.0180, -0.7993,  2.3330,  ...,  0.2594, -0.0333, -0.0826],\n           [-1.2569, -0.8219,  1.3467,  ...,  0.4792,  1.8265, -0.6156],\n           [-1.9367, -0.0949,  0.0720,  ...,  0.0806,  0.2966, -1.0284]],\n \n          [[ 0.2291, -0.0936, -1.3283,  ...,  1.4995, -0.1965, -0.2879],\n           [-1.0226, -1.2896,  1.6202,  ..., -0.3910, -0.3834,  0.5519],\n           [ 0.5424,  0.2685,  0.4912,  ...,  0.9773, -0.8260,  1.1552],\n           ...,\n           [-1.5280, -0.2530, -1.3748,  ..., -1.4948,  1.3661, -1.1294],\n           [ 0.4241, -0.2996,  1.8231,  ...,  0.6968,  0.8247, -0.0279],\n           [-3.3711, -0.7468, -1.3212,  ..., -0.4128,  0.4621,  2.6297]],\n \n          [[-0.7510, -0.7452, -0.8998,  ..., -1.6957, -0.4004, -0.2596],\n           [-1.2092, -1.8881, -0.5828,  ..., -1.0428, -0.6500,  0.3601],\n           [-0.4254,  0.9478,  1.3083,  ..., -0.0259, -0.4542,  0.4353],\n           ...,\n           [-0.1918,  0.4858,  0.0666,  ...,  0.8505, -0.6606, -0.3193],\n           [ 1.3620,  0.2283,  0.6292,  ..., -0.9271,  1.7018,  0.2161],\n           [-0.3891, -1.8911, -0.7501,  ..., -0.2330, -1.0460,  0.4121]]],\n \n \n         [[[ 0.3649, -1.3183, -1.3308,  ..., -0.5548, -1.3610, -1.9329],\n           [-0.0071,  0.1977,  1.5517,  ..., -1.6664,  1.6551,  0.1798],\n           [-1.0404,  0.6524,  0.4654,  ..., -0.5947, -1.0871,  2.2230],\n           ...,\n           [-0.6844,  0.1692, -0.2559,  ...,  0.5511,  0.9734,  0.7936],\n           [-1.1951,  0.5016,  0.8089,  ...,  0.2337, -0.2213, -1.1724],\n           [-0.5055, -0.7491, -1.4940,  ..., -2.1332,  0.9120,  0.2057]],\n \n          [[ 1.3668, -1.1680, -0.8574,  ..., -0.0635, -1.9132, -0.6023],\n           [ 1.0974, -0.9654,  1.2987,  ...,  1.3187, -0.0241, -0.5427],\n           [-2.0427, -1.4358, -0.7115,  ...,  0.1088,  0.0764,  0.7254],\n           ...,\n           [ 1.0957,  1.4058, -0.0178,  ...,  0.5748,  0.0953,  0.7550],\n           [ 0.4080,  0.8792,  0.6801,  ..., -0.7215,  1.1261,  0.0551],\n           [-0.3183, -2.3306,  0.7155,  ...,  0.4291, -0.2074, -1.1237]],\n \n          [[-0.2401,  0.9229,  0.0212,  ...,  0.2128, -0.4705, -0.3262],\n           [ 0.1108,  0.8909,  0.5309,  ..., -1.7175, -1.6657, -1.7706],\n           [-0.1654, -0.4582, -1.2832,  ...,  0.5297, -0.8363,  1.0293],\n           ...,\n           [-1.3526,  2.1482,  0.5417,  ..., -2.2156, -1.9940, -0.9745],\n           [-0.5821,  0.0492,  0.6693,  ..., -0.8610,  0.5864, -0.6040],\n           [ 1.0180,  1.4447,  0.9563,  ...,  0.9034,  0.7988, -1.7119]],\n \n          [[-1.6146,  0.0868,  0.6415,  ...,  0.2083,  0.4058,  0.2813],\n           [ 0.1969, -0.3334, -0.6526,  ..., -1.4639, -1.6302, -0.6036],\n           [ 0.1556, -0.0859, -0.0230,  ..., -0.7900, -0.3481,  0.8767],\n           ...,\n           [ 0.6056,  0.8374, -0.3834,  ..., -0.6636, -0.4814,  0.8244],\n           [ 0.6982, -0.4884, -1.3777,  ...,  0.5876, -2.0944,  0.0853],\n           [ 0.0388, -0.5761, -0.5116,  ..., -1.6645,  0.1752, -0.1923]]]],\n        device='cuda:0'))\n\n\n\nscheduler.set_timesteps(num_inference_steps)\n\nscheduler.timesteps.shape, pipe.scheduler.timesteps\n\n(torch.Size([50]),\n tensor([999.0000, 978.6122, 958.2245, 937.8367, 917.4490, 897.0612, 876.6735,\n         856.2857, 835.8980, 815.5102, 795.1224, 774.7347, 754.3469, 733.9592,\n         713.5714, 693.1837, 672.7959, 652.4082, 632.0204, 611.6327, 591.2449,\n         570.8571, 550.4694, 530.0816, 509.6939, 489.3061, 468.9184, 448.5306,\n         428.1429, 407.7551, 387.3673, 366.9796, 346.5918, 326.2041, 305.8163,\n         285.4286, 265.0408, 244.6531, 224.2653, 203.8776, 183.4898, 163.1020,\n         142.7143, 122.3265, 101.9388,  81.5510,  61.1633,  40.7755,  20.3878,\n           0.0000], dtype=torch.float64))\n\n\n\n\n\n\n\\tilde{\\boldsymbol{\\epsilon}}_\\theta(\\mathbf{z}_t, \\mathbf{c}) = w\\boldsymbol{\\epsilon}_\\theta(\\mathbf{z}_t, \\mathbf{c}) + (1-w)\\boldsymbol{\\epsilon}_{\\theta}(\\mathbf{z}_t).\n\nHere, \\boldsymbol{\\epsilon}_\\theta(\\mathbf{z}_t, \\mathbf{c}) and \\boldsymbol{\\epsilon}_{\\theta}(\\mathbf{z}_t) are conditional and unconditional \\boldsymbol{\\epsilon}-predictions, given by \\boldsymbol{\\epsilon}_\\theta := (\\mathbf{z}_t - \\alpha_t\\hat{\\mathbf{x}}_\\theta)/\\sigma_t, and w is the guidance weight. Setting w = 1 disables classifier-free guidance, while increasing w &gt; 1 strengthens the effect of guidance.1\n\nfrom tqdm.auto import tqdm\n\nlatents = latents * scheduler.init_noise_sigma\n\nfor t in tqdm(scheduler.timesteps):\n    # expand the latents if we are doing classifier-free guidance to avoid doing two forward passes.\n    latent_model_input = torch.cat([latents] * 2)\n\n    latent_model_input = scheduler.scale_model_input(latent_model_input, t)\n\n    # predict the noise residual\n    with torch.no_grad():\n        noise_pred = unet(\n            latent_model_input, t, encoder_hidden_states=text_embeddings\n        ).sample\n\n    # perform guidance\n    noise_pred_uncond, noise_pred_text = noise_pred.chunk(2)\n    noise_pred = (\n        guidance_scale * noise_pred_text + (1 - guidance_scale) * noise_pred_uncond\n    )\n\n    # compute the previous noisy sample x_t -&gt; x_t-1\n    latents = scheduler.step(noise_pred, t, latents).prev_sample\n\n\n# scale and decode the image latents with vae\nlatents = 1 / 0.18215 * latents\n\nwith torch.no_grad():\n    image = vae.decode(latents).sample\n\n\nfrom PIL import Image\n\nimage = (image / 2 + 0.5).clamp(0, 1)\nimage = image.detach().cpu().permute(0, 2, 3, 1).numpy()\nimages = (image * 255).round().astype(\"uint8\")\npil_images = [Image.fromarray(image) for image in images]\n\n\nfor pil_image in pil_images:\n    display(pil_image)"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#references",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#references",
    "title": "Stable Diffusion Inference with Diffusers (low-level)",
    "section": "",
    "text": "Patil et al.Â (2022) Stable Diffusion with ğŸ§¨ Diffusers, https://huggingface.co/blog/stable_diffusion"
  },
  {
    "objectID": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#footnotes",
    "href": "posts/stable-diffusion-inference/Stable_Diffusion_Inference_low_level.html#footnotes",
    "title": "Stable Diffusion Inference with Diffusers (low-level)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSaharia et al.Â (2022) Photorealistic Text-to-Image Diffusion Models with Deep Language Understanding, https://arxiv.org/abs/2205.11487â†©ï¸"
  },
  {
    "objectID": "posts/spherical-astronomy/index.html",
    "href": "posts/spherical-astronomy/index.html",
    "title": "Spherical Astronomy",
    "section": "",
    "text": "This post is based on the project report that was written during the astronomical observation class in 2019."
  },
  {
    "objectID": "posts/spherical-astronomy/index.html#introduction",
    "href": "posts/spherical-astronomy/index.html#introduction",
    "title": "Spherical Astronomy",
    "section": "Introduction",
    "text": "Introduction\n\nWhat is the purpose of this post?\nThe purpose of this post is to help you grasp the concept of the celestial sphere and the motions of celestial objects by utilizing the celestial sphere model. In detail, you will learn and understand that diurnal motion is the result of Earthâ€™s rotation, and annual motion is the result of Earthâ€™s revolution. Furthermore, you will gain insights into solar time, sidereal time, the celestial coordinate system (horizontal and equatorial), and coordinate conversion.\n\n\nWhy do you learn this?\nAll astronomical studies are based on the results of astronomical observations. The majority of these observations are conducted on Earth, with some exceptions. However, Earth is not an inertial frame of reference because it both rotates on its axis and orbits the Sun. Consequently, when we observe celestial objects from Earth, we inevitably observe apparent motion due to Earthâ€™s own movements. Therefore, it is essential to identify the apparent motion in the motion of celestial objects. Additionally, all celestial objects are projected onto the celestial sphere, and as a result, their movements occur on the surface of this sphere. For these reasons, learning spherical astronomy is crucial for astronomers."
  },
  {
    "objectID": "posts/spherical-astronomy/index.html#celestial-sphere-model",
    "href": "posts/spherical-astronomy/index.html#celestial-sphere-model",
    "title": "Spherical Astronomy",
    "section": "Celestial Sphere Model",
    "text": "Celestial Sphere Model\n\nCelestial Sphere\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Celestial Sphere is an imaginary sphere with an infinite radius centered at the Earthâ€™s center. While most motions of celestial objects are a result of Earthâ€™s motion, for the sake of convenience, we assume that the Earth is fixed, and all celetial objects are embedded on the surface of the Celetial Sphere. We attribute the motions of celestial objects to the motion of the Celestial Sphere.\nSince the Celestial Sphere is a sphere defined by a set of points equidistant from its center, we designate certain special points or circles for convenience. There are various methods for naming these points and circles, but we typically use Earthâ€™s Rotation, Earthâ€™s Revolution, and Observer. For each of them, we begin by selecting a reference axis and a reference plane that is perpendicular to the axis. We then extend the axis and plane infinitely, resulting in three intersections (two points and one circle), each of which is given a specific name. If additional points or circles on the Celestial Sphere are required, we can refer to 9 intersections (6 points and 3 circles) for reference.\n\nEarthâ€™s Rotation\n\nReference axis: Earthâ€™s rotation axis\nReference plane: The plane containing Earthâ€™s equator\n\n\nTwo points on the Celestial Sphere\n\nCelestial North Pole: The point near Earthâ€™s North Pole\nCelestial South Pole: The point near Earthâ€™s South Pole\n\n\n\nOne circle on the Celestial Sphere\n\nCelestial Equator: The great circle determined by the reference plane of Earthâ€™s Rotation\n\n\n\n\nEarthâ€™s Revolution\n\nReference axis: The axis parallel to Earthâ€™s revolution axis and passing through Earthâ€™s center\nReference plane: The plane containing Earthâ€™s orbital path around the Sun\n\n\nTwo points on the Celestial Sphere\n\nEcliptic North Pole: The point near Earthâ€™s North Pole\nEcliptic South Pole: The point near Earthâ€™s South Pole\n\n\n\nOne circle on the Celestial Sphere\n\nEcliptic: The great circle determined by the reference plane of Earthâ€™s Revolution\n\n\n\n\nObserver\n\nReference axis: The line perpendicular to the reference plane at the observerâ€™s location\nReference plane: The plane parallel to the tangent plane of the Earth at the observerâ€™s location and passing though Earthâ€™s center\n\n\nTwo points on the Celestial Sphere\n\nZenith: The point near observerâ€™s head\nNadir: The point near observerâ€™s feet\n\n\n\nOne circle on the Celestial Sphere\n\nHorizon: The great circle determined by the reference plane of observer\n\n\n\n\nAdditional Points and Circles\n\nCircle on the Celestial Sphere\n\nMeridian: The great circle passing though the Celestial North Pole, the Celestial South Pole, the Zenith, and the Nadir\n\n\n\n4 points on the Ecliptic\n\nVernal Equinox : The point of intersection of the Ecliptic and the Celestial Equator, where the Sun moves from the celestial southern hemisphere to the celestial northern hemisphere\nSummer Solsticeâ€‹ : The point on the Ecliptic nearest to the Celestial North Pole\nAutumnal Equinox : The point of intersection of the Ecliptic and the Celestial Equator, where the Sun moves from the celestial northern hemisphere to the celestial southern hemisphere\nWinter Solsticeâ€‹ : The point on the Ecliptic nearest to the Celestial South Pole\n\n\n\n4 points on the Horizon\n\nNorth pointâ€‹ : The point of intersection of the Horizon and the Meridian near the Celestial North Pole\nEast point : The point on the Horizon located 90 degree clockwise from the North point\nSouth pointâ€‹ : The point of intersection of the Horizon and the Meridian near the Celestial South Pole\nWest point : The point on the Horizon located 90 degree clockwise from the South point\n\n\n\n\nAltitude of Celestial Poles\n\n\n\n\n\n\n\n\n\n\n\n(a) Northern hemisphere observer\n\n\n\n\n\n\n\n\n\n\n\n(b) Southern hemisphere observer\n\n\n\n\n\n\n\nFigureÂ 1: Schematic illustrations explaining the altitude of celestial poles\n\n\n\nFigureÂ 1 (a) represents a situation in which the observer is located in the northern hemisphere, while FigureÂ 1 (b) depicts a case in the southern hemisphere. In these diagrams, the blue line represents the horizon, the red line signifies the celestial equator, the black line is perpendicular to the horizon, the green line is perpendicular to the celestial equator, the orange point represents the observer, the green point represents Polaris, and \\phi denotes the observerâ€™s latitude. From these figures, we can conclude that the altitude of celestial poles is equal to the observerâ€™s latitude.\n\n\n\nEarthâ€™s Rotation\nFirst, letâ€™s review the following concept for convenience.\n\n\n\n\n\n\n\n\n\n\n\n(a) Left-hand screw rule\n\n\n\n\n\n\n\n\n\n\n\n(b) Right-hand screw rule\n\n\n\n\n\n\n\nFigureÂ 2: Illustrations explaining the rotation direction\n\n\n\nFigureÂ 2 (a) illustrates the left-hand screw rule, while FigureÂ 2 (b) illustrates the right-hand screw rule. Imagine youâ€™re directly looking at your thumbs and curling your other fingers. If you focus on your left thumb, the rotation direction is clockwise. Conversely, if you focus on your right thumb, the rotation direction is counterclockwise. To determine the rotation direction, simply observe your thumbs, curl your other fingers, and match the fingerâ€™s rotation direction with the given rotation direction: clockwise for the left hand and counterclockwise for the right hand.\n\n\n\n\n\nIn 3D space, the direction of a rotation vector is uniqe, but the rotation direction is not. Therefore, when describing a rotation, it is necessary to specify the viewpoint or indicate the direction of the rotation vector.\n\n\n\n\n\nIf your right thumb points in the direction of (Celestial) North Pole, then the Earthâ€™s rotation follows right-hand screw rule. In other words, if you were to observe Earthâ€™s North Pole from space, you would see that it rotates counterclockwise. Therefore, the direction of the Earthâ€™s rotation vector is from South Pole to North Pole. Due to relative motion, the celestial sphere appears to rotate in the opposite direction around the Earth.\nWhen you rotate the celestial sphere model, you can observe that the Sun and all celestial objects rise in the east and set in the west in all hemispheres. Furthermore, youâ€™ll notice that at the Sunâ€™s upper culmination (its highest point), it appears in the southern sky in the northern hemisphere and in the northern sky in the southern hemisphere. At the poles, the Sun either remains either continuously visible or permanently hidden.\n\n\nSidereal Time\n\n\n\n\n\nThe (Local) Hour Angle is the inversely measured right ascension from the intersection of the celestial equator and the meridian above horizon. When the hour angle of a celestial object is zero, we call that the celestial object is at its upper culmination.\nThe (Local) Sidereal Time is the hour angle of the vernal equinox. By definition, sidereal time \\Theta of a celestial object is equal to H+\\alpha, where H is hour angle, and \\alpha is right ascension of the celestial object.\n\n\\begin{align*}\n\\text{Sidereal time} = \\Theta & = H_{\\text{vernal equinox}} \\\\\n& = H + \\alpha \\\\\n& = \\alpha_{\\text{celestial object at its upper culmination}}\n\\end{align*}\n\nThe (Local) Solar Time is calculated by adding the hour angle of the Sun to 12 hours.\n\n\\text{Solar time} = S = H_{\\odot} + \\text{12 h}\n\nTherefore, we get the following equation.\n\n\\begin{align*}\n\\text{Sidereal time} = \\Theta & = H_{\\odot} + \\alpha_{\\odot} \\\\\n& = S - \\text{12 h} + \\alpha_{\\odot}\n\\end{align*}\n\nThe right ascension of the Sun \\alpha_{\\odot} increases about +\\text{4 min} per day.\n\n\n\nTime\n\\alpha_{\\odot}\n\n\n\n\nVernal Equinox\n\\text{0 h}\n\n\nSummer Solstice\n\\text{6 h}\n\n\nAutumnal Equinox\n\\text{12 h}\n\n\nWinter Solstice\n\\text{18 h}\n\n\n\nThis solar time is actually local solar time. In Korea, the local solar time of Seoul is that of 127Â° E but our clock uses the local solar time of 135Â° E (UTC+9). As a result, there is a difference of about 8Â° (equivalent to 32 minutes). Therefore, in Seoul, the Sun is at its upper culmination at approximately 12:32 KST."
  },
  {
    "objectID": "posts/spherical-astronomy/index.html#spherical-coordinate-system",
    "href": "posts/spherical-astronomy/index.html#spherical-coordinate-system",
    "title": "Spherical Astronomy",
    "section": "Spherical Coordinate System",
    "text": "Spherical Coordinate System\n\nHorizontal System vs.Â Equatorial System\n\nDefinition of (Az, Alt) in Horizontal System\nAzimuth (Az, A) of a celestial object is the angle (or angular distance) measured commonly clockwise from the south point along the horizon. Azimuth values are typically within the range of [0Â°, 360Â°].\nAltitude (Alt, a) of a celestial object is the angle (or angular distance) measured from the horizon along the great circle passing through the celestial object and the zenith. Altitude values fall within the range [-90Â°, +90Â°]. A positive altitude indicates that the object is above the horizon, while a negative altitude indicates that the object is below the horizon.\n\n\nDefinition of (RA, Dec) in Equatorial System\nRight Ascension (RA, \\alpha) is a celestial longitude, equivalent to Earthâ€™s longtiude, except that it is measured from the vernal equinox instead of Greenwich. It is measured only in the eartward direction.\nDeclination (Dec, \\delta) is a celestial latitude, equivalent to Earthâ€™s latitude, except that N and S are respectively replaced by + and -.\n\n\nA formula to convert (RA, Dec) to (Az, Alt)\n\n\n\n\n\nIn the figure above, the point â€‹P has coordinates (x, y, z) in xyz Cartesian coordinates system, and (x', y', z') in x'y'z' Cartesian coordinates system. Each of these coordinates has the following relations with spherical coordinates in its respective frame.\n\n\\begin{align*}\nx & = \\cos \\theta \\cos \\psi \\\\\ny & = \\cos \\theta \\sin \\psi \\\\\nz & = \\sin \\theta\n\\end{align*}\n\n\n\\begin{align*}\nx' & = \\cos \\theta' \\cos \\psi' \\\\\ny' & = \\cos \\theta' \\sin \\psi' \\\\\nz' & = \\sin \\theta'\n\\end{align*}\n\nThe primed coordinates are related to the unprimed coordinates by the following equations.\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos \\chi & -\\sin \\chi \\\\\n0 & \\sin \\chi & \\cos \\chi\n\\end{bmatrix}\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz'\n\\end{bmatrix}\n\n\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos \\chi & \\sin \\chi \\\\\n0 & -\\sin \\chi & \\cos \\chi\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n\n\n\n\n\n\nIn the figure above, we have \\chi = 90^{\\circ} - \\psi. The values of (x, y, z) and (x', y', z') are determined by the following equations.\n\n\\begin{align*}\nx & = \\cos a \\cos(90^{\\circ} - A) \\\\\n& = \\cos a \\sin A \\\\\ny & = \\cos a \\sin(90^{\\circ} - A) \\\\\n& = \\cos a \\cos A \\\\\nz & = \\sin a\n\\end{align*}\n\n\n\\begin{align*}\nx' & = \\cos \\delta \\cos(90^{\\circ} - H) \\\\\n& = \\cos \\delta \\sin H \\\\\ny' & = \\cos \\delta \\sin(90^{\\circ} - H) \\\\\n& = \\cos \\delta \\cos H \\\\\nz' & = \\sin \\delta\n\\end{align*}\n\nThus, we get the following equations.\n\n\\begin{align*}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n& =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos (90^{\\circ} - \\phi) & -\\sin (90^{\\circ} - \\phi) \\\\\n0 & \\sin (90^{\\circ} - \\phi) & \\cos (90^{\\circ} - \\phi)\n\\end{bmatrix}\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz'\n\\end{bmatrix} \\\\\n& =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\sin \\phi & -\\cos \\phi \\\\\n0 & \\cos \\phi & \\sin \\phi\n\\end{bmatrix}\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz'\n\\end{bmatrix}\n\\end{align*}\n\n\n\\begin{align*}\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\nz'\n\\end{bmatrix}\n& =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos (90^{\\circ} - \\phi) & \\sin (90^{\\circ} - \\phi) \\\\\n0 & -\\sin (90^{\\circ} - \\phi) & \\cos (90^{\\circ} - \\phi)\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix} \\\\\n& =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\sin \\phi & \\cos \\phi \\\\\n0 & -\\cos \\phi & \\sin \\phi\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n\\end{align*}\n\nIn conclusion, we get the following two conversion fomulas.\nWhen we know (\\alpha=\\Theta-H, \\delta, \\phi), we can obtain (A, a) by using following equations.\n\n\\begin{align*}\n\\cos a \\sin A & = \\cos \\delta \\sin H \\\\\n\\cos a \\cos A & = \\sin \\phi \\cos \\delta \\cos H - \\cos \\phi \\sin \\delta \\\\\n\\sin a & = \\cos \\phi \\cos \\delta \\cos H + \\sin \\phi \\sin \\delta\n\\end{align*}\n\nWhen we know (A, a, \\phi), we can obtain (\\alpha=\\Theta-H, \\delta) by using following equations.\n\n\\begin{align*}\n\\cos \\delta \\sin H & = \\cos a \\sin A \\\\\n\\cos \\delta \\cos H & = \\sin \\phi \\cos a \\cos A + \\cos \\phi \\sin a \\\\\n\\sin \\delta & = - \\cos \\phi \\cos a \\cos A + \\sin \\phi \\sin a\n\\end{align*}\n\nTherefore, we can conclude that we need to know sidereal time and latitude when performing conversions between (RA, Dec) and (Az, Alt).\n\n\n\nTargets on Meridian\nLet \\alpha' be the right ascension of celestial object at its upper culmination. By definition of sidereal time, the following equation holds.\n\n\\begin{align*}\n\\Theta & = S - \\text{12 h} + \\alpha_\\odot \\\\\n& = \\alpha'\n\\end{align*}\n\nThus we get the following equation.\n\nS = \\text{12 h} - \\alpha_\\odot + \\alpha'\n\n\n\nHour Angle of Targets\nBy definition of sidereal time, the following equation holds.\n\n\\begin{align*}\n\\Theta & = S - \\text{12 h} + \\alpha_\\odot \\\\\n& = H + \\alpha\n\\end{align*}\n\nThus we get the following equation.\n\nH = S - \\text{12 h} + \\alpha_\\odot - \\alpha"
  },
  {
    "objectID": "posts/spherical-astronomy/index.html#references",
    "href": "posts/spherical-astronomy/index.html#references",
    "title": "Spherical Astronomy",
    "section": "References",
    "text": "References\n\nIntroductory Astronomy: The Celestial Sphere, http://astro.wsu.edu/worthey/astro/html/lec-celestial-sph.html\nMeridian (astronomy), https://en.wikipedia.org/wiki/Meridian_(astronomy)\nRight hand screw rule, https://www3.eng.cam.ac.uk/~hemh1/gyroscopes/screwrule.html\nRotation Vs. Revolution: What Are The Differences?, https://differencecamp.com/rotation-vs-revolution\nSUPPLEMENT: MOTIONS IN THE SKY & COORDINATE SYSTEMS, https://rwoconne.github.io/rwoclass/astr1230/motions-coords.html\nHannu Karttunen et al.Â â€‹Fundamental Astronomyâ€‹. Sixth Edition. Springer (2016)"
  }
]